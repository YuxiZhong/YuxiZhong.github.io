<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>神经科学基础</title>
      <link href="/post/751f48d7.html"/>
      <url>/post/751f48d7.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Brodmann分区"><a href="#Brodmann分区" class="headerlink" title="Brodmann分区"></a>Brodmann分区</h1><p><a href="https://www.kenhub.com/en/library/anatomy/brodmann-areas">Brodmann areas: Anatomy and functions | Kenhub</a></p><center class="half">    <img src="https://s2.loli.net/2024/10/02/pewuB2ZNRaqigL8.png" width="500"/>    <img src="https://s2.loli.net/2024/10/02/H2Tq1VuWMlsS9bL.png" width="540"/></center><ul><li>==<strong>Areas 3, 1 &amp; 2</strong>== – Primary Somatosensory Cortex (frequently referred to as Areas 3, 1, 2 by convention) 初级躯体感觉皮层（中央后回）<ul><li>触摸、温度、振动、疼痛的定位  <u>（是否存在更细的划分？）</u></li><li><strong>感觉知觉</strong> sensory perception（两点辨别、本体感觉等）尤其是腿、躯干、手臂、手、脸和嘴唇</li><li>熟练且协调的<strong>口面部运动</strong>（如吹口哨）</li><li>运动学习</li></ul></li><li>==<strong>Area 4</strong>== – Primary Motor Cortex 初级运动皮层 （中央前回），可能包含area 6的一部分<ul><li><strong>运动执行</strong>，包括对侧手指/手/手腕或口面部运动、学习运动序列、呼吸控制和自愿眨眼。（对侧指的是左脑控制右侧，右脑控制左侧）</li></ul></li><li>==<strong>Area 5</strong>== – Somatosensory Association Cortex 躯体感觉联络皮层 Superior parietal lobule 顶上小叶<ul><li>立体视觉</li><li>线等分判断（判断一条线段有没有被等分）（顶叶受损：单侧空间忽略）</li><li>处理混沌的模式</li><li>在演绎推理中使用空间意向</li><li>运动执行</li><li>双手操纵</li><li>工作记忆</li><li>语言处理</li><li>视觉运动注意力</li><li>疼痛知觉</li></ul></li><li>==<strong>Area 6</strong>== – Premotor cortex and Supplementary Motor Cortex (Secondary Motor Cortex) (Supplementary motor area) 前运动区和辅助运动区皮层（次级运动皮层）</li><li>Area 7 – Somatosensory Association Cortex 躯体感觉联络皮层</li><li>Area 8 – Includes Frontal eye fields 包含额叶眼动区</li><li>==<strong>Area 9</strong>== – Dorsolateral/anterior prefrontal cortex (motor planning, and organization) 前额叶背外侧/前部皮层（运动规划/协调组织）</li><li>==<strong>Area 10</strong>== – Anterior prefrontal cortex (most rostral part of superior and middle frontal gyri) 前额叶前部皮层（额上回和额中回最嘴侧部分）（记忆检索）</li><li>Area 11 – Orbitofrontal area (orbital and rectus gyri, plus part of the rostral part of the superior frontal gyrus) 额眶区（眶回和直回，以及额上回嘴侧的一部分）</li><li>Area 12 – Orbitofrontal area (used to be part of BA11, refers to the area between the superior frontal gyrus and the inferior rostral sulcus) 额眶区（以往是Brodmann Area 11的一部分，位于额上回与下嘴沟之间的区域）</li><li>Area 13 and Area 14* – Insular cortex 岛叶皮层</li><li>Area 15 – Anterior Temporal Lobe 前颞叶</li><li>Area 16 – Insular cortex 岛叶皮层</li><li>==<strong>Area 17</strong>== – Primary visual cortex (V1) 初级视觉皮层</li><li>Area 18 – Secondary visual cortex (V2) 次级视觉皮层</li><li>Area 19 – Associative visual cortex (V3, V4, V5) 视觉联络皮层</li><li>Area 20 – Inferior temporal gyrus 颞下回</li><li>Area 21 – Middle temporal gyrus 颞中回</li><li>==<strong>Area 22</strong>== – 1. Superior temporal gyrus, of which the caudal part is usually considered to contain the Wernicke’s area 颞上回，其尾侧部分通常认为包含Wernicke区（语言理解） 2. Primary auditory cortex 初级听觉皮层</li><li>Area 23 – Ventral posterior cingulate cortex 扣带回腹侧后部皮层</li><li>Area 24 – Ventral anterior cingulate cortex 扣带回腹侧前部皮层 前扣带皮层</li><li>Area 25 – Subgenual area (part of the ventromedial prefrontal cortex) 胼胝体膝部下区域（前额叶腹内侧皮层的一部分）</li><li>Area 26 – Ectosplenial portion of the retrosplenial region of the cerebral cortex 胼胝体压部后方皮层的压部外部分</li><li>Area 27 – Piriform cortex 梨状皮层</li><li>Area 28 – Ventral entorhinal cortex 内嗅皮层腹侧部</li><li>Area 29 – Retrosplenial cingulate cortex 扣带回胼胝体压部后皮层</li><li>Area 30 – Part of cingulate cortex 扣带回皮层的一部分</li><li>Area 31 – Dorsal Posterior cingulate cortex 扣带回背侧后部皮层</li><li>Area 32 – Dorsal anterior cingulate cortex 扣带回背侧前部皮层</li><li>Area 33 – Part of anterior cingulate cortex 扣带回前部皮层的一部分</li><li>Area 34 – Dorsal entorhinal cortex (on the Parahippocampal gyrus) 内嗅皮层背侧部（位于海马旁回）</li><li>Area 35 – Perirhinal cortex (in the rhinal sulcus) 嗅周皮层（位于嗅脑沟）</li><li>Area 36 – Ectorhinal area, now part of the perirhinal cortex (in the rhinal sulcus) 外嗅区，目前为嗅周皮层的一部分（位于嗅脑沟）</li><li>==<strong>Area 37</strong>== – Occipitotemporal (fusiform) gyrus 枕颞（梭状）回</li><li>Area 38 – Temporopolar area (most rostral part of the superior and middle temporal gyri) 颞极区（颞上回和颞中回的最嘴侧部分）</li><li>Area 39 – Angular gyrus, considered by some to be part of Wernicke’s area 角回，有人认为是Wernicke区的一部分</li><li>Area 40 – Supramarginal gyrus, considered by some to be part of Wernicke’s area 缘上回，有人认为是Wernicke区的一部分</li><li>Areas 41 and 42 – Auditory cortex 听觉皮层</li><li>Area 43 – Primary gustatory cortex 初级味觉皮层</li><li>Area 44 – Pars opercularis, part of the inferior frontal gyrus and part of Broca’s area 额下回盖部，Broca区的一部分</li><li>Area 45 – Pars triangularis, part of the inferior frontal gyrus and part of Broca’s area 额下回三角部，Broca区的一部分</li><li>Area 46 – Dorsolateral prefrontal cortex 前额叶背外侧部皮层</li><li>Area 47 – Pars orbitalis, part of the inferior frontal gyrus 额下回眶部</li><li>Area 48 – Retrosubicular area (a small part of the medial surface of the temporal lobe) 下托后区（颞叶内侧面的一小部分）</li><li>Area 49 – Parasubicular area in a rodent 啮齿动物的下托旁区</li><li>Area 52 – Parainsular area (at the junction of the temporal lobe and the insula) 岛叶旁区（颞叶与岛叶的交界部）</li></ul><p><img src="https://s2.loli.net/2024/10/15/ul54xs23zZriVtw.png" alt="Premotor_cortex" style="zoom: 50%;" /></p><center class="half">    <img src="https://s2.loli.net/2024/10/05/batdHKzykpcADCW.png" width="500"/>    <img src="https://s2.loli.net/2024/10/05/EQ8GZYTjmfsrLuK.png" width="520"/></center><hr><h1 id="The-Brain-and-Spinal-Cord"><a href="#The-Brain-and-Spinal-Cord" class="headerlink" title="The Brain and Spinal Cord"></a>The Brain and Spinal Cord</h1><p><a href="https://open.oregonstate.education/aandp/chapter/14-3-the-brain-and-spinal-cord/">14.3 The Brain and Spinal Cord – Anatomy &amp; Physiology (oregonstate.education)</a></p><h3 id="1-大脑皮层-Cerebral-Cortex"><a href="#1-大脑皮层-Cerebral-Cortex" class="headerlink" title="1. 大脑皮层 Cerebral Cortex"></a>1. 大脑皮层 Cerebral Cortex</h3><h4 id="Frontal-额叶"><a href="#Frontal-额叶" class="headerlink" title="Frontal 额叶"></a><strong>Frontal 额叶</strong></h4><ul><li>4：中央前回，“primary motor cortex” (<a href="zotero://open-pdf/library/items/BBUPRFJ4?sel=%23fs-id1119780">snapshot</a>) 初级运动皮层M1。upper motor neurons，脊髓和脑干中的细胞（lower motor neuron）移动骨骼肌。</li><li>6、8：premotor area，前运动皮层。运动规划、复杂运动算法。</li><li>8下部：frontal eye fields 额叶眼动区。扫视、注视的眼球运动。</li><li>44、45：Broca‘s area。语言的产生、言语的控制。涉及言语的表达。</li><li>Prefrontal lobe：前额叶。认知功能，人格、短期记忆、意识。</li></ul><h4 id="Parietal-顶叶"><a href="#Parietal-顶叶" class="headerlink" title="Parietal 顶叶"></a><strong>Parietal 顶叶</strong></h4><ul><li>1、2、3：中央后回，“primary somatosensory cortex” (<a href="zotero://open-pdf/library/items/BBUPRFJ4?sel=%23fs-id1319713">snapshot</a>) 初级体感皮层S1。触觉、本体感觉、运动感觉。</li></ul><h4 id="Temporal-颞叶"><a href="#Temporal-颞叶" class="headerlink" title="Temporal 颞叶"></a><strong>Temporal 颞叶</strong></h4><ul><li>41、42、22：superior temporal，初级听觉皮层A1。</li><li>23：进一步进行听觉处理。</li><li>负责<strong>建立</strong>长期记忆。记忆本质上是一种感觉功能。</li><li>Wernicke’s area：与听觉关联皮层相邻，位于视觉皮层前面的外侧沟末端。涉及语言的接受，对内容的理解。</li></ul><h4 id="Occipital-枕叶"><a href="#Occipital-枕叶" class="headerlink" title="Occipital 枕叶"></a><strong>Occipital 枕叶</strong></h4><ul><li>17：初级视觉皮层。</li><li>18、19：后续视觉处理。</li></ul><h4 id="大脑皮层的处理区域可以分为三种类型："><a href="#大脑皮层的处理区域可以分为三种类型：" class="headerlink" title="大脑皮层的处理区域可以分为三种类型："></a><strong>大脑皮层的处理区域可以分为三种类型：</strong></h4><ul><li><strong>primary：初级区域。</strong>是感觉信息最初被处理的地方，或者是运动命令发出并到达脑干或脊髓的地方。如：1、2、3、4、17、22。</li><li><strong>association：关联区域。</strong>与初级区域相邻，进一步处理特定模式的输入。</li><li><strong>integration：整合区域。</strong>集成多感觉信息（如视觉和体感），通常位于特定模式区域的交会处。</li></ul><h4 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h4><p>记忆很大程度上是<strong>颞叶</strong>以及大脑皮层下方结构（例如<strong>海马体 hippocampus</strong> 和 <strong>杏仁核 amygdala</strong>）的功能。记忆的长期存储涉及到<strong>内侧颞叶。</strong></p><ul><li><p>episodic memory 情景记忆</p><ul><li>存储位置位于大脑皮层的多模态整合区域</li><li>由短期转向长期需要海马体和相关内侧颞叶结构</li></ul></li><li>short-term memory 短期记忆：前额叶</li><li>long-term memory 长期记忆：将短期记忆转移/巩固为长期记忆，而已经完成巩固的长期记忆不一定存储在内侧颞叶。</li></ul><h4 id="语言和言语-Language-and-Speech"><a href="#语言和言语-Language-and-Speech" class="headerlink" title="语言和言语 Language and Speech"></a>语言和言语 Language and Speech</h4><ul><li>Broca‘s area：左半球，额叶外侧，语言的产生、言语的控制。涉及言语的<strong>表达</strong>。</li><li><p>Wernicke’s area：左半球，与听觉关联皮层相邻，位于视觉皮层前面的外侧沟末端。涉及语言的接受，对内容的<strong>理解</strong>。</p></li><li><p>这两个区域通过在后颞叶和额叶外侧之间延伸的深层白质束连接。</p></li><li>某些失语症的特征是动词或名词的缺失，称为 V 损伤或 N 损伤。额叶和颞叶交汇处（包括岛叶区域）的损伤与 V 损伤有关；中颞叶和下颞叶的损伤与 N 损伤有关。</li><li>95% 的人大脑皮层的语言功能位于左半球。</li></ul><h3 id="2-皮层下结构-Subcortical"><a href="#2-皮层下结构-Subcortical" class="headerlink" title="2. 皮层下结构 Subcortical"></a>2. 皮层下结构 Subcortical</h3><p>负责增强皮质功能</p><ul><li><p><strong>basal forebrain 基底前脑：</strong></p><ul><li>产生乙酰胆碱，可能导致对感觉刺激更敏感。</li><li>调节注意力和记忆的皮层活动</li><li>该处神经元丧失与阿尔兹海默症有关</li></ul></li><li><strong>hippocampus and amygdala 海马体和杏仁核：</strong>内侧叶结构，与邻近皮质一起参与长期记忆的形成和情绪反应。</li><li><p><strong>basal neclei / basal ganglia 基底核：</strong></p><ul><li>大脑中的一系列神经核团</li><li>接收来自皮质区域的输入，并通过<strong>多巴胺释放核</strong>的活动将皮质输入与个体的一般状态进行比较。输出会影响丘脑部分的活动，从而<strong>增加或减少皮质活动</strong>，这通常会导致运动命令的变化。</li><li>主要结构：位于大脑深处的尾状核、壳核和苍白球（the <strong>caudate</strong>, <strong>putamen</strong>, and <strong>globus pallidus</strong>）尾核和壳核一起称为<strong>纹状体（striatum）</strong></li><li>大脑中的基底核与脑干中的更多核相连，它们共同充当形成<strong>运动通路</strong>的功能组。</li><li>帕金森是由基底核黑质致密部神经元死亡导致</li></ul></li></ul><h3 id="3-间脑-Diencephalon"><a href="#3-间脑-Diencephalon" class="headerlink" title="3. 间脑 Diencephalon"></a>3. 间脑 Diencephalon</h3><p>间脑位于大脑下方深处，构成第三脑室的壁。间脑可以被描述为名称中带有<strong>“丘脑（thalamus）”</strong>的大脑区域。</p><p>间脑是大脑与神经系统其他部分（大脑的其余部分、脊髓和周围神经系统）之间的连接桥梁，但有一个例外，与嗅觉相关的系统不经过间脑直接与大脑相连。</p><ul><li><p><strong>丘脑 thalamus</strong></p><ul><li>在大脑皮层和周围神经、脊髓和脑干之间<strong>传递信息</strong>（中继站）</li><li><strong>处理信息</strong>，如影响视觉刺激的受到关注的程度</li></ul></li><li><p><strong>下丘脑 hypothalamus：</strong>丘脑的下方和稍前方</p><ul><li>垂体前叶：通过调控自主神经系统和内分泌系统<strong>调节体内平衡</strong></li><li>其他部分：作为<strong>边缘系统（limbic system）</strong>的一部分参与记忆和情感。边缘系统还包括其他负情绪和记忆的深部核团。</li></ul></li></ul><h3 id="4-脑干-Brain-Stem"><a href="#4-脑干-Brain-Stem" class="headerlink" title="4. 脑干 Brain Stem"></a>4. 脑干 Brain Stem</h3><p><strong>中脑（midbrain）</strong>和后脑（hindbrain）的<strong>脑桥（pons）</strong>、<strong>延髓（medulla）</strong>统称为“脑干“</p><p><strong>中脑</strong>协调视觉、听觉和体感感知空间的感觉表征。<strong>脑桥</strong>是与小脑的主要连接。<strong>脑桥和延髓</strong>调节多种重要功能，包括心血管和呼吸系统。</p><ul><li>中脑：胚胎大脑的原始区域之一，分为tectum和tegmentum。tectum由四个colliculi组成。结合视觉空间、听觉空间和体感空间的感觉信息（将视觉定向到声音或触觉刺激上）。</li><li>脑桥：是小脑和脑干之间的主要连接</li><li>延髓：与睡眠和清醒有关，如大脑的一般活动和注意力</li></ul><h3 id="5-小脑-Cerebellum"><a href="#5-小脑-Cerebellum" class="headerlink" title="5. 小脑 Cerebellum"></a>5. 小脑 Cerebellum</h3><p>小脑主要负责将来自大脑的信息与来自外周通过脊髓的感觉反馈进行比较，并进行补偿与纠正。<strong>（反馈调节）</strong></p><p>如果额叶的初级运动皮层向脊髓发送开始行走的命令，该指令的副本就会发送到小脑。来自肌肉和关节的感觉反馈、有关行走运动的本体感觉信息以及平衡感通过下橄榄发送到小脑，小脑对它们进行比较。如果行走不协调，可能是因为地面不平或刮着大风，那么小脑就会发出纠正命令，以<strong>补偿原始皮质命令和感觉反馈之间的差异</strong>。</p><h3 id="6-脊髓"><a href="#6-脊髓" class="headerlink" title="6. 脊髓"></a>6. 脊髓</h3><p><strong>灰质：后角（posterior horn）</strong>负责感觉处理。<strong>前角（anterior horn）</strong>向骨骼肌发出运动信号。<strong>侧角（lateral horn）</strong>只存在于胸椎、上腰椎和骶椎区域，是自主神经系统交感神经的中心组成部分。</p><p><strong>白质：</strong>神经系统纤维的<strong>上升束（ascending tracts）</strong>将感觉信息传送到大脑，而<strong>下降束（descending tracts）</strong>则传送来自大脑的运动命令。<strong>后柱（posterior columns）</strong>由上升束的轴突组成。<strong>前柱（anterior columns）</strong>和<strong>侧柱（lateral columns）</strong>由许多不同组的上行束和下行束轴突组成</p><p><img src="https://s2.loli.net/2024/10/15/egvNBq4ytZxFk6s.png" alt="image-20241010201908161" style="zoom:50%;" /></p><hr>]]></content>
      
      
      <categories>
          
          <category> Neural </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neural </tag>
            
            <tag> 神经科学 </tag>
            
            <tag> 生物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记 | 矩阵理论（英）</title>
      <link href="/post/c9daa1a2.html"/>
      <url>/post/c9daa1a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h1><ul><li>closed umder 4 binary operations：$+, -, \times, \div$</li><li><strong><em>R</em></strong> ，<strong><em>C</em></strong>，<strong><em>F</em></strong>（任意数域）</li></ul><h1 id="Vector-Space"><a href="#Vector-Space" class="headerlink" title="Vector Space"></a>Vector Space</h1><ul><li>Definition<ul><li>closed under <strong>2</strong> operations: addition, scalar multiplication</li><li>satisfied <strong>8</strong> axioms </li></ul></li></ul><h1 id="Polynomial-Space"><a href="#Polynomial-Space" class="headerlink" title="Polynomial Space"></a>Polynomial Space</h1><p>$P_n={\sum^n_{j=0}a_j x^j|a_0,a_i,\dots,a_n\in R}$</p><h1 id="Subspace"><a href="#Subspace" class="headerlink" title="Subspace"></a>Subspace</h1><ul><li><p>prove</p><ul><li>zero vector</li><li>closed under addition and scalar multiplication</li></ul></li><li><p>the intersection $\cap$ of two subspaces U and V is always a subspace</p></li><li>a union $\cup$ of two subspaces of V is not necessarily a subspace of V<ul><li>the union of two subspaces of V is a subspace of V if and only if one of the subspace is contained in the other</li></ul></li></ul><h1 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h1><p>If a set of vectors $S=\{v_1,v_2,\dots,v_k\}\subset V$ is a subset of a vector of a vector space V over a field <strong>F</strong>, <u><strong>Span S</strong> is the intersection of all subspaces of V that contain S</u></p><ul><li><p>if  $S\ne\varnothing$, then</p><p>$span\ S=\{\sum^k_{j=1}a_jv_j|a_1,\dots,a_k\in F,k=1,2,\dots\}$</p></li><li><p>span S is a subspace of V</p></li></ul><h4 id="The-sum-of-two-subspaces-X-Y"><a href="#The-sum-of-two-subspaces-X-Y" class="headerlink" title="The sum of two subspaces: X+Y"></a>The sum of two subspaces: X+Y</h4><ul><li><p>$S=X+Y=span\{X\cup Y\}=\{x+y|x\in X,y\in Y\}$</p></li><li><p>X,Y is subspaces of V, then X+Y is a subspace of V</p></li><li><p>Theorem:</p><p>if $span\{S_X\}=X, span\{S_Y\}=Y$, then $span\{S_X\cup S_Y\}=X+Y$</p></li></ul><h1 id="Linear-Combinations"><a href="#Linear-Combinations" class="headerlink" title="Linear Combinations"></a>Linear Combinations</h1><p>A linear combination of vectors in a vector space <strong>V</strong> over a field <strong>F</strong> is any expression of the form</p><p>$a_1v_1+a_2v_2+\cdots+a_kv_k$</p><p>in which k is a positive integer, $v_1,\dots,v_k\in S，a_1,\dots,a_k\in F$</p><ul><li>span S consists of all linear combinations of finitely many vectors in S</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercises | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcc4e1.html"/>
      <url>/post/c9dcc4e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="4-7-Exercise"><a href="#4-7-Exercise" class="headerlink" title="4.7 Exercise"></a>4.7 Exercise</h2><h3 id="4-7-1-Exercises-for-Script-A"><a href="#4-7-1-Exercises-for-Script-A" class="headerlink" title="4.7.1 Exercises for Script A"></a><strong>4.7.1 Exercises for Script A</strong></h3><ol><li><p>Create a 4 × 8 matrix of randomly generated numbers. </p></li><li><p>Loop through all rows and columns, and test whether each element is greater than 0.5. </p></li><li><p>Report the results of the test along with the value of the matrix element and its row-column position. For example, your Matlab script should print The 3rd row and 8th column has a value of 0.42345 and is not bigger than 0.5 . </p></li><li><p>Make sure to add exceptions to print out 1st, 2nd, and 3rd, instead of 1th, 2th, and 3th. </p></li><li><p>Put this code into a separate function that you can call from the command line with two inputs, corresponding to the number of rows and the number of columns of the matrix. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.1 Exercises for Script A</span></span><br><span class="line">matA = GreaterThanPointFive(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成一个 rowx × colx 的0~1随机数矩阵，并输出各行各列上的元素及其与0.5的大小关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matx</span> = <span class="title">GreaterThanPointFive</span><span class="params">(rowx, colx)</span></span></span><br><span class="line">    matx = <span class="built_in">rand</span>(rowx,colx);</span><br><span class="line">    NoString = [<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;st&#x27;</span>;<span class="string">&#x27;nd&#x27;</span>;<span class="string">&#x27;rd&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> rowi = <span class="number">1</span>:rowx</span><br><span class="line">        <span class="keyword">for</span> coli = <span class="number">1</span>:colx</span><br><span class="line">            <span class="keyword">if</span> matx(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is not bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="4-7-2-Exercises-for-Script-B"><a href="#4-7-2-Exercises-for-Script-B" class="headerlink" title="4.7.2 Exercises for Script B"></a><strong>4.7.2 Exercises for Script B</strong></h3><ol><li><p>Import and plot the picture of Amsterdam that comes with the online Matlab code. </p></li><li><p>On top of the picture, plot a thick red line from “ Nieuwmarkt ” (near the center of the picture) to “ Station Amsterdam Centraal ” (near the top of the picture). </p></li><li><p>Plot a magenta star over the Waterlooplein metro station (a bit South of Nieuwmarkt). </p></li><li><p>Find the maximum value on each color dimension (red, green, or blue) and plot a circle using that color. There may be more than one pixel with a maximum value; if so, pick one pixel at random. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.2 Exercises for Script B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 6. Import and plot picture</span></span><br><span class="line">amsterdamImg = imread(<span class="string">&quot;amsterdam.bmp&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">imagesc(amsterdamImg);</span><br><span class="line">axis image</span><br><span class="line">axis on</span><br><span class="line">grid on</span><br><span class="line">grid minor</span><br><span class="line"></span><br><span class="line"><span class="comment">% 7. plot a thick red line</span></span><br><span class="line">line([<span class="number">367</span>,<span class="number">395</span>],[<span class="number">325</span>,<span class="number">75</span>],<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 8. plot a magenta star</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">375</span>,<span class="number">490</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 9.find maximum value on each color dimension and plot a circle using it</span></span><br><span class="line"><span class="comment">% 分别提取RGB数值</span></span><br><span class="line">R = amsterdamImg(:,:,<span class="number">1</span>);</span><br><span class="line">G = amsterdamImg(:,:,<span class="number">2</span>);</span><br><span class="line">B = amsterdamImg(:,:,<span class="number">3</span>);</span><br><span class="line"><span class="comment">% 找到最大的RGB值</span></span><br><span class="line">R_max = <span class="built_in">max</span>(R);</span><br><span class="line">G_max = <span class="built_in">max</span>(G);</span><br><span class="line">B_max = <span class="built_in">max</span>(B);</span><br><span class="line"><span class="comment">% 找到最大值所在位置</span></span><br><span class="line">[R_maxRow, R_maxCol] = <span class="built_in">find</span>(R==R_max);</span><br><span class="line">[G_maxRow, G_maxCol] = <span class="built_in">find</span>(G==G_max);</span><br><span class="line">[B_maxRow, B_maxCol] = <span class="built_in">find</span>(B==B_max);</span><br><span class="line"><span class="comment">% 随机选择一个索引</span></span><br><span class="line">R_idx = randi(<span class="built_in">length</span>(R_maxRow));</span><br><span class="line">G_idx = randi(<span class="built_in">length</span>(G_maxRow));</span><br><span class="line">B_idx = randi(<span class="built_in">length</span>(B_maxRow));</span><br><span class="line"><span class="comment">% 获取坐标</span></span><br><span class="line">R_position = [R_maxRow(R_idx), R_maxCol(R_idx)];</span><br><span class="line">G_position = [G_maxCol(G_idx), G_maxCol(G_idx)];</span><br><span class="line">B_position = [B_maxCol(B_idx), B_maxCol(B_idx)];</span><br><span class="line"><span class="comment">% 在图像上最大值位置绘制圆圈</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(R_position(<span class="number">1</span>),R_position(<span class="number">2</span>),<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(G_position(<span class="number">1</span>),G_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(B_position(<span class="number">1</span>),B_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/10/15/JNc7oOSmMaQD5fC.png" alt="image-20240814164819625" style="zoom:67%;" /></p><h3 id="4-7-3-Exercises-for-Script-C"><a href="#4-7-3-Exercises-for-Script-C" class="headerlink" title="4.7.3 Exercises for Script C"></a><strong>4.7.3 Exercises for Script C</strong></h3><ol><li><p>From the function you wrote for exercise 5, generate a 32 × 3 number matrix in which the three numbers in each row correspond to the row, column, and result of the test (1 for bigger than 0.5; 0 for smaller than 0.5). </p></li><li><p>Write this 32 × 3 matrix to a text file that contains this matrix along with appropriate variable labels in the first row. Make sure this file is tab-delimited and readable by a spreadsheet software such as Microsoft Excel or Open Office Calc. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 运行该代码前请先运行Exercise_04_A</span></span><br><span class="line"></span><br><span class="line">matC = NaN(<span class="number">32</span>,<span class="number">3</span>);   <span class="comment">% 第一、二列为matA的行、列坐标，第三列为该坐标上的元素是否大于0.5</span></span><br><span class="line">countRowi = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rowi = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> coli = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">2</span>)</span><br><span class="line">        matC(countRowi,<span class="number">1</span>) = rowi;</span><br><span class="line">        matC(countRowi,<span class="number">2</span>) = coli;</span><br><span class="line">        <span class="keyword">if</span> matA(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        countRowi = countRowi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 将matC写入txt文件</span></span><br><span class="line">fileC = fopen(<span class="string">&#x27;data_output_04C.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% variable labels</span></span><br><span class="line">variable_labels = &#123;<span class="string">&#x27;row&#x27;</span>;<span class="string">&#x27;column&#x27;</span>;<span class="string">&#x27;result&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">% 写入第一行变量名</span></span><br><span class="line"><span class="keyword">for</span> vari=<span class="number">1</span>:<span class="built_in">length</span>(variable_labels)</span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;%s\t&#x27;</span>,variable_labels&#123;vari&#125;);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 换行</span></span><br><span class="line">fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> datarowi=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> columni=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">2</span>)</span><br><span class="line">        fprintf(fileC,<span class="string">&#x27;%g\t&#x27;</span>,matC(datarowi,columni));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fclose(fileC);</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h1><h2 id="9-8-Exercise"><a href="#9-8-Exercise" class="headerlink" title="9.8 Exercise"></a>9.8 Exercise</h2><h3 id="9-8-1"><a href="#9-8-1" class="headerlink" title="9.8.1"></a>9.8.1</h3><p>Compute the ERP at each electrode. Select five time points at which to show topographical plots (e.g., 0 to 400 ms in 100-ms steps). In one figure, make a series of topographical plots  at these time points. To increase the signal-to-noise ratio, make each plot show the average of activity from 20 ms before until 20 ms after each time point. For example, the topographical  plot from 200 ms should show average activity from 180 ms until 220 ms. Indicate the center  time point in a title on each subplot. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex_09 (1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% load EEG data</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute the ERP at each electrode</span></span><br><span class="line">ERP = <span class="built_in">zeros</span>(EEG.nbchan, EEG.pnts);</span><br><span class="line"><span class="keyword">for</span> electrode_i = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    ERP(electrode_i,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(electrode_i,:,:),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% select 5 time points (0 to 400ms in 100-ms steps) </span></span><br><span class="line"><span class="comment">% and plot topographical Maps</span></span><br><span class="line">dt = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="keyword">for</span> timei=<span class="number">0</span>:<span class="number">100</span>:<span class="number">400</span></span><br><span class="line">    <span class="comment">% Each point show the average of activity from 20ms before until 20ms</span></span><br><span class="line">    <span class="comment">% after each point</span></span><br><span class="line">    TimeSpani = <span class="built_in">find</span>(EEG.times &gt;= timei-dt &amp; EEG.times &lt;= timei+dt);</span><br><span class="line">    MeanEEG = <span class="built_in">mean</span>(EEG.data(:,TimeSpani,:),<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% topographical plots</span></span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">2</span>,timei/<span class="number">100</span>+<span class="number">1</span>);</span><br><span class="line">    c = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(MeanEEG(:,:,:),<span class="number">3</span>));</span><br><span class="line">    topoplot(double(c),EEG.chanlocs,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="number">-10</span>,<span class="number">10</span>]);   <span class="comment">% 统一各subplot的colorbar</span></span><br><span class="line">    title([<span class="string">&#x27;ERP around &#x27;</span> num2str(timei) <span class="string">&#x27;ms&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    colormap jet</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot colorbar</span></span><br><span class="line">ax6 = subplot(<span class="number">326</span>);</span><br><span class="line">axis off</span><br><span class="line">cb = colorbar;</span><br><span class="line">set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="number">-10</span>,<span class="number">10</span>]);</span><br><span class="line">cb.Position(<span class="number">1</span>) = ax6.Position(<span class="number">1</span>);</span><br><span class="line">cb.Position(<span class="number">2</span>) = ax6.Position(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/10/15/MCiH8hZkGxcRSoe.png" alt="Ex09(1)" style="zoom:67%;" /></p><h3 id="9-8-2"><a href="#9-8-2" class="headerlink" title="9.8.2"></a>9.8.2</h3><p>Loop through each electrode and find the peak time of the ERP between 100 and 400 ms. Store these peak times in a separate variable and then make a topographical plot of the peak times (that is, the topographical map will illustrate times in milliseconds, not activity at peak times). Include a color bar in the figure and make sure to show times in milliseconds from time 0 (not, for example, time in milliseconds since 100 ms or indices instead of milliseconds). What areas of the scalp show the earliest and the latest peak responses to the stimulus within this window?</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex_09 (2)</span></span><br><span class="line"></span><br><span class="line">PeakTimes = <span class="built_in">zeros</span>(EEG.nbchan,<span class="number">1</span>);      <span class="comment">% the peak time of the ERP between 100 and 400ms (in ms)</span></span><br><span class="line">PeakTimedx = <span class="built_in">zeros</span>(EEG.nbchan,<span class="number">1</span>);      <span class="comment">% peak time index of each channel</span></span><br><span class="line">Timedx = <span class="built_in">find</span>(EEG.times &gt;= <span class="number">100</span> &amp; EEG.times &lt;= <span class="number">400</span>);     <span class="comment">% index of 100~400ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% find ERP peak times</span></span><br><span class="line"><span class="keyword">for</span> electrode_i = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    PeakTimedx(electrode_i) = Timedx(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> timespani = <span class="number">1</span>:<span class="built_in">length</span>(Timedx)</span><br><span class="line">        <span class="keyword">if</span> ERP(electrode_i,Timedx(timespani)) &gt; ERP(electrode_i,PeakTimedx(electrode_i))</span><br><span class="line">            PeakTimedx(electrode_i) = Timedx(timespani);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    PeakTimes(electrode_i) = EEG.times(PeakTimedx(electrode_i));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot a topographical plot of peak times</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">topoplot(PeakTimes,EEG.chanlocs,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">colormap jet</span><br><span class="line">set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="built_in">min</span>(PeakTimes) <span class="built_in">max</span>(PeakTimes)]);</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;ERP peak times between 100 and 400 ms&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/10/15/Ntai3rTk7wF2yCe.png" alt="EX09(2)" style="zoom:67%;" /></p><hr><h1 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h1><h2 id="Exercises-10-Convolution"><a href="#Exercises-10-Convolution" class="headerlink" title="Exercises 10 | Convolution"></a>Exercises 10 | Convolution</h2><h3 id="10-6-1"><a href="#10-6-1" class="headerlink" title="10.6.1"></a>10.6.1</h3><ol><li>Create two kernels for convolution: one that looks like a U and one that looks like a decay function. There is no need to be too sophisticated in generating, for example, a Gaussian and an exponential; numerical approximations are fine.</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 10</span></span><br><span class="line"><span class="comment">% 1. Create two kernels </span></span><br><span class="line">kernel_U = [<span class="number">1</span> <span class="number">0.8</span> <span class="number">0.3</span> <span class="number">0.1</span> <span class="number">0</span> <span class="number">0.1</span> <span class="number">0.3</span> <span class="number">0.8</span> <span class="number">1</span>];</span><br><span class="line">kernel_decay = [<span class="number">1</span> <span class="number">0.9</span> <span class="number">0.8</span> <span class="number">0.7</span> <span class="number">0.5</span> <span class="number">0.3</span> <span class="number">0.2</span> <span class="number">0.1</span> <span class="number">0</span>];</span><br></pre></td></tr></table></figure><h3 id="10-6-2"><a href="#10-6-2" class="headerlink" title="10.6.2"></a>10.6.2</h3><ol><li>Convolve these two kernels with 50 time points of EEG data from one electrode. Make a plot showing the kernels, the EEG data, and the result of the convolution between the data and each kernel. Use time-domain convolution as explained in this chapter and as illustrated in the online Matlab code. Based on visual inspection, what is the effect of convolving the EEG data with these two kernels?</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2</span></span><br><span class="line"><span class="comment">% Snippet of EEG data</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">impEEG = EEG.data(<span class="number">47</span>,<span class="number">100</span>:<span class="number">149</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用自编函数计算impEEG与kernel_U的convolution</span></span><br><span class="line"><span class="comment">% data that we&#x27;ll use for convolution (must be zero-padded).</span></span><br><span class="line">dat4conv = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) impEEG <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) ];</span><br><span class="line"></span><br><span class="line"><span class="comment">% used for cutting the result of convolution</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize convolution output</span></span><br><span class="line">convolution_result_U = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(impEEG)+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% run convolution (note that kernel is flipped backwards) ti以外的范围会被舍弃，没必要计算</span></span><br><span class="line"><span class="keyword">for</span> ti=half_of_kernel_size+<span class="number">1</span>:<span class="built_in">length</span>(convolution_result_U)-half_of_kernel_size         </span><br><span class="line">    convolution_result_U(ti) = sum(dat4conv(ti:ti+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>).*kernel_U(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_U = convolution_result_U(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用Matlab自带函数conv()计算impEEG与kernel_decay的convolution</span></span><br><span class="line">convolution_result_decay = conv(impEEG,kernel_decay,<span class="string">&#x27;same&#x27;</span>);    <span class="comment">%% &#x27;same&#x27;:conv的结果与impfun的长度相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot kernels</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">311</span>)</span><br><span class="line"><span class="built_in">plot</span>(kernel_U,<span class="string">&#x27;bo-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(kernel_decay,<span class="string">&#x27;ro-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;decay&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.84</span> <span class="number">0.13512</span> <span class="number">0.064683</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Points&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Convolution kernels&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot Snippet of EEG data</span></span><br><span class="line">subplot(<span class="number">312</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Snippet of EEG data (EEG.data(47,100:149,10))&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot EEG data before and after convolution</span></span><br><span class="line">subplot(<span class="number">313</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;k-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_U./sum(kernel_U),<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_decay./sum(kernel_decay),<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;U-convolved&#x27;</span>,<span class="string">&#x27;decay-convolved&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.65</span> <span class="number">0.245</span> <span class="number">0.2</span> <span class="number">0.09</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;EEG data before and after convolution&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/17/Id6gBtjlfc2LV1M.png" alt="Ex_10" style="zoom:67%;" /></p><hr><h2 id="Exercises-11-Fourier-Transform"><a href="#Exercises-11-Fourier-Transform" class="headerlink" title="Exercises 11 | Fourier Transform"></a>Exercises 11 | Fourier Transform</h2><h3 id="11-12-1"><a href="#11-12-1" class="headerlink" title="11.12.1"></a>11.12.1</h3><p>Reproduce the top three panels of figure 11.12 three times. </p><ul><li><p>First, perform time-domain convolution using <strong>the “ manual ” convolution method</strong> shown in chapter 10. </p></li><li><p>Second, perform frequency-domain convolution using <strong>the discrete time Fourier transform</strong> presented at the beginning of this chapter. </p></li><li>Finally, perform frequency-domain convolution using <strong>the Matlab functions fft and ifft</strong> (do not use the function conv). (You can optionally reproduce the bottom panel of figure 11.12 for the frequency domain analyses; keep in mind that the power scaling is for display purposes only.) </li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 1. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">    conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"><span class="comment">% Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    <span class="comment">% create sine wave</span></span><br><span class="line">    sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">    fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line"></span><br><span class="line"><span class="comment">% inverse Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line">conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,eegdat4convol);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_manual,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_Fourier,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_fft,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;&quot;manual&quot; convolution method&#x27;</span>,<span class="string">&#x27;discrete time Fourier transform&#x27;</span>,<span class="string">&#x27;Matlab functions fft and ifft&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/dHleLSJOyTUR9xt.png" alt="Ex_11"></p><h3 id="11-12-2"><a href="#11-12-2" class="headerlink" title="11.12.2"></a>11.12.2</h3><p>From the three sets of Matlab code you have for reproducing figure 11.12 , run a computation time test. That is, time how long it takes Matlab to perform 1000 repetitions of each of the three methods for computing convolution that you generated in the previous exercise (do not plot the results each time). You can use the Matlab function pairs tic and toc to time a Matlab process. Plot the results in a bar plot, similar to figure 11.8 . </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 2. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line">t = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">        conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">1</span>) = toc;</span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="comment">% Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        <span class="comment">% create sine wave</span></span><br><span class="line">        sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">        fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% inverse Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">2</span>) = toc;</span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">    conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">3</span>) = toc;</span><br><span class="line"><span class="comment">%% plot results in a bar plot</span></span><br><span class="line">b = bar(t);</span><br><span class="line">labels = string(b(<span class="number">1</span>).YData);</span><br><span class="line">text(b(<span class="number">1</span>).XEndPoints,b(<span class="number">1</span>).YEndPoints,labels,<span class="string">&#x27;HorizontalAlignment&#x27;</span>,<span class="string">&#x27;center&#x27;</span>,<span class="string">&#x27;VerticalAlignment&#x27;</span>,<span class="string">&#x27;top&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>])</span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,&#123;<span class="string">&#x27;manual convolution&#x27;</span>;<span class="string">&#x27;DTFT&amp;IDTFT&#x27;</span>;<span class="string">&#x27;FFT&amp;IFFt&#x27;</span>&#125;)</span><br><span class="line">set(gca, <span class="string">&#x27;YScale&#x27;</span>, <span class="string">&#x27;log&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;time(s)&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/391pAN7iXbJEkdl.png" alt="Ex_11(2)" style="zoom: 50%;" /></p><h3 id="11-12-3"><a href="#11-12-3" class="headerlink" title="11.12.3"></a>11.12.3</h3><p>Generate a time series by creating and summing sine waves, as in figure 11.2B . Use between two and four sine waves, so that the individual sine waves are still somewhat visible in the sum. Perform a Fourier analysis (you can use the fft function) on the resulting time series and plot the power structure. Confirm that your code is correct by comparing the frequencies with nonzero power to the frequencies of the sine waves that you generated. Now try adding random noise to the signal before computing the Fourier transform. First, add a small amount of noise so that the sine waves are still visually recognizable. Next, add a large amount of noise so that the sine waves are no longer visually recognizable in the time domain data. Perform a Fourier analysis on the two noisy signals and plot the results. What is the effect of a small and a large amount of noise in the power spectrum? Are the sine waves with noise easier to detect in the time domain or in the frequency domain, or is it equally easy/difficult to detect a sine wave in the presence of noise? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Create sine waves</span></span><br><span class="line">srate = <span class="number">400</span>;</span><br><span class="line">time=<span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">N = <span class="built_in">length</span>(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create three sine waves</span></span><br><span class="line">s1 = <span class="number">20</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">3</span>*time);</span><br><span class="line">s2 = <span class="number">10</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">8</span>*time);</span><br><span class="line">s3 = <span class="number">5</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">15</span>*time);</span><br><span class="line">sum_Sine = s1+s2+s3;</span><br><span class="line"></span><br><span class="line"><span class="comment">% add random noise</span></span><br><span class="line">Sine_LitteNoise = sum_Sine + <span class="number">10</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line">Sine_LargeNoise = sum_Sine + <span class="number">40</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">linspace</span>(<span class="number">0</span>,srate/<span class="number">2</span>,<span class="built_in">floor</span>(N/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = fft(sum_Sine)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LitteNoise = fft(Sine_LitteNoise)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LargeNoise = fft(Sine_LargeNoise)./(N/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = <span class="built_in">abs</span>(FFT_Sine(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LitteNoise = <span class="built_in">abs</span>(FFT_LitteNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LargeNoise = <span class="built_in">abs</span>(FFT_LargeNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(time,sum_Sine);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Original time series&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">bar(f,FFT_Sine);</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LitteNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">bar(f,FFT_LitteNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LargeNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, large noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>)</span><br><span class="line">bar(f,FFT_LargeNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, large noise&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/I5wHdjzGkQmMDN6.png" alt="Ex_11(3)" style="zoom: 80%;" /></p><hr><h2 id="Exercises-12-Morlet-wavelets"><a href="#Exercises-12-Morlet-wavelets" class="headerlink" title="Exercises 12 | Morlet wavelets"></a>Exercises 12 | Morlet wavelets</h2><ol><li><p>Create a family of Morlet wavelets ranging in frequency from 2 Hz to 30 Hz in five steps. </p></li><li><p>Select one electrode from the scalp EEG dataset and convolve each wavelet with EEG data from all trials from that electrode. Apply the Matlab function real to the convolution result, as in <code>convol_result=real(convol_result)</code>. This will return the EEG data bandpass filtered at the peak frequency of the wavelet. You learn more about why this is in the next chapter. </p></li><li><p>Average the result of convolution over all trials and plot an ERP corresponding to each wavelet frequency. Each frequency should be in its own subplot. </p></li><li><p>Plot the broadband ERP (without any convolution). Thus, you will have six subplots in one figure. How do the wavelet-convolved ERPs compare with the broadband ERP? Are there dynamics revealed by the wavelet-convolved ERPs that are not apparent in the broadband ERP, and are there dynamics in the broadband ERP that are not apparent in the waveletconvolved ERPs? Base your answer on qualitative visual inspection of the results; statistics or other quantitative comparisons are not necessary. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercise 12</span></span><br><span class="line"><span class="comment">%% 1. Create a family of Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequencies = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">num_wavelets = <span class="built_in">length</span>(frequencies);</span><br><span class="line"></span><br><span class="line">srate = EEG.srate;</span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">wavelet_family = <span class="built_in">zeros</span>(num_wavelets,<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Loop through frequencies and make a family of wavelets.</span></span><br><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:num_wavelets</span><br><span class="line"> </span><br><span class="line">    <span class="comment">% create a sine wave at this frequency</span></span><br><span class="line">    sinewave = <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*frequencies(fi).*time); <span class="comment">% the &quot;1i&quot; makes it a complex wavelet</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create a Gaussian window</span></span><br><span class="line">    gaus_win = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi)))^<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create wavelet via element-by-element multiplication of the sinewave and gaussian window</span></span><br><span class="line">    wavelet_family(fi,:) = sinewave.*gaus_win;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 2. Get EEG data from electrode 47, convolve each wavelet with EEG data</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line">channel = <span class="number">47</span>;</span><br><span class="line">n_conv = EEG.pnts + <span class="built_in">length</span>(time) - <span class="number">1</span>;</span><br><span class="line">convol_result = <span class="built_in">zeros</span>(EEG.trials,num_wavelets,n_conv);</span><br><span class="line">half_of_kernal_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> trial_i = <span class="number">1</span>:EEG.trials</span><br><span class="line">    fft_EEG = fft(EEG.data(channel,:,trial_i),n_conv);</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:num_wavelets</span><br><span class="line">        fft_wavelet = fft(wavelet_family(fi,:),n_conv);</span><br><span class="line">        convol_result(trial_i,fi,:) = ifft(fft_EEG.*fft_wavelet,n_conv) * <span class="built_in">sqrt</span>(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi))) / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convol_result = <span class="built_in">real</span>(convol_result(:,:,half_of_kernal_size+<span class="number">1</span>:n_conv-half_of_kernal_size));</span><br><span class="line">filtered_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(convol_result,<span class="number">1</span>));<span class="comment">% 经过wavelet滤波后的ERP</span></span><br><span class="line">broadband_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(channel,:,:),<span class="number">3</span>)); <span class="comment">% 未滤波的ERP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_wavelets</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,filtered_ERP(<span class="built_in">i</span>,:));</span><br><span class="line">    set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-300</span>, <span class="number">1000</span>])</span><br><span class="line">    ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">    xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Wavelet filtered ERP at &#x27;</span> num2str(frequencies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,broadband_ERP);</span><br><span class="line">ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Unfiltered broadband ERP&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/19/3lrQXKtgZI4docT.png" alt="Ex_12"></p><hr><h2 id="Exercises-13-complex-Morlet-wavelets"><a href="#Exercises-13-complex-Morlet-wavelets" class="headerlink" title="Exercises 13 | complex Morlet wavelets"></a>Exercises 13 | complex Morlet wavelets</h2><h3 id="1-Create-a-family-of-complex-Morlet-wavelets"><a href="#1-Create-a-family-of-complex-Morlet-wavelets" class="headerlink" title="1. Create a family of complex Morlet wavelets"></a>1. Create a family of complex Morlet wavelets</h3><p>Create a family of complex Morlet wavelets ranging in frequencies from 2 Hz to 30 Hz in five steps. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 13</span></span><br><span class="line"><span class="comment">% 1. Create a family of complex Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">time = <span class="number">-2</span>:<span class="number">1</span>/EEG.srate:<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在3和10之间生成5个对数分别的数，作为不同频率下wavelet包含的周期数目</span></span><br><span class="line">numcycles = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">10</span>),<span class="built_in">length</span>(frex));</span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex), <span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% make complex Morlet wavelets</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi));</span><br><span class="line">    wavelet(fi,:) = <span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)) * <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi).*time);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 检查两侧是否衰减到0</span></span><br><span class="line">    <span class="comment">% subplot(ceil(length(frex)/3), ceil(length(frex)/2), fi);</span></span><br><span class="line">    <span class="comment">% plot(time,real(wavelet));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="2-Convolve-each-wavelet-with-EEG-data"><a href="#2-Convolve-each-wavelet-with-EEG-data" class="headerlink" title="2. Convolve each wavelet with EEG data"></a>2. Convolve each wavelet with EEG data</h3><p>Convolve each wavelet with EEG data from all electrodes and from one trial. </p><h3 id="3-Extract-power-and-phase"><a href="#3-Extract-power-and-phase" class="headerlink" title="3. Extract power and phase"></a>3. Extract power and phase</h3><p>Extract power and phase from the result of complex wavelet convolution and store in a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix). </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2. Convolve each wavelet with EEG data from all electrode and from one trial</span></span><br><span class="line">trial = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 3. a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix)</span></span><br><span class="line">convolution_result_fft = <span class="built_in">zeros</span>(n_convolution,<span class="built_in">length</span>(frex),EEG.nbchan,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% FFT of wavelet and EEG data</span></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    fft_data    = fft(<span class="built_in">squeeze</span>(EEG.data(electrodei,:,trial)),n_convolution); <span class="comment">% trial 1</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">        fft_wavelet = fft(wavelet(fi,:),n_convolution);</span><br><span class="line">        convoli = ifft(fft_wavelet.*fft_data,n_convolution) * <span class="built_in">sqrt</span>(s);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">1</span>) = <span class="built_in">abs</span>(convoli.^<span class="number">2</span>);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">2</span>) = <span class="built_in">angle</span>(convoli);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_fft = convolution_result_fft(half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size,:,:,:);</span><br></pre></td></tr></table></figure><h3 id="4-Make-topographical-plots-of-power-and-phase"><a href="#4-Make-topographical-plots-of-power-and-phase" class="headerlink" title="4. Make topographical plots of power and phase"></a>4. Make topographical plots of power and phase</h3><p>Make topographical plots of power and phase at 180 ms at all frequencies (hint: you may need to use the squeeze function to remove singleton dimensions). Arrange the plots in one figure with five columns for frequency and two rows for power/phase. Put labels in the plot so it is clear which topographical maps correspond to which frequencies. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 180 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">180</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/gypqPbMUZfo2iC5.png" alt="Ex_13(1)"></p><h3 id="5-Repeat-step-4-for-activity-at-360-ms"><a href="#5-Repeat-step-4-for-activity-at-360-ms" class="headerlink" title="5. Repeat step 4 for activity at 360 ms."></a>5. Repeat step 4 for activity at 360 ms.</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 360 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">360</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/DxTRqhzK72JtoPL.png" alt="Ex_13(2)"></p><h3 id="6-Think"><a href="#6-Think" class="headerlink" title="6. Think"></a>6. Think</h3><p>Are there any prominent topographical features in power or in phase?     - Yes.</p><p>Do these differ for different frequencies?     - Yes.</p><p>Do power and phase have similar topographical distributions?    - It doesn’t look very similar.</p><p>Is there any reason to suspect that they might have similar or different topographies?     </p><blockquote><h4 id="From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures"><a href="#From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures" class="headerlink" title="(From ChatGPT for reference, GPT is not provided with corresponding pictures)"></a><strong>(From ChatGPT for reference, GPT is not provided with corresponding pictures)</strong></h4><p>When analyzing EEG data, particularly through time-frequency decomposition, you might observe various topographical features in both power and phase distributions across the scalp. These features can provide insights into underlying neural processes. Let’s break down each question:</p><h4 id="1-Are-there-any-prominent-topographical-features-in-power-or-in-phase"><a href="#1-Are-there-any-prominent-topographical-features-in-power-or-in-phase" class="headerlink" title="(1) Are there any prominent topographical features in power or in phase?"></a><strong>(1) Are there any prominent topographical features in power or in phase?</strong></h4><ul><li><strong>Power Topography</strong>: Power topography represents the distribution of signal power across the scalp. Prominent features in power maps could indicate areas of strong neural activity, which might correspond to specific cognitive or sensory processes. For example, increased power in the occipital regions might be related to visual processing.</li><li><strong>Phase Topography</strong>: Phase topography shows the distribution of phase angles across the scalp. Prominent features in phase topography could indicate phase synchronization between regions, which might be associated with communication between different brain areas.</li></ul><h4 id="2-Do-these-differ-for-different-frequencies"><a href="#2-Do-these-differ-for-different-frequencies" class="headerlink" title="(2) Do these differ for different frequencies?"></a><strong>(2) Do these differ for different frequencies?</strong></h4><ul><li>Yes, topographical features often differ for different frequencies. Different frequencies in EEG are associated with different types of neural activity (e.g., alpha waves in the 8-12 Hz range are often related to relaxation and closed eyes, while beta waves in the 13-30 Hz range are associated with active thinking or focus). The power and phase topographies can change significantly across different frequency bands, reflecting the different functional roles of these frequencies.</li></ul><h4 id="3-Do-power-and-phase-have-similar-topographical-distributions"><a href="#3-Do-power-and-phase-have-similar-topographical-distributions" class="headerlink" title="(3) Do power and phase have similar topographical distributions?"></a><strong>(3) Do power and phase have similar topographical distributions?</strong></h4><ul><li>Power and phase distributions are often not identical. Power topography might highlight regions with strong amplitude, while phase topography might emphasize regions where the timing of oscillatory activity is synchronized across electrodes. However, there can be similarities, especially in regions where strong power is accompanied by consistent phase alignment (e.g., in tasks requiring coordinated neural activity across brain regions).</li></ul><h4 id="4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies"><a href="#4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies" class="headerlink" title="(4) Is there any reason to suspect that they might have similar or different topographies?"></a><strong>(4) Is there any reason to suspect that they might have similar or different topographies?</strong></h4><ul><li><strong>Similar Topographies</strong>: Power and phase could have similar topographies in cases where high power is associated with phase-locked activity across trials or regions. For instance, during sensory processing, a stimulus might evoke both strong power and phase synchronization in relevant brain areas.</li><li><strong>Different Topographies</strong>: Conversely, power and phase might differ in their topographical distributions due to different underlying mechanisms. High power might occur in one region without strong phase alignment, especially if the neural activity is more localized or independent across trials. Additionally, phase synchronization can occur without strong power, especially in low-amplitude oscillations that are critical for certain cognitive processes.</li></ul><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h4><ul><li><strong>Power and phase topographies can both reveal important aspects of neural activity, but they often provide different insights</strong>. Power maps tend to show where neural activity is strong, while phase maps can indicate where different regions are temporally synchronized. The topographies of power and phase may differ depending on the frequency of interest and the specific neural processes involved. Understanding these distributions and their relationships is key to interpreting EEG data in the context of neural dynamics.</li></ul></blockquote><h3 id="7-Create-a-circular-colormap"><a href="#7-Create-a-circular-colormap" class="headerlink" title="7.  Create a circular colormap"></a>7.  Create a circular colormap</h3><p>Because phase values are circular ( – <em>π</em> and + <em>π</em> are identical), most color maps are inappropriate because they suggest that – <em>π</em> and + <em>π</em> are very different values (represented, e.g., by blue and red colors). Create a circular colormap that can be used for phase values. You can do this by setting the red, green, and/or blue values to be a cosine function rather than a linear function. Recreate the phase topographical maps. Do they look any different with the new color maps? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自定义用于相位的环形colormap，使得-pi和pi对应的颜色相同</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ax6 = subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">nColors = <span class="number">128</span>; <span class="comment">% 调色板的颜色数量</span></span><br><span class="line">cmap = hsv(nColors); <span class="comment">% 使用 HSV colormap</span></span><br><span class="line">cmap = cmap([<span class="number">1</span>:<span class="keyword">end</span> <span class="number">1</span>], :); <span class="comment">% 将第一个颜色重复，使得 -pi 和 pi 一致</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加环形 colorbar</span></span><br><span class="line">cb = colorbar;</span><br><span class="line">set(cb, <span class="string">&#x27;Ticks&#x27;</span>, [-<span class="built_in">pi</span>, -<span class="built_in">pi</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="built_in">pi</span>/<span class="number">2</span>, <span class="built_in">pi</span>], <span class="string">&#x27;TickLabels&#x27;</span>, &#123;<span class="string">&#x27;-\pi&#x27;</span>, <span class="string">&#x27;-\pi/2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;\pi/2&#x27;</span>, <span class="string">&#x27;\pi&#x27;</span>&#125;);</span><br><span class="line">clim([-<span class="built_in">pi</span> <span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">axis off</span><br><span class="line">cb.Position(<span class="number">1</span>) = ax6.Position(<span class="number">1</span>);</span><br><span class="line">cb.Position(<span class="number">2</span>) = ax6.Position(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/8dGJkcTSfWMRO1A.png" alt="Ex_13(3)"></p><hr><h2 id="Exercises-14-filter-Hilbert"><a href="#Exercises-14-filter-Hilbert" class="headerlink" title="Exercises 14 | filter-Hilbert"></a>Exercises 14 | filter-Hilbert</h2><ol><li>Pick two frequencies (e.g., 5 Hz and 25 Hz) and one electrode and perform complex Morlet wavelet convolution and filter-Hilbert using those two frequencies as the peak/center frequencies for all trials. Plot the resulting power and the bandpass-filtered signal (that is, the real component of the analytic signal) from each method. Plot one single trial (you can choose the trial randomly but plot the same trial for both methods) and then plot the average of all trials. Describe some similarities and differences between the results of the two time-frequency decomposition methods. </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 14</span></span><br><span class="line"><span class="comment">%% 1. perform complex Morlet wavelet convolution and filter-Hilbert using frequencies 5 Hz and 25 Hz</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"><span class="comment">% two frequencies</span></span><br><span class="line">frex = [<span class="number">5</span>, <span class="number">25</span>]; <span class="comment">% the center frequencies</span></span><br><span class="line"><span class="comment">% pick one electrode (Fcz) and one trial</span></span><br><span class="line">electrode = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,<span class="string">&#x27;Fcz&#x27;</span>));</span><br><span class="line">trial = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">data2filter = <span class="built_in">squeeze</span>(EEG.data(electrode,:,trial));</span><br><span class="line">data2filter_average = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(electrode,:,:),<span class="number">3</span>));</span><br><span class="line"><span class="comment">%% perform complex Morlet wavelet convolution</span></span><br><span class="line"><span class="comment">% wavelet parameters</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">numcycles = [<span class="number">4</span> <span class="number">5</span>];</span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">conv_result_wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),n_convolution);</span><br><span class="line">conv_result_wavelet_2 = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),n_convolution);</span><br><span class="line">fft_data = fft(data2filter,n_convolution);</span><br><span class="line">fft_data_2 = fft(data2filter_average,n_convolution);</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi));</span><br><span class="line">    wavelet = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi).*time);</span><br><span class="line">    </span><br><span class="line">    fft_wavelet = fft(wavelet,n_convolution);</span><br><span class="line">    fft_wavelet = fft_wavelet ./ <span class="built_in">max</span>(<span class="built_in">abs</span>(fft_wavelet));</span><br><span class="line">    conv_result_wavelet(fi,:) = ifft(fft_wavelet.*fft_data,n_convolution)*(<span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)));</span><br><span class="line">    conv_result_wavelet_2(fi,:) = ifft(fft_wavelet.*fft_data_2,n_convolution)*(<span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">conv_result_wavelet = conv_result_wavelet(:,half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line">conv_result_wavelet_2 = conv_result_wavelet_2(:,half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line"><span class="comment">%% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">2</span> <span class="number">10</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = [<span class="number">.01</span> <span class="number">.15</span>];</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>) ([<span class="number">1</span> <span class="number">1</span>]-transwid)&#x27;.*(frex-freqspread)&#x27; (frex-freqspread)&#x27; (frex+freqspread)&#x27; ([<span class="number">1</span> <span class="number">1</span>]+transwid)&#x27;.*(frex+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(fi),EEG.pnts);</span><br><span class="line">filter_result_2 = <span class="built_in">zeros</span>(<span class="built_in">length</span>(fi),EEG.pnts);</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">    fft_filter = fft(filterweights);</span><br><span class="line">    filter_result(fi,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    filter_result_2(fi,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter_average));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(conv_result_wavelet(<span class="built_in">i</span>,:)).^<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(filter_result(<span class="built_in">i</span>,:)).^<span class="number">2</span>)</span><br><span class="line">    set(gca,<span class="string">&quot;XLim&quot;</span>,[<span class="number">-500</span>,<span class="number">1000</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Voltage (\muV)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Center Frequency: &#x27;</span> num2str(frex(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;wavelet&#x27;</span>,<span class="string">&#x27;filter-Hilbert&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(conv_result_wavelet_2(<span class="built_in">i</span>,:)).^<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(filter_result_2(<span class="built_in">i</span>,:)).^<span class="number">2</span>)</span><br><span class="line">    set(gca,<span class="string">&quot;XLim&quot;</span>,[<span class="number">-500</span>,<span class="number">1000</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Voltage (\muV)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Center Frequency: &#x27;</span> num2str(frex(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;wavelet&#x27;</span>,<span class="string">&#x27;filter-Hilbert&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/26/5IQZ4tyGiRP6Lck.png" alt="Ex_14(1)_onetrial"></p><p><img src="https://s2.loli.net/2024/08/26/LfFCS7RhA6BjYpX.png" alt="Ex_14(1)_onetrial"></p><ol><li>Modify the wavelet and filter settings (but keep the peak/center frequencies the same) until these two methods produce very similar results. Next, modify the wavelet and filter settings (except the peak/center frequencies) to make the results different (stay within a reasonable range of parameter settings; they do not need to look dramatically different). Which parameters did you change to make the results look more similar versus more different? How different are the results, and would you consider this a meaningful difference? What does this difference tell you about when to use specific parameter settings for wavelet convolution and the filter-Hilbert method? </li></ol><p>尝试改变的参数：</p><ul><li>wavelet：<ul><li>numcycles：wavelet包含的周期数目参数。包含的周期数目越多，wavelet频带越窄，频率分辨率越高</li></ul></li><li>filter-Hilbert：<ul><li>freqspread：带宽参数。带宽越大，频率分辨率越低</li><li>transwid：过渡区宽度参数。</li><li><code>firls()</code>的第一个参数，the order of the filter：决定filter kernel频率响应的精度。</li></ul></li></ul><hr><h2 id="Exercises-15-The-Short-Time-FFT"><a href="#Exercises-15-The-Short-Time-FFT" class="headerlink" title="Exercises 15 | The Short-Time FFT"></a>Exercises 15 | The Short-Time FFT</h2><ol><li>Compute the <strong>short-time FFT</strong> at each electrode and make topographical maps of theta band (around 6 Hz) power and alpha-band (around 10 Hz) power at 150 ms and 700 ms. </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Compute the short-time FFT at each electrode</span></span><br><span class="line"><span class="comment">% and make topographical maps of theta band (around 6 Hz) power and alpha-band (around 10 Hz) power at 150 ms and 700 ms. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">50</span>:<span class="number">1000</span>; <span class="comment">% in ms</span></span><br><span class="line">timepoint(<span class="number">1</span>) = <span class="number">150</span>;   <span class="comment">% ms</span></span><br><span class="line">timepoint(<span class="number">2</span>) = <span class="number">700</span>;   <span class="comment">% ms</span></span><br><span class="line">frequency(<span class="number">1</span>) = <span class="number">6</span>;     <span class="comment">% Hz</span></span><br><span class="line">frequency(<span class="number">2</span>) = <span class="number">10</span>;    <span class="comment">% Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert ms to idx</span></span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> frexi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [junk,times2saveidx(frexi)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(frexi)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">0.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">tf = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frex),<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    <span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">        tempdat = <span class="built_in">squeeze</span>(EEG.data(channi,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">        <span class="comment">% and hann_win)</span></span><br><span class="line">        taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">        </span><br><span class="line">        fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">        tf(channi,:,timepointi) = <span class="built_in">mean</span>(<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>,<span class="number">2</span>); <span class="comment">% average over trials</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[junk,frequencyidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency(<span class="number">1</span>)));</span><br><span class="line">[junk,frequencyidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency(<span class="number">2</span>)));</span><br><span class="line">[junk,timepointidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-timepoint(<span class="number">1</span>)));</span><br><span class="line">[junk,timepointidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-timepoint(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> timei = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> frexi = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        subplot(<span class="number">2</span>,<span class="number">2</span>,(timei<span class="number">-1</span>)*<span class="number">2</span>+frexi)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(tf(:,frequencyidx(frexi),timepointidx(timei))),EEG.chanlocs);</span><br><span class="line">        title([num2str(timepoint(timei)) <span class="string">&#x27;ms, &#x27;</span> num2str(frequency(frexi)) <span class="string">&#x27;Hz&#x27;</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/01/IZGUTadVePJ85Qt.png" alt="Ex_15(1)" style="zoom:50%;" /></p><ol><li>Select one electrode and one frequency and compute power over time at that electrode and that frequency using <strong>complex wavelet convolution</strong>, <strong>filter-Hilbert</strong>, and the <strong>short-time FFT</strong>. Plot the results of these three time-frequency decomposition methods in different subplots of one figure. Note that the scaling might be different because no baseline normalization has been applied. How visually similar are the results from these three methods? If the results from the three methods are different, how are they different, and what parameters do you think you could change in the three methods to make the results look more or less similar? </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select one electrode and one frequency and compute power over time at that electrode and that frequency</span></span><br><span class="line"><span class="comment">% using complex wavelet convolution, filter-Hilbert, and the short-time FFT.</span></span><br><span class="line"></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">channel2plot = <span class="string">&#x27;Fcz&#x27;</span>;</span><br><span class="line">electrode = strcmpi(channel2plot,&#123;EEG.chanlocs.labels&#125;);</span><br><span class="line">frequency = <span class="number">6</span>;     <span class="comment">% in Hz</span></span><br><span class="line"></span><br><span class="line">times2save = <span class="number">-200</span>:<span class="number">1000</span>/EEG.srate:<span class="number">800</span>;</span><br><span class="line"><span class="comment">% convert from ms to index</span></span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [junk,times2saveidx(<span class="built_in">i</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% complex wavelet convolution</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">numcycle = <span class="number">4</span>;</span><br><span class="line">s = numcycle/(<span class="number">2</span>*<span class="built_in">pi</span>*frequency);</span><br><span class="line">wavelet = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frequency.*time);</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT of wavelet and EEG data</span></span><br><span class="line">fft_wavelet = fft(wavelet,n_convolution);</span><br><span class="line">convol = <span class="built_in">zeros</span>(EEG.trials,n_convolution);</span><br><span class="line"><span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">    fft_data    = fft(<span class="built_in">squeeze</span>(EEG.data(electrode,:,triali)),n_convolution);</span><br><span class="line">    convol(triali,:) = ifft(fft_wavelet.*fft_data,n_convolution);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">convolution_result_fft = <span class="built_in">mean</span>((<span class="built_in">abs</span>(convol).^<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_fft = convolution_result_fft(half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% filter-Hilbert</span></span><br><span class="line">freqspread = <span class="number">3</span>; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.01</span>;</span><br><span class="line">nyquist = EEG.srate/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="number">0</span> (<span class="number">1</span>-transwid)&#x27;.*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (<span class="number">1</span>+transwid)&#x27;.*(frequency+freqspread)&#x27; nyquist ]./nyquist;</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line"></span><br><span class="line">filterweights = firls(<span class="number">200</span>,ffrequencies,idealresponse);</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(EEG.trials,EEG.pnts);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">    filter_result(triali,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,EEG.data(electrode,:,triali)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">filter_result = <span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result.^<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line"><span class="comment">%% the short-time FFT</span></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">    tempdat = <span class="built_in">squeeze</span>(EEG.data(electrode,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">    <span class="comment">% and hann_win)</span></span><br><span class="line">    taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">    </span><br><span class="line">    fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">    tf(:,timepointi) = <span class="built_in">mean</span>(<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>,<span class="number">2</span>); <span class="comment">% average over trials</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[junk,frequencyidx]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency));</span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(times2save,tf(frequencyidx,:)./(<span class="built_in">max</span>(tf(frequencyidx,:))),<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(times2save,convolution_result_fft(times2saveidx)./(<span class="built_in">max</span>(convolution_result_fft(times2saveidx))),<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.8</span> <span class="number">0</span>],<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(times2save,filter_result(times2saveidx)./(<span class="built_in">max</span>(filter_result(times2saveidx))),<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Short-Time FFT&#x27;</span>,<span class="string">&#x27;complex wavelet&#x27;</span>,<span class="string">&#x27;Hilbert-filter&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0.2</span>,<span class="number">1.3</span>]) </span><br><span class="line">colormap parula</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/10/15/8ksfL9EAevVWQbX.png" alt="Ex_15(2)" style="zoom:67%;" /></p><hr><h2 id="Exercises-16-Multitaper"><a href="#Exercises-16-Multitaper" class="headerlink" title="Exercises 16 | Multitaper"></a>Exercises 16 | Multitaper</h2><ol><li><p>Pick one electrode and compute a time-frequency map of power using both the multitaper method and the short-time FFT. Store all of the power values for all of the trials.</p></li><li><p>Next, compute a time-frequency map of signal-to-noise ratio. The signal-to-noise ratio of power is discussed more in chapter 18, but it can be estimated as the average power at each time-frequency point across trials, divided by the standard deviation of power at each time-frequency point across trials. </p></li><li>Make time-frequency plots of power and signal-to-noise ratio from the two methods. Make another plot in which you subtract the signal-to-noise plots between the two methods. Are there any noticeable differences between the signal-to-noise results when the multitaper method versus the short-time FFT is used? </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick one electrode and compute a time-frequency map of power using both the multitaper method and the short-time FFT.</span></span><br><span class="line">load sampleEEGdata</span><br><span class="line"></span><br><span class="line">channel2plot = <span class="string">&#x27;p7&#x27;</span>;</span><br><span class="line">channel2plotidx = strcmpi(channel2plot,&#123;EEG.chanlocs.labels&#125;);</span><br><span class="line"></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">50</span>:<span class="number">1000</span>; <span class="comment">% in ms</span></span><br><span class="line"><span class="comment">% convert from ms to index</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [~,times2saveidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">baseline_range  = [<span class="number">-200</span> <span class="number">-00</span>];</span><br><span class="line"><span class="comment">% find baselinetimepoints</span></span><br><span class="line">baseidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(baseline_range));</span><br><span class="line">[~,baseidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-baseline_range(<span class="number">1</span>)));</span><br><span class="line">[~,baseidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-baseline_range(<span class="number">2</span>)));</span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% multitaper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 参数设置</span></span><br><span class="line">N = timewinidx; <span class="comment">% 样本点数</span></span><br><span class="line">W = <span class="number">4</span>;    <span class="comment">% 频带宽度</span></span><br><span class="line">Fs = EEG.srate; <span class="comment">% 采样率</span></span><br><span class="line">NW = N * (W / (Fs/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成tapers</span></span><br><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择特征值大于0.9的tapers</span></span><br><span class="line">tapersToUse = tapers(:, eigenvalues &gt; <span class="number">0.9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize output matrix</span></span><br><span class="line">multitaper_tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials,<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop through time bins</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)  <span class="comment">% 对应一个时间点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% initialize power vector (over tapers)</span></span><br><span class="line">    <span class="comment">% 一个时间点处各频率的功率值，对应tf图上与时间轴垂直的一条线段</span></span><br><span class="line">    taperpow = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% loop through tapers</span></span><br><span class="line">    <span class="keyword">for</span> tapi = <span class="number">1</span>:<span class="built_in">size</span>(tapersToUse,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">        tempdat = <span class="built_in">squeeze</span>(EEG.data(channel2plotidx,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">        data      = <span class="built_in">bsxfun</span>(@times,tempdat,tapersToUse(:,tapi));</span><br><span class="line"></span><br><span class="line">        <span class="comment">% timewindow截取、taper两端减弱后的数据进行Fourier变换，提取特定频率的功率值</span></span><br><span class="line">        pow       = fft(data,timewinidx)/timewinidx;</span><br><span class="line">        pow       = pow(<span class="number">1</span>:<span class="built_in">length</span>(frex),:);</span><br><span class="line">        taperpow  = taperpow + pow.*<span class="built_in">conj</span>(pow);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% finally, get power from closest frequency</span></span><br><span class="line">    multitaper_tf(:,:,timepointi) = taperpow/tapi;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% the short-time FFT</span></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">fft_tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials,<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">    tempdat = <span class="built_in">squeeze</span>(EEG.data(channel2plotidx,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">    <span class="comment">% and hann_win)</span></span><br><span class="line">    taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">    </span><br><span class="line">    fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">    fft_tf(:,:,timepointi) =<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>; <span class="comment">% average over trials</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% compute a time-frequency map of signal-to-noise ratio.</span></span><br><span class="line">multitaper_mean = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(multitaper_tf,<span class="number">2</span>));</span><br><span class="line">fft_mean = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(fft_tf,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">multitaper_std = <span class="built_in">squeeze</span>(std(multitaper_tf,[],<span class="number">2</span>));</span><br><span class="line">fft_std = <span class="built_in">squeeze</span>(std(fft_tf,[],<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">snr_multitaper = multitaper_mean ./ multitaper_std;</span><br><span class="line">snr_fft = fft_mean ./ fft_std;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="comment">% db-correct</span></span><br><span class="line">db_multitaper_tf = <span class="number">10</span>*<span class="built_in">log10</span>( multitaper_mean ./ <span class="built_in">repmat</span>(<span class="built_in">mean</span>(multitaper_mean(:,baseidx(<span class="number">1</span>):baseidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">length</span>(times2save)) );</span><br><span class="line"><span class="comment">% db-correct</span></span><br><span class="line">db_fft_tf = <span class="number">10</span>*<span class="built_in">log10</span>( fft_mean ./ <span class="built_in">repmat</span>(<span class="built_in">mean</span>(fft_mean(:,baseidx(<span class="number">1</span>):baseidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">length</span>(times2save)) );</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">colormap jet</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">contourf(times2save,frex,db_multitaper_tf,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;Power of Multitaper&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">contourf(times2save,frex,db_fft_tf,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;Power of FFT&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">contourf(times2save,frex,snr_multitaper,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0.4</span> <span class="number">1.6</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;SNR of Multitaper&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">contourf(times2save,frex,snr_fft,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0.4</span> <span class="number">1.6</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;SNR of FFT&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">colormap jet</span><br><span class="line">contourf(times2save,frex,snr_multitaper-snr_fft,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">colorbar</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-0.2</span> <span class="number">1.2</span>])</span><br><span class="line">title(<span class="string">&#x27;SNR_&#123;Multipaper&#125; minus SNR_&#123;FFT&#125;&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/02/K3nNI58gTucP7Xj.png" alt="Ex_16(1)" style="zoom: 50%;" /></p><p><img src="https://s2.loli.net/2024/09/02/acKXeDqzrPkFV16.png" alt="Ex_16(2)" style="zoom:50%;" /></p><ol><li>Select two frequencies, one relatively low and one relatively high (e.g., 8 Hz and 60 Hz), and compare the power time series and signal-to-noise time series in these frequency bands from the two methods in a separate figure, using line plots. Comment on the differences if there are any. </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select two frequencies, one relatively low and one relatively high (e.g., 8 Hz and 60 Hz), </span></span><br><span class="line"><span class="comment">% and compare the power time series and signal-to-noise time series in these frequency bands </span></span><br><span class="line"><span class="comment">% from the two methods in a separate figure, using line plots.</span></span><br><span class="line">frequncies = [<span class="number">8</span>, <span class="number">60</span>];</span><br><span class="line">frequnciesidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(frequncies));</span><br><span class="line">[~,frequnciesidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequncies(<span class="number">1</span>)));</span><br><span class="line">[~,frequnciesidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequncies(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frequncies)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save,db_multitaper_tf(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    title([<span class="string">&#x27;Frequency: &#x27;</span> num2str(frequncies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz, Power&#x27;</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Power (dB)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save,db_fft_tf(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;Multitaper&#x27;</span>,<span class="string">&#x27;FFT&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save,snr_multitaper(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    title([<span class="string">&#x27;Frequency: &#x27;</span> num2str(frequncies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz, SNR&#x27;</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;SNR&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save,snr_fft(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;Multitaper&#x27;</span>,<span class="string">&#x27;FFT&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/03/WkcpXonqmF8lbr5.png" alt="Ex_16(3)" style="zoom: 50%;" /></p><ul><li>Multitaper常用于低信噪比的情况，如高频活动或功率的单试次估计。通过使用多个taper，multitaper方法在频率轴上引入了一定的<strong>平滑效应</strong>。这种平滑可以减少频率分辨率的精细度，使得<strong>频谱变得更加连续和平滑</strong>。</li></ul><hr><h2 id="Exercises-18-Baseline-Normalization"><a href="#Exercises-18-Baseline-Normalization" class="headerlink" title="Exercises 18 | Baseline Normalization"></a>Exercises 18 | Baseline Normalization</h2><ol><li><p>Select three frequency bands and compute time-varying power at each electrode in these three bands, using either complex wavelet convolution or filter-Hilbert. Compute and store both the baseline-corrected power and the raw non-baseline-corrected power. You can choose which time period and baseline normalization method to use. </p></li><li><p>Select five time points and create topographical maps of power with and without baseline normalization at each selected time-frequency point. You should have time in columns and with/without baseline normalization in rows. Use separate figures for each frequency. The color scaling should be the same for all plots over time within a frequency, but the color scaling should be different for with versus without baseline normalization and should also be different for each frequency. </p></li><li>Are there qualitative differences in the topographical distributions of power with compared to without baseline normalization? Are the differences more prominent in some frequency bands or at some time points? What might be causing these differences? </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select three frequency bands and compute time-varying power at each electrode in these three bands, using either complex wavelet convolution or filter-Hilbert.</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequency = [<span class="number">6</span> <span class="number">15</span> <span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">4</span> <span class="number">4</span> <span class="number">4</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.1</span>;</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequency+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">raw_result = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frequency),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(EEG.data(electrodei,:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">        filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        raw_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">raw_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(raw_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(raw_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">baseline_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,raw_result,baseline_power));</span><br><span class="line"></span><br><span class="line">timepoints = <span class="number">0</span>:<span class="number">100</span>:<span class="number">400</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timepoints)</span><br><span class="line">    [~,timepointsidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timepoints(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">    <span class="built_in">figure</span></span><br><span class="line">    sgtitle([<span class="string">&#x27;frequncy: &#x27;</span> num2str(frequency(fi)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    max_raw = <span class="built_in">ceil</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">abs</span>(raw_result(:,fi,timepointsidx)))));</span><br><span class="line">    max_baseline = <span class="built_in">ceil</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">abs</span>(baseline_dbconverted(:,fi,timepointsidx)))));</span><br><span class="line">    <span class="keyword">for</span> ti = <span class="number">1</span>:<span class="built_in">length</span>(timepoints)</span><br><span class="line">        subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,ti)</span><br><span class="line">        topoplot(raw_result(:,fi,timepointsidx(ti)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        title([<span class="string">&#x27;Raw Power, &#x27;</span> num2str(timepoints(ti)) <span class="string">&#x27;ms&#x27;</span>])   </span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[-max_raw,max_raw])</span><br><span class="line"></span><br><span class="line">        subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>+ti);</span><br><span class="line">        topoplot(baseline_dbconverted(:,fi,timepointsidx(ti)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        title([<span class="string">&#x27;DB Power, &#x27;</span> num2str(timepoints(ti)) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[-max_baseline,max_baseline])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    subplot(subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>))</span><br><span class="line">    axis off</span><br><span class="line">    colorbar(<span class="string">&#x27;Ticks&#x27;</span>,[<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],<span class="string">&#x27;TickLabels&#x27;</span>,[-max_raw, -max_raw/<span class="number">2</span>, <span class="number">0</span>, max_raw/<span class="number">2</span>, max_raw]);</span><br><span class="line">    </span><br><span class="line">    subplot(subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,<span class="number">2</span>*(<span class="built_in">length</span>(timepoints)+<span class="number">1</span>)))</span><br><span class="line">    axis off</span><br><span class="line">    colorbar(<span class="string">&#x27;Ticks&#x27;</span>,[<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],<span class="string">&#x27;TickLabels&#x27;</span>,[-max_baseline, -max_baseline/<span class="number">2</span>, <span class="number">0</span>, max_baseline/<span class="number">2</span>, max_baseline]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/03/3z12yptIrshBUcF.png" alt="Ex_18_6Hz" style="zoom: 45%;" /></p><p><img src="https://s2.loli.net/2024/09/03/sHWeBm4nFMlz9cR.png" alt="Ex_18_15Hz" style="zoom:45%;" /></p><p><img src="https://s2.loli.net/2024/09/03/8hnCD9qUrumiJgc.png" alt="Ex_18_60Hz" style="zoom:45%;" /></p><hr><h2 id="Exercises-19-ITPC-Intertrial-Phase-Clustering"><a href="#Exercises-19-ITPC-Intertrial-Phase-Clustering" class="headerlink" title="Exercises 19 | ITPC (Intertrial Phase Clustering)"></a>Exercises 19 | ITPC (Intertrial Phase Clustering)</h2><ol><li>Pick three electrodes. Compute time-frequency plots of ITPC and decibel-corrected power for these electrodes, using either complex Morlet wavelet convolution or the filter-Hilbert method. Plot the results side by side for each electrode (power and ITPC in subplots; one figure for each electrode). Are the patterns of results from ITPC and power generally similar or generally different? Do the results look more similar at some electrodes and less similar at other electrodes? </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick three electrodes. Compute time-frequency plots of ITPC and decibel-corrected power for these electrodes, using either complex Morlet wavelet convolution or the filter-Hilbert method. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">electrode = [<span class="string">&quot;fz&quot;</span>, <span class="string">&quot;p8&quot;</span>, <span class="string">&quot;oz&quot;</span>];</span><br><span class="line">electrodeidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(electrode));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(electrode) </span><br><span class="line">    electrodeidx(<span class="built_in">i</span>) = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,electrode(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">frequencies = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">30</span>),<span class="number">30</span>);</span><br><span class="line"><span class="comment">%% calculate power</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line"></span><br><span class="line">freqspread = <span class="built_in">linspace</span>(<span class="number">1</span>,<span class="number">6</span>,<span class="built_in">length</span>(frequencies)); <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.1</span>;</span><br><span class="line">nyquist = <span class="built_in">repmat</span>(EEG.srate/<span class="number">2</span>, <span class="built_in">size</span>(frequencies));</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">ones</span>(<span class="built_in">length</span>(frequencies),<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequencies-freqspread)&#x27; (frequencies-freqspread)&#x27; (frequencies+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequencies+freqspread)&#x27; nyquist&#x27; ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(electrode),<span class="built_in">length</span>(frequencies),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">        filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        filter_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">power_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(power_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">power_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,power_result,baseline_power));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% calculate ITPC</span></span><br><span class="line">ITPC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">angle</span>(filter_result)),<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">time2plot = [<span class="number">-300</span>, <span class="number">1000</span>];</span><br><span class="line">time2plotidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(time2plot));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    [~,time2plotidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-time2plot(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,electrodei)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(power_dbconverted(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">    title([<span class="string">&#x27;Power from &#x27;</span> num2str(electrode(electrodei))])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>+electrodei)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(ITPC(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    title([<span class="string">&#x27;ITPC from &#x27;</span> num2str(electrode(electrodei))])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/03/PQAfsYTyS8UwIZ5.png" alt="Ex_19(1)" style="zoom: 67%;" /></p><ol><li>For each of these three electrodes, compute wITPCz using reaction time as the trial-varying modulator. Perform this analysis for all time-frequency points to generate time-frequency maps of the relationship between phase and reaction time. Do the time-frequency maps of wITPCz look different from the time-frequency maps of ITPC? Do you see any striking patterns in the ITPCz results, and do the results differ across the different electrodes (don ’ t worry about statistics, base your judgment on qualitative patterns)? How would you interpret the results if they were statistically significant? </li></ol><hr><h2 id="Exercises-20-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency"><a href="#Exercises-20-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency" class="headerlink" title="Exercises 20 | Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency"></a>Exercises 20 | Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency</h2><p>Pick two frequencies and compute total and non-phase-locked power from each electrode over time at these two frequencies. Pick two time windows, one early and one late, of several hundreds of milliseconds each (e.g., 100 – 300 ms and 500 – 800 ms) and show topographical maps of total power, non-phase-locked power, and phase-locked power from the average of all time points within these windows. Are there striking topographical differences among these results? If so, are the differences bigger or smaller in the early or the late time window? Why might this be the case? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick two frequencies and compute total and non-phase-locked power from each electrode over time at these two frequencies. </span></span><br><span class="line"><span class="comment">% compute total power</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequency = [<span class="number">5</span> <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">1.5</span> <span class="number">4</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.15</span>;</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequency+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">raw_result = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frequency),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(EEG.data(electrodei,:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">        filterweights = firls(<span class="number">200</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        raw_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">raw_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(raw_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(raw_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">baseline_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,raw_result,baseline_power));</span><br><span class="line">timewindow = [<span class="number">100</span>,<span class="number">300</span>; <span class="number">600</span>, <span class="number">900</span>];</span><br><span class="line">timewindowidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timewindowidx)</span><br><span class="line">    [~,timewindowidx(<span class="built_in">i</span>,<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">1</span>)));</span><br><span class="line">    [~,timewindowidx(<span class="built_in">i</span>,<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">2</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">total = <span class="built_in">zeros</span>(<span class="built_in">length</span>(timewindow),EEG.nbchan,<span class="built_in">length</span>(frequency));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timewindow)</span><br><span class="line">    total(<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(baseline_dbconverted(:,:,timewindowidx(<span class="built_in">i</span>,<span class="number">1</span>):timewindowidx(<span class="built_in">i</span>,<span class="number">2</span>)),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% compute non-phase-locked power</span></span><br><span class="line"><span class="comment">% compute ERP</span></span><br><span class="line">erp = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(:,:,:),<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% compute induced power by subtracting ERP from each trial</span></span><br><span class="line">induced_EEG = EEG.data(:,:,:) - <span class="built_in">repmat</span>(erp,[<span class="number">1</span> <span class="number">1</span> EEG.trials]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% filter the induced eeg data</span></span><br><span class="line">raw_result_non_phase_locked = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frequency),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(induced_EEG(electrodei,:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">        filterweights = firls(<span class="number">200</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        raw_result_non_phase_locked(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">raw_result_non_phase_locked = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(raw_result_non_phase_locked).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% baseline normalization</span></span><br><span class="line">baseline_dbconverted_non_phase_locked = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,raw_result_non_phase_locked,baseline_power));</span><br><span class="line"></span><br><span class="line">non_phase_locked = <span class="built_in">zeros</span>(<span class="built_in">length</span>(timewindow),EEG.nbchan,<span class="built_in">length</span>(frequency));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timewindow)</span><br><span class="line">    non_phase_locked(<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(baseline_dbconverted_non_phase_locked(:,:,timewindowidx(<span class="built_in">i</span>,<span class="number">1</span>):timewindowidx(<span class="built_in">i</span>,<span class="number">2</span>)),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% compute phase-locked power</span></span><br><span class="line">phase_locked = total - non_phase_locked;</span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">n = <span class="number">0</span>;  <span class="comment">% 用于绘子图时计算行数</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">    <span class="keyword">for</span> twi = <span class="number">1</span>:<span class="built_in">length</span>(timewindow)</span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>*n+<span class="number">1</span>)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(total(twi,:,fi)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-2</span>,<span class="number">2</span>])</span><br><span class="line">        title([<span class="string">&#x27;Total (&#x27;</span> num2str(frequency(fi)) <span class="string">&#x27;Hz, &#x27;</span> num2str(timewindow(twi,<span class="number">1</span>)) <span class="string">&#x27;-&#x27;</span> num2str(timewindow(twi,<span class="number">2</span>)) <span class="string">&#x27;ms)&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>*n+<span class="number">2</span>)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(non_phase_locked(twi,:,fi)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-2</span>,<span class="number">2</span>])</span><br><span class="line">        title([<span class="string">&#x27;Non-Phase-Locked (&#x27;</span> num2str(frequency(fi)) <span class="string">&#x27;Hz, &#x27;</span> num2str(timewindow(twi,<span class="number">1</span>)) <span class="string">&#x27;-&#x27;</span> num2str(timewindow(twi,<span class="number">2</span>)) <span class="string">&#x27;ms)&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>*n+<span class="number">3</span>)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(phase_locked(twi,:,fi)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-1</span>,<span class="number">1</span>])</span><br><span class="line">        title([<span class="string">&#x27;Phase-Locked (&#x27;</span> num2str(frequency(fi)) <span class="string">&#x27;Hz, &#x27;</span> num2str(timewindow(twi,<span class="number">1</span>)) <span class="string">&#x27;-&#x27;</span> num2str(timewindow(twi,<span class="number">2</span>)) <span class="string">&#x27;ms)&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        n = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    colormap jet</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/04/yZaAUzbl3Nus6wh.png" alt="Ex_20" style="zoom:67%;" /></p><hr><h1 id="Part-4"><a href="#Part-4" class="headerlink" title="Part 4"></a>Part 4</h1><h2 id="Exercises-22-Surface-Laplacian"><a href="#Exercises-22-Surface-Laplacian" class="headerlink" title="Exercises 22 | Surface Laplacian"></a>Exercises 22 | Surface Laplacian</h2><ol><li><p>Based on the topographical maps of ERPs in figure 22.6 (plate 12) , select one electrode whose activity you think might look similar before and after computing the surface Laplacian, and one electrode whose activity you think might look different before and after the surface Laplacian. </p><p>(1) look similar before and after computing the surface Laplacian: <strong>FC1</strong></p><p>(2) look different before and after the surface Laplacian: <strong>PO8</strong></p><p><img src="https://s2.loli.net/2024/09/06/91IQ6UqVTAFykvG.png" alt="Figure22.6"></p></li><li><p>Perform a time-frequency decomposition of the data from those two electrodes both before and after computing the surface Laplacian (that is, compute the surface Laplacian on the raw data before applying a time-frequency decomposition). Compute both power (decibels normalized using a baseline period of your choice) and ITPC. </p></li><li><p>Plot the results using the same color scaling for before and after the surface Laplacian. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 获得Surface Laplacian处理前后的数据</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"><span class="comment">% extract XYZ coordinates from EEG structure</span></span><br><span class="line">X = [EEG.chanlocs.X];</span><br><span class="line">Y = [EEG.chanlocs.Y];</span><br><span class="line">Z = [EEG.chanlocs.Z];</span><br><span class="line"><span class="comment">% compute surface laplacian</span></span><br><span class="line">lap_data = laplacian_perrinX(EEG.data,X,Y,Z);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算Power</span></span><br><span class="line">electrode = [<span class="string">&quot;FC1&quot;</span>, <span class="string">&quot;PO8&quot;</span> ,<span class="string">&quot;FC4&quot;</span>];</span><br><span class="line">electrodeidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(electrode));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(electrode) </span><br><span class="line">    electrodeidx(<span class="built_in">i</span>) = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,electrode(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">frequencies = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">2</span>),<span class="built_in">log10</span>(<span class="number">40</span>),<span class="number">30</span>);</span><br><span class="line"><span class="comment">%% calculate power</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line"></span><br><span class="line">freqspread = <span class="built_in">linspace</span>(<span class="number">0.8</span>,<span class="number">6</span>,<span class="built_in">length</span>(frequencies)); <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.1</span>;</span><br><span class="line">nyquist = <span class="built_in">repmat</span>(EEG.srate/<span class="number">2</span>, <span class="built_in">size</span>(frequencies));</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">ones</span>(<span class="built_in">length</span>(frequencies),<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequencies-freqspread)&#x27; (frequencies-freqspread)&#x27; (frequencies+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequencies+freqspread)&#x27; nyquist&#x27; ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(electrode),<span class="built_in">length</span>(frequencies),<span class="number">3</span>*EEG.pnts,EEG.trials);</span><br><span class="line">filter_result_lap = <span class="built_in">zeros</span>(<span class="built_in">length</span>(electrode),<span class="built_in">length</span>(frequencies),<span class="number">3</span>*EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    data2filter = [<span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:))); <span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:)); <span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:)))];</span><br><span class="line">    data2filter_lap= [<span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(lap_data(electrodeidx(electrodei),:,:))); <span class="built_in">squeeze</span>(lap_data(electrodeidx(electrodei),:,:)); <span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(lap_data(electrodeidx(electrodei),:,:)))];</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">        filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        filter_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">        filter_result_lap(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter_lap));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">filter_result = filter_result(:,:,<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span>:<span class="keyword">end</span>*<span class="number">2</span>/<span class="number">3</span>,:);</span><br><span class="line">filter_result_lap = filter_result_lap(:,:,<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span>:<span class="keyword">end</span>*<span class="number">2</span>/<span class="number">3</span>,:);</span><br><span class="line">power_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">power_result_lap = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result_lap).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(power_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">baseline_power_lap = <span class="built_in">mean</span>(power_result_lap(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">power_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,power_result,baseline_power));</span><br><span class="line">power_dbconverted_lap = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,power_result_lap,baseline_power_lap));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% calculate ITPC</span></span><br><span class="line">ITPC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">angle</span>(filter_result)),<span class="number">4</span>));</span><br><span class="line">ITPC_lap = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">angle</span>(filter_result_lap)),<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">time2plot = [<span class="number">-300</span>, <span class="number">1000</span>];</span><br><span class="line">time2plotidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(time2plot));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    [~,time2plotidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-time2plot(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    <span class="built_in">figure</span>(electrodei)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(power_dbconverted(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;Before Laplacian&#x27;</span>, [<span class="string">&#x27;Power from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(ITPC(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0</span> <span class="number">0.3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;Before Laplacian&#x27;</span>, [<span class="string">&#x27;ITPC from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(power_dbconverted_lap(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;After Laplacian&#x27;</span>, [<span class="string">&#x27;Power from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(ITPC_lap(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0</span> <span class="number">0.3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;After Laplacian&#x27;</span>, [<span class="string">&#x27;ITPC from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/06/c5YvOF8VH3RBhEt.png" alt="Ex_22(1)" style="zoom: 50%;" /></p><p><img src="https://s2.loli.net/2024/09/06/8vFAIJibtjwNEq9.png" alt="Ex_22(2)" style="zoom:50%;" /></p><ol><li>Are there any salient differences in the time-frequency power or ITPC results before versus after application of the surface Laplacian, and do the differences depend on the frequency? How would you interpret similarities and differences at different frequency bands? </li></ol><ul><li>There are differences and the differences depend on the frequency, like the power from PC1 at 10 Hz and from PO8 at 15 Hz.</li></ul><hr><h2 id="Exercises-23-Principal-Components-Analysis-PCA"><a href="#Exercises-23-Principal-Components-Analysis-PCA" class="headerlink" title="Exercises 23 | Principal Components Analysis (PCA)"></a>Exercises 23 | Principal Components Analysis (PCA)</h2><ol><li><p>Perform PCA on broadband data using two time windows, one before and one after trial onset (e.g., – 500 to 0 ms and 100 to 600 ms). </p></li><li><p>Plot topographical maps and time courses of the first four components. To construct the PCA time courses, multiply the PCA weights defined by the pre- and posttrial time windows with the electrode time courses from the entire trial. Do you notice any differences in the topographical maps or time courses from before versus after stimulus onset? How would you interpret differences and/or similarities? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Perform PCA on broadband data using two time windows</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">timewindow = [<span class="number">-500</span>, <span class="number">0</span>; <span class="number">100</span>, <span class="number">600</span>];       <span class="comment">% in ms, 选取的timewindow</span></span><br><span class="line">timewindow_idx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(timewindow,<span class="number">1</span>)</span><br><span class="line">    [~,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">1</span>)));</span><br><span class="line">    [~,timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">2</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% timewindow的长度</span></span><br><span class="line">timewindow_length = timewindow_idx(<span class="number">1</span>,<span class="number">2</span>)-timewindow_idx(<span class="number">1</span>,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% compute covariance of ERP </span></span><br><span class="line">covar = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">pc = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">temp_eigvals = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">eigvals = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan);</span><br><span class="line"></span><br><span class="line"><span class="comment">% average single-trial covariances. 先对每一个试次计算协方差，最后平均</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(timewindow,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> triali=<span class="number">1</span>:EEG.trials</span><br><span class="line">        eeg = <span class="built_in">bsxfun</span>(@minus,<span class="built_in">squeeze</span>(EEG.data(:,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>):timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>),triali)),<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(:,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>):timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>),triali),<span class="number">2</span>)));</span><br><span class="line">        covar(<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(covar(<span class="built_in">i</span>,:,:)) + (eeg*eeg&#x27;)./(timewindow_length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    covar(<span class="built_in">i</span>,:,:) = covar(<span class="built_in">i</span>,:,:)./triali;</span><br><span class="line">    <span class="comment">% principle components analysis via eigenvalue decomposition 计算特征值eigvals、特征向量pc</span></span><br><span class="line">    [pc(<span class="built_in">i</span>,:,:),temp_eigvals(<span class="built_in">i</span>,:,:)] = eig(<span class="built_in">squeeze</span>(covar(<span class="built_in">i</span>,:,:)));</span><br><span class="line">    eigvals(<span class="built_in">i</span>,:) = <span class="built_in">diag</span>(<span class="built_in">squeeze</span>(temp_eigvals(<span class="built_in">i</span>,:,:)))&#x27;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">clear temp_eigvals</span><br><span class="line"></span><br><span class="line"><span class="comment">% components are listed in increasing order, and converted here to descending order for convenience</span></span><br><span class="line">pc      = pc(:,:,<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">eigvals = <span class="number">100</span>*eigvals(:,<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>)./sum(eigvals,<span class="number">2</span>); <span class="comment">% convert to percent change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">4</span> <span class="comment">% only first 4 are shown in the real figure</span></span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">    colormap jet</span><br><span class="line">    subplot(<span class="number">4</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    topoplot(double(pc(<span class="number">1</span>,:,<span class="built_in">i</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">    title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;, eigval=&#x27;</span> num2str(eigvals(<span class="number">1</span>,<span class="built_in">i</span>)) ])</span><br><span class="line">    subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="built_in">i</span>*<span class="number">2</span>)</span><br><span class="line">    topoplot(double(pc(<span class="number">2</span>,:,<span class="built_in">i</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">    title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;, eigval=&#x27;</span> num2str(eigvals(<span class="number">2</span>,<span class="built_in">i</span>)) ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="built_in">i</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">% PC time course for each trial, then average together</span></span><br><span class="line">    pctimes = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>,EEG.pnts);</span><br><span class="line">    <span class="keyword">for</span> triali=<span class="number">1</span>:EEG.trials</span><br><span class="line">        eeg = <span class="built_in">bsxfun</span>(@minus,<span class="built_in">squeeze</span>(EEG.data(:,:,triali)),<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(:,:,triali),<span class="number">2</span>)));</span><br><span class="line">        pctimes(<span class="number">1</span>,:,:) = <span class="built_in">squeeze</span>(pctimes(<span class="number">1</span>,:,:))&#x27; + <span class="built_in">squeeze</span>(pc(<span class="number">1</span>,:,<span class="built_in">i</span>))*eeg;</span><br><span class="line">        pctimes(<span class="number">2</span>,:,:) = <span class="built_in">squeeze</span>(pctimes(<span class="number">2</span>,:,:))&#x27; + <span class="built_in">squeeze</span>(pc(<span class="number">2</span>,:,<span class="built_in">i</span>))*eeg;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">squeeze</span>(pctimes(<span class="number">1</span>,:,:))./EEG.trials)</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">squeeze</span>(pctimes(<span class="number">2</span>,:,:))./EEG.trials)</span><br><span class="line">    set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1200</span>])</span><br><span class="line">    title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;, eigval=&#x27;</span> num2str(eigvals(<span class="built_in">i</span>)) ])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/20/NdLJIsl67hyezbi.png" alt="Ex_23(1)" style="zoom: 67%;" /></p><p><img src="https://s2.loli.net/2024/09/20/HXKNLgRt4pqzjvi.png" alt="Ex_23(1.2)"></p></li><li><p>Repeat this exercise but after bandpass filtering in two different frequency bands. Make sure there are no edge artifacts in the pretrial time window (consider using reflection, if necessary, as described in figure 7.3). Justify your decision of frequency bands and time window width(s). Comment on any qualitative similarities and differences you observe between frequency bands and time windows and similarities and differences between the frequencyband-specific and broadband signal from the results obtained in the previous exercise. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% perform Morlet wavelet, calculate power</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">frequencies = [<span class="number">15</span> <span class="number">30</span>];</span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">numcycles = [<span class="number">5</span> <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">half_wavelet  = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">n_wavelet = <span class="built_in">length</span>(time);</span><br><span class="line">n_data = <span class="number">3</span>*EEG.pnts;</span><br><span class="line">n_convolution = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi));</span><br><span class="line">    wavelet(fi,:) = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi).*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% filtered data</span></span><br><span class="line">convolution_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),EEG.nbchan,EEG.trials,EEG.pnts);</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform Morlet wavelet</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">    wavelet_fft = fft(wavelet(fi,:),n_convolution);</span><br><span class="line">    <span class="keyword">for</span> chani = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">        <span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">            data2filter = <span class="built_in">squeeze</span>(EEG.data(chani,:,triali));</span><br><span class="line">            data2filter = [<span class="built_in">fliplr</span>(data2filter) data2filter <span class="built_in">fliplr</span>(data2filter)];</span><br><span class="line">            data_fft = fft(data2filter,n_convolution);</span><br><span class="line">            </span><br><span class="line">            temp_result = ifft(wavelet_fft .* data_fft,n_convolution);</span><br><span class="line">            temp_result = temp_result(half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line"></span><br><span class="line">            convolution_result(fi,chani,triali,:) = <span class="built_in">real</span>(temp_result(<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span> : <span class="number">2</span>*<span class="keyword">end</span>/<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% calculate eigvals and pc</span></span><br><span class="line">timewindow = [<span class="number">-500</span>, <span class="number">0</span>; <span class="number">100</span>, <span class="number">600</span>];       <span class="comment">% in ms, 选取的timewindow</span></span><br><span class="line">timewindow_idx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(timewindow,<span class="number">1</span>)</span><br><span class="line">    [~,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">1</span>)));</span><br><span class="line">    [~,timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">2</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% timewindow的长度</span></span><br><span class="line">timewindow_length = timewindow_idx(<span class="number">1</span>,<span class="number">2</span>)-timewindow_idx(<span class="number">1</span>,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% compute covariance of ERP </span></span><br><span class="line">covar = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">pc = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">temp_eigvals = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">eigvals = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan);</span><br><span class="line"></span><br><span class="line"><span class="comment">% average single-trial covariances. 先对每一个试次计算协方差，最后平均</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(timewindow,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> triali=<span class="number">1</span>:EEG.trials</span><br><span class="line">            eeg = <span class="built_in">bsxfun</span>(@minus,<span class="built_in">squeeze</span>(convolution_result(fi,:,triali,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>):timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>))),<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(convolution_result(fi,:,triali,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>):timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>)),<span class="number">4</span>))&#x27;);</span><br><span class="line">            covar(fi,<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(covar(fi,<span class="built_in">i</span>,:,:)) + (eeg*eeg&#x27;)./(timewindow_length<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        covar(fi,<span class="built_in">i</span>,:,:) = covar(fi,<span class="built_in">i</span>,:,:)./triali;</span><br><span class="line">        <span class="comment">% principle components analysis via eigenvalue decomposition 计算特征值eigvals、特征向量pc</span></span><br><span class="line">        [pc(fi,<span class="built_in">i</span>,:,:),temp_eigvals(fi,<span class="built_in">i</span>,:,:)] = eig(<span class="built_in">squeeze</span>(covar(fi,<span class="built_in">i</span>,:,:)));</span><br><span class="line">        eigvals(fi,<span class="built_in">i</span>,:) = <span class="built_in">diag</span>(<span class="built_in">squeeze</span>(temp_eigvals(fi,<span class="built_in">i</span>,:,:)))&#x27;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">clear temp_eigvals</span><br><span class="line"></span><br><span class="line"><span class="comment">% components are listed in increasing order, and converted here to descending order for convenience</span></span><br><span class="line">pc      = pc(:,:,:,<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">eigvals = <span class="number">100</span>*eigvals(:,:,<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>)./sum(eigvals,<span class="number">3</span>); <span class="comment">% convert to percent change</span></span><br><span class="line"><span class="comment">%% </span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">4</span> <span class="comment">% only first 4 are shown in the real figure</span></span><br><span class="line">        <span class="built_in">figure</span>((fi<span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        a = sgtitle([<span class="string">&#x27;Frequency = &#x27;</span> num2str(frequencies(fi)) <span class="string">&#x27;Hz&#x27;</span>]);</span><br><span class="line">        a.FontSize = <span class="number">12</span>;</span><br><span class="line">        colormap jet</span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        topoplot(double(pc(fi,<span class="number">1</span>,:,<span class="built_in">i</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">        title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>) ], [<span class="string">&#x27;eigval=&#x27;</span> num2str(eigvals(<span class="number">1</span>,<span class="built_in">i</span>)) ])</span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="built_in">i</span>*<span class="number">2</span>)</span><br><span class="line">        topoplot(double(pc(fi,<span class="number">2</span>,:,<span class="built_in">i</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">        title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>)], [<span class="string">&#x27;eigval=&#x27;</span> num2str(eigvals(<span class="number">2</span>,<span class="built_in">i</span>)) ])</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">figure</span>(fi*<span class="number">2</span>)</span><br><span class="line">        sgtitle([<span class="string">&#x27;Frequency = &#x27;</span> num2str(frequencies(fi)) <span class="string">&#x27;Hz&#x27;</span>])</span><br><span class="line">        subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="built_in">i</span>)</span><br><span class="line">        <span class="comment">% PC time course for each trial, then average together</span></span><br><span class="line">        pctimes = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>,EEG.pnts);</span><br><span class="line">        <span class="keyword">for</span> triali=<span class="number">1</span>:EEG.trials</span><br><span class="line">            eeg = <span class="built_in">bsxfun</span>(@minus,<span class="built_in">squeeze</span>(convolution_result(fi,:,triali,:)),<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(convolution_result(fi,:,triali,:),<span class="number">4</span>))&#x27;);</span><br><span class="line">            pctimes(<span class="number">1</span>,:,:) = <span class="built_in">squeeze</span>(pctimes(<span class="number">1</span>,:,:))&#x27; + <span class="built_in">squeeze</span>(pc(fi,<span class="number">1</span>,:,<span class="built_in">i</span>))&#x27;*eeg;</span><br><span class="line">            pctimes(<span class="number">2</span>,:,:) = <span class="built_in">squeeze</span>(pctimes(<span class="number">2</span>,:,:))&#x27; + <span class="built_in">squeeze</span>(pc(fi,<span class="number">2</span>,:,<span class="built_in">i</span>))&#x27;*eeg;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">plot</span>(EEG.times,<span class="built_in">squeeze</span>(pctimes(<span class="number">1</span>,:,:)))</span><br><span class="line">        <span class="built_in">hold</span> on</span><br><span class="line">        <span class="built_in">plot</span>(EEG.times,<span class="built_in">squeeze</span>(pctimes(<span class="number">2</span>,:,:)))</span><br><span class="line">        set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1200</span>])</span><br><span class="line">        title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>)  ])</span><br><span class="line">        xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/23/VhqaPsYU2uKyjE5.png" alt="Ex_23(2.1)" style="zoom: 50%;" /></p><p><img src="https://s2.loli.net/2024/09/23/VtH1AECf8bPqegh.png" alt="Ex_23(2.2)" style="zoom: 50%;" /></p><p><img src="https://s2.loli.net/2024/09/23/lnPU2SOgCHZb3Jw.png" alt="Ex_23(2.3)" style="zoom: 50%;" /></p><p><img src="https://s2.loli.net/2024/09/23/MRHx9hgASXaz1JZ.png" alt="Ex_23(2.4)" style="zoom: 50%;" /></p></li></ol><hr><h1 id="Part-5"><a href="#Part-5" class="headerlink" title="Part 5"></a>Part 5</h1><h2 id="26-Phase-Based-Connectivity"><a href="#26-Phase-Based-Connectivity" class="headerlink" title="26 | Phase-Based Connectivity"></a>26 | Phase-Based Connectivity</h2><ol><li><p>Select <strong>one seed electrode</strong> and <strong>one frequency band</strong> and compute phase-based connectivity between that seed electrode and every other electrode. Use two methods for phase-based connectivity that were presented in this chapter, one that is volume conduction independent (e.g., PLI) and one that could produce spurious connectivity due to volume conduction (e.g., ISPC). Do not apply a baseline subtraction. Make topographical plots of seeded connectivity in a time window of your choice (e.g., 300 – 350 ms). What are the similarities and differences between results from the two methods, and what might be the reasons for the similarities and differences? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 26.1</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% Seed electrode</span></span><br><span class="line">channel = <span class="string">&#x27;p1&#x27;</span>;</span><br><span class="line">chanidx = <span class="built_in">find</span>(strcmpi(channel,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Select one frequency band</span></span><br><span class="line">frequency = <span class="number">5</span>;      <span class="comment">% in Hz</span></span><br><span class="line"><span class="comment">%% Perform Morlet wavelet </span></span><br><span class="line"><span class="comment">% wavelet and FFT parameters</span></span><br><span class="line">time          = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">half_wavelet  = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">numcycle = <span class="number">6</span>;</span><br><span class="line">n_wavelet     = <span class="built_in">length</span>(time);</span><br><span class="line">n_data        = EEG.pnts*EEG.trials;       </span><br><span class="line">n_convolution = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% create wavelet and take FFT</span></span><br><span class="line">s = numcycle/(<span class="number">2</span>*<span class="built_in">pi</span>*frequency);</span><br><span class="line">wavelet_fft = fft( <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*frequency.*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(s^<span class="number">2</span>))) ,n_convolution);</span><br><span class="line">    </span><br><span class="line">convolution_result = <span class="built_in">zeros</span>(EEG.nbchan,n_convolution);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data_fft = fft(<span class="built_in">reshape</span>(EEG.data(channi,:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line">    convolution_result(channi,:) = ifft(wavelet_fft .* data_fft, n_convolution);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convolution_result = convolution_result(:,half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line"></span><br><span class="line">signal = <span class="built_in">reshape</span>(convolution_result,EEG.nbchan,EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Compute ISPC-trial and Imaginary coherence</span></span><br><span class="line">ISPC_trial = <span class="built_in">zeros</span>(EEG.nbchan,EEG.pnts);</span><br><span class="line">Imag_Coher = <span class="built_in">zeros</span>(EEG.nbchan,EEG.pnts);</span><br><span class="line"></span><br><span class="line">phase1 = <span class="built_in">squeeze</span>(<span class="built_in">angle</span>(signal(chanidx,:,:)));</span><br><span class="line">spec1 = sum(<span class="built_in">squeeze</span>(signal(chanidx,:,:)).*<span class="built_in">conj</span>(<span class="built_in">squeeze</span>(signal(chanidx,:,:))),<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    phase2 = <span class="built_in">squeeze</span>(<span class="built_in">angle</span>(signal(channi,:,:)));</span><br><span class="line">    spec2 = sum(<span class="built_in">squeeze</span>(signal(channi,:,:)).*<span class="built_in">conj</span>(<span class="built_in">squeeze</span>(signal(channi,:,:))),<span class="number">2</span>); </span><br><span class="line">    specX = sum(<span class="built_in">squeeze</span>(signal(chanidx,:,:)).*<span class="built_in">conj</span>(<span class="built_in">squeeze</span>(signal(channi,:,:))),<span class="number">2</span>); </span><br><span class="line">    ISPC_trial(channi,:) = <span class="built_in">squeeze</span>(<span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*(phase1-phase2)),<span class="number">2</span>)));</span><br><span class="line">    Imag_Coher(channi,:) = <span class="built_in">abs</span>(<span class="built_in">imag</span>(specX./<span class="built_in">sqrt</span>(spec1.*spec2)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">timewindow = [<span class="number">300</span> <span class="number">350</span>];</span><br><span class="line">[~, timewindowidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="number">1</span>)));</span><br><span class="line">[~, timewindowidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">colormap jet</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">title(<span class="string">&#x27;ISPC-trials, no baseline correction&#x27;</span>)</span><br><span class="line">topoplot(<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(ISPC_trial(:,timewindowidx(<span class="number">1</span>):timewindowidx(<span class="number">2</span>)),<span class="number">2</span>)),EEG.chanlocs)</span><br><span class="line"><span class="comment">% set(gca,&#x27;CLim&#x27;,[0,0.8])</span></span><br><span class="line">colorbar</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">title(<span class="string">&#x27;Imaginary Coherence, no baseline correction&#x27;</span>)</span><br><span class="line">topoplot(<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(Imag_Coher(:,timewindowidx(<span class="number">1</span>):timewindowidx(<span class="number">2</span>)),<span class="number">2</span>)),EEG.chanlocs)</span><br><span class="line">set(gca,<span class="string">&#x27;CLim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>])</span><br><span class="line">colorbar</span><br></pre></td></tr></table></figure></li><li><p>Now apply a baseline subtraction to the results (you can choose the baseline time period). Are there any changes in the plots after baseline subtraction (note that the color scaling will be different after baseline subtraction), and how do results from the two analyses compare with each other after baseline subtraction? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% baseline</span></span><br><span class="line">baselinetm = [<span class="number">-400</span> <span class="number">-200</span>];</span><br><span class="line">baselineidx  = dsearchn(EEG.times&#x27;,baselinetm&#x27;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">repmat</span>(<span class="built_in">mean</span>(ISPC_trial(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">size</span>(ISPC_trial,<span class="number">2</span>));</span><br><span class="line">ISPC_baseline = ISPC_trial - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(ISPC_trial(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">size</span>(ISPC_trial,<span class="number">2</span>));</span><br><span class="line">Coher_baseline = Imag_Coher - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(Imag_Coher(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">size</span>(Imag_Coher,<span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">title(<span class="string">&#x27;ISPC-trials, baseline corrected&#x27;</span>)</span><br><span class="line">topoplot(<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(ISPC_baseline(:,timewindowidx(<span class="number">1</span>):timewindowidx(<span class="number">2</span>)),<span class="number">2</span>)),EEG.chanlocs)</span><br><span class="line"><span class="comment">% set(gca,&#x27;CLim&#x27;,[-0.1,0.1])</span></span><br><span class="line">colorbar</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">title(<span class="string">&#x27;Imaginary Coherence, baseline corrected&#x27;</span>)</span><br><span class="line">topoplot(<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(Coher_baseline(:,timewindowidx(<span class="number">1</span>):timewindowidx(<span class="number">2</span>)),<span class="number">2</span>)),EEG.chanlocs)</span><br><span class="line">set(gca,<span class="string">&#x27;CLim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>])</span><br><span class="line">colorbar</span><br></pre></td></tr></table></figure></li><li><p>From the results in exercise 1 above, pick one “ target ” electrode (any electrode other than the seed) and provide evidence, using additional data analyses if necessary, for or against that measure of phase-based connectivity between that electrode and the seed being driven by volume conduction. </p><ul><li>可以看出，对于可以排除volume conduction影响的相干性分析方法，如 Imaginary Coherence，baseline corrected前后的topographical map差异较小，而对于容易受volume conduction影响的分析方法，如ISPC-trial，baseline corrected前后有明显的差异。</li></ul><p><img src="https://s2.loli.net/2024/09/24/DTP2Q6nIdCpgWVm.png" alt="Ex_26" style="zoom:50%;" /></p></li></ol><hr><h2 id="27-Power-Based-Connectivity"><a href="#27-Power-Based-Connectivity" class="headerlink" title="27 | Power-Based Connectivity"></a>27 | Power-Based Connectivity</h2><ol><li><p>Perform a power correlation analysis over time. Pick two electrodes and use a sliding time segment of three cycles (1.5 cycles on either side of each center time point). Average the results over trials. Perform this analysis at three frequencies and plot the time series of correlation coefficients. Next, repeat the analysis twice, using fixed time-segment lengths of 150 ms and 900 ms. Do the results differ according to the time segment length and the frequency band, and how are they different? In what situations would it be beneficial to use each window width parameter, and in what situations might problems or limitations arise? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 27.1</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform time-frequency decomposition</span></span><br><span class="line"><span class="comment">% Select electrode</span></span><br><span class="line">channel1 = <span class="string">&#x27;Fz&#x27;</span>;</span><br><span class="line">channel2 = <span class="string">&#x27;O1&#x27;</span>;</span><br><span class="line">chanidx(<span class="number">1</span>) = <span class="built_in">find</span>(strcmpi(channel1,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line">chanidx(<span class="number">2</span>) = <span class="built_in">find</span>(strcmpi(channel2,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line"><span class="comment">% Select one frequency band</span></span><br><span class="line">frequencies = [<span class="number">5</span> <span class="number">10</span> <span class="number">15</span>];      <span class="comment">% in Hz</span></span><br><span class="line"><span class="comment">%% Perform Morlet wavelet </span></span><br><span class="line"><span class="comment">% wavelet and FFT parameters</span></span><br><span class="line">time          = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">half_wavelet  = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">numcycles = [<span class="number">5</span> <span class="number">7</span> <span class="number">9</span>];</span><br><span class="line">n_wavelet     = <span class="built_in">length</span>(time);</span><br><span class="line">n_data        = EEG.pnts*EEG.trials;       </span><br><span class="line">n_convolution = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">convolution_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">length</span>(chanidx),n_convolution);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line"><span class="comment">% create wavelet and take FFT</span></span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi));</span><br><span class="line">    wavelet_fft = fft( <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*frequencies(fi).*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(s^<span class="number">2</span>))) ,n_convolution);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> channi = <span class="number">1</span>:<span class="built_in">length</span>(chanidx)</span><br><span class="line">        data_fft = fft(<span class="built_in">reshape</span>(EEG.data(chanidx(channi),:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line">        convolution_result(fi,channi,:) = ifft(wavelet_fft .* data_fft, n_convolution);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">convolution_result = convolution_result(:,:,half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line">power = <span class="built_in">abs</span>(<span class="built_in">reshape</span>(convolution_result,<span class="built_in">length</span>(frequencies),<span class="built_in">length</span>(chanidx),EEG.pnts,EEG.trials)).^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Perform a power correlation over time, using a sliding time segment of three cycles</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">10</span>:<span class="number">800</span>;</span><br><span class="line">timewindow_1 = <span class="number">3</span>*<span class="number">500</span> ./ frequencies;       <span class="comment">% (in ms) half of three cycle</span></span><br><span class="line">timewindow_2 = <span class="number">150</span>/<span class="number">2</span>;       <span class="comment">% in ms</span></span><br><span class="line">timewindow_3 = <span class="number">900</span>/<span class="number">2</span>;       <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line">times2saveidx = dsearchn(EEG.times&#x27;,times2save&#x27;);</span><br><span class="line">timewindowidx_1 = <span class="built_in">round</span>(timewindow_1/<span class="number">1000</span> * EEG.srate);</span><br><span class="line">timewindowidx_2 = <span class="built_in">round</span>(timewindow_2/<span class="number">1000</span> * EEG.srate);</span><br><span class="line">timewindowidx_3 = <span class="built_in">round</span>(timewindow_3/<span class="number">1000</span> * EEG.srate);</span><br><span class="line"></span><br><span class="line">Corr_3cycle = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies), <span class="built_in">length</span>(times2saveidx));</span><br><span class="line">Corr_150ms = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies), <span class="built_in">length</span>(times2saveidx));</span><br><span class="line">Corr_900ms = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies), <span class="built_in">length</span>(times2saveidx));</span><br><span class="line"><span class="comment">% perform correlation</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">   <span class="keyword">for</span> ti = <span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">       <span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">           <span class="comment">% a sliding time segment of 3 cycles</span></span><br><span class="line">            signal_1 = <span class="built_in">squeeze</span>(power(fi,<span class="number">1</span>,times2saveidx(ti)-timewindowidx_1(fi):times2saveidx(ti)+timewindowidx_1(fi),triali));</span><br><span class="line">            signal_2 = <span class="built_in">squeeze</span>(power(fi,<span class="number">2</span>,times2saveidx(ti)-timewindowidx_1(fi):times2saveidx(ti)+timewindowidx_1(fi),triali));</span><br><span class="line">            signal_1 = signal_1 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_1),<span class="built_in">size</span>(signal_1));</span><br><span class="line">            signal_2 = signal_2 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_2),<span class="built_in">size</span>(signal_2));</span><br><span class="line">            </span><br><span class="line">            Corr_3cycle(fi,ti) = Corr_3cycle(fi,ti) + signal_1&#x27; * signal_2 ./ <span class="built_in">sqrt</span>((signal_1&#x27;*signal_1) * (signal_2&#x27;*signal_2));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% fixed time segment of 150 ms</span></span><br><span class="line">            signal_1 = <span class="built_in">squeeze</span>(power(fi,<span class="number">1</span>,times2saveidx(ti)-timewindowidx_2:times2saveidx(ti)+timewindowidx_2,triali));</span><br><span class="line">            signal_2 = <span class="built_in">squeeze</span>(power(fi,<span class="number">2</span>,times2saveidx(ti)-timewindowidx_2:times2saveidx(ti)+timewindowidx_2,triali));</span><br><span class="line">            signal_1 = signal_1 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_1),<span class="built_in">size</span>(signal_1));</span><br><span class="line">            signal_2 = signal_2 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_2),<span class="built_in">size</span>(signal_2));</span><br><span class="line">            </span><br><span class="line">            Corr_150ms(fi,ti) = Corr_150ms(fi,ti) + signal_1&#x27; * signal_2 ./ <span class="built_in">sqrt</span>((signal_1&#x27;*signal_1) * (signal_2&#x27;*signal_2));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% fixed time segment of 900ms</span></span><br><span class="line">            signal_1 = <span class="built_in">squeeze</span>(power(fi,<span class="number">1</span>,times2saveidx(ti)-timewindowidx_3:times2saveidx(ti)+timewindowidx_3,triali));</span><br><span class="line">            signal_2 = <span class="built_in">squeeze</span>(power(fi,<span class="number">2</span>,times2saveidx(ti)-timewindowidx_3:times2saveidx(ti)+timewindowidx_3,triali));</span><br><span class="line">            signal_1 = signal_1 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_1),<span class="built_in">size</span>(signal_1));</span><br><span class="line">            signal_2 = signal_2 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_2),<span class="built_in">size</span>(signal_2));</span><br><span class="line">            </span><br><span class="line">            Corr_900ms(fi,ti) = Corr_900ms(fi,ti) + signal_1&#x27; * signal_2 ./ <span class="built_in">sqrt</span>((signal_1&#x27;*signal_1) * (signal_2&#x27;*signal_2));</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Corr_3cycle = Corr_3cycle ./ EEG.trials;</span><br><span class="line">Corr_150ms = Corr_150ms ./ EEG.trials;</span><br><span class="line">Corr_900ms= Corr_900ms ./ EEG.trials;</span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">1</span>,fi)</span><br><span class="line">    <span class="built_in">plot</span>(times2save, <span class="built_in">squeeze</span>(Corr_3cycle(fi,:)),<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save, <span class="built_in">squeeze</span>(Corr_150ms(fi,:)),<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save, <span class="built_in">squeeze</span>(Corr_900ms(fi,:)),<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.8</span> <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    set(gca,<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>],<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-300</span>,<span class="number">800</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Correlation Coefficient&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Correlation between &#x27;</span> num2str(channel1) <span class="string">&#x27; and &#x27;</span> num2str(channel2) <span class="string">&#x27; at &#x27;</span> num2str(frequencies(fi)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;3 cycle&#x27;</span>,<span class="string">&#x27;150 ms&#x27;</span>,<span class="string">&#x27;900 ms&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/24/uXHri9PIn56ca7m.png" alt="Ex_27_1" style="zoom: 50%;" /></p><ul><li>从直观的角度，由于900ms的 timewindow比较长，所得出的结果也就较为平滑，而150ms timewindow下的correlation曲线波动明显更大。对于可变的3-Cycles timewindow，曲线的波动程度介于两者之间。在5Hz下，这种差异尤为明显，因为5Hz对应的周期更长，所需的timewindow（通常至少为3个周期）也就更长。</li></ul></li><li><p>Select two “ seed ” time-frequency-electrode windows and perform an exploratory power correlation <strong>over trials</strong> at one selected “ target ” electrode, as in figure 27.6C (plate 19) . Show the results in separate plots, and then show a time-frequency plot of correlation coefficient differences between the two seeds (Fisher- <em>Z</em> transform the coefficients before subtraction). Are there any striking qualitative differences between the two plots, and did plotting the difference map make the differences easier or more difficult to interpret? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex.27_2</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line">targetSensor = <span class="string">&#x27;C4&#x27;</span>;</span><br><span class="line">seedSensor1 = <span class="string">&#x27;Fz&#x27;</span>;</span><br><span class="line">seedSensor2 = <span class="string">&#x27;O1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">target_idx = <span class="built_in">find</span>(strcmpi(targetSensor,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line">seed_idx(<span class="number">1</span>) = <span class="built_in">find</span>(strcmpi(seedSensor1,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line">seed_idx(<span class="number">2</span>) = <span class="built_in">find</span>(strcmpi(seedSensor2,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Perform Morlet wavelet on seed electrodes</span></span><br><span class="line"><span class="comment">% wavelet and FFT parameters</span></span><br><span class="line">seed_frex     = <span class="number">6</span>;      <span class="comment">% 选取的seed frequency</span></span><br><span class="line">time          = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">half_wavelet  = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">seed_numcycles     = <span class="number">4</span>;</span><br><span class="line">n_wavelet     = <span class="built_in">length</span>(time);</span><br><span class="line">n_data        = EEG.pnts*EEG.trials;</span><br><span class="line">n_convolution = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">convolution_result_seed = <span class="built_in">zeros</span>(<span class="built_in">length</span>(seed_idx),n_convolution);</span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:<span class="built_in">length</span>(seed_idx)</span><br><span class="line">    <span class="comment">% create wavelet and take FFT</span></span><br><span class="line">    s = seed_numcycles/(<span class="number">2</span>*<span class="built_in">pi</span>*seed_frex);</span><br><span class="line">    wavelet_fft = fft( <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*seed_frex.*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(s^<span class="number">2</span>))) ,n_convolution);</span><br><span class="line"></span><br><span class="line">    data_fft = fft(<span class="built_in">reshape</span>(EEG.data(seed_idx(channi),:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line">    convolution_result_seed(channi,:) = ifft(wavelet_fft .* data_fft, n_convolution) * <span class="built_in">sqrt</span>(s);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convolution_result_seed = convolution_result_seed(:,half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line">seed_tf = <span class="built_in">abs</span>(<span class="built_in">reshape</span>(convolution_result_seed,<span class="built_in">length</span>(seed_idx),EEG.pnts,EEG.trials)).^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Perform Morlet wavelet on target electrode</span></span><br><span class="line">target_frex      = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">2</span>),<span class="built_in">log10</span>(<span class="number">40</span>),<span class="number">20</span>);</span><br><span class="line">time             = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">half_wavelet     = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">target_numcycles = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">10</span>),<span class="number">20</span>);</span><br><span class="line">n_wavelet        = <span class="built_in">length</span>(time);</span><br><span class="line">n_data           = EEG.pnts*EEG.trials;</span><br><span class="line">n_convolution    = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">convolution_result_target = <span class="built_in">zeros</span>(<span class="built_in">length</span>(target_frex),n_convolution);</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(target_frex)</span><br><span class="line">    <span class="comment">% create wavelet and take FFT</span></span><br><span class="line">    s = target_numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*target_frex(fi));</span><br><span class="line">    wavelet_fft = fft( <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*target_frex(fi).*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(s^<span class="number">2</span>))) ,n_convolution);</span><br><span class="line"></span><br><span class="line">    data_fft = fft(<span class="built_in">reshape</span>(EEG.data(target_idx,:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line">    convolution_result_target(fi,:) = ifft(wavelet_fft .* data_fft, n_convolution) * <span class="built_in">sqrt</span>(s);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convolution_result_target = convolution_result_target(:,half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line">target_tf = <span class="built_in">abs</span>(<span class="built_in">reshape</span>(convolution_result_target,<span class="built_in">length</span>(target_frex),EEG.pnts,EEG.trials)).^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 计算seed electrode在所选取的timewindow内每一个trial的平均power，得到一个长EEG.trials的向量</span></span><br><span class="line">timewindow_seed = [<span class="number">100</span> <span class="number">300</span>];        <span class="comment">% 选取的seed time window</span></span><br><span class="line">timewindow_idx_seed = dsearchn(EEG.times&#x27;,timewindow_seed&#x27;);</span><br><span class="line">power_seed(<span class="number">1</span>,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(seed_tf(<span class="number">1</span>,timewindow_idx_seed(<span class="number">1</span>):timewindow_idx_seed(<span class="number">2</span>),:),<span class="number">2</span>));</span><br><span class="line">power_seed(<span class="number">2</span>,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(seed_tf(<span class="number">2</span>,timewindow_idx_seed(<span class="number">1</span>):timewindow_idx_seed(<span class="number">2</span>),:),<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对target electrode下的每一个时间点，计算所有trials的power值与power_seed的correlation</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">10</span>:<span class="number">800</span>;</span><br><span class="line">times2save_idx = dsearchn(EEG.times&#x27;,times2save&#x27;);</span><br><span class="line"></span><br><span class="line">Corr_trial = <span class="built_in">zeros</span>(<span class="built_in">length</span>(target_idx),<span class="built_in">length</span>(times2save),<span class="built_in">length</span>(target_frex));</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> seedi = <span class="number">1</span>:<span class="built_in">length</span>(seed_idx)</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(target_frex)</span><br><span class="line">        <span class="keyword">for</span> ti = <span class="number">1</span>:<span class="built_in">length</span>(times2save_idx)</span><br><span class="line">            power_target = <span class="built_in">squeeze</span>(target_tf(fi,times2save_idx(ti),:));</span><br><span class="line">            Corr_trial(seedi,ti,fi) = corr(power_seed(seedi,:)&#x27;,power_target,<span class="string">&#x27;type&#x27;</span>,<span class="string">&#x27;Spearman&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% Fisher-Z</span></span><br><span class="line">    Corr_trial = <span class="number">0.5</span> .* <span class="built_in">log</span>((<span class="number">1</span>+Corr_trial) ./ (<span class="number">1</span>-Corr_trial));</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,seedi)</span><br><span class="line">    contourf(times2save,target_frex,<span class="built_in">squeeze</span>(Corr_trial(seedi,:,:))&#x27;,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>],<span class="string">&#x27;yscale&#x27;</span>,<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="built_in">round</span>(<span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">2</span>),<span class="built_in">log10</span>(<span class="number">40</span>),<span class="number">6</span>)))</span><br><span class="line">    xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">contourf(times2save,target_frex,<span class="built_in">squeeze</span>(Corr_trial(<span class="number">1</span>,:,:))&#x27;-<span class="built_in">squeeze</span>(Corr_trial(<span class="number">2</span>,:,:))&#x27;,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>],<span class="string">&#x27;yscale&#x27;</span>,<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="built_in">round</span>(<span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">2</span>),<span class="built_in">log10</span>(<span class="number">40</span>),<span class="number">6</span>)))</span><br><span class="line">xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">axis off</span><br><span class="line">cb = colorbar;</span><br><span class="line">set(cb, <span class="string">&#x27;Ticks&#x27;</span>, [<span class="number">-0.2</span>, <span class="number">-0.1</span>, <span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.2</span>], <span class="string">&#x27;TickLabels&#x27;</span>, &#123;<span class="string">&#x27;-0.2&#x27;</span>, <span class="string">&#x27;-0.1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>&#125;);</span><br><span class="line">clim([<span class="number">-0.2</span> <span class="number">0.2</span>])</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/24/3rT9EtFOqDHcMZ1.png" alt="Ex_27_2" style="zoom: 50%;" /></p></li></ol><hr><h2 id="28-Granger-Prediction"><a href="#28-Granger-Prediction" class="headerlink" title="28 | Granger Prediction"></a>28 | Granger Prediction</h2><ol><li><p>How would you interpret panels A and C versus B and D in figure 28.8 (plate 21) ? Discuss advantages and disadvantages of baseline-normalized Granger prediction results for a study investigating the role of visual attention in healthy university students and in a study comparing visual attention in children with ADHD versus typically developing controls. </p><p><img src="https://s2.loli.net/2024/09/25/xvAqrZ4LGNEP26M.png" alt="image-20240925083902807"></p></li><li><p>Pick <strong>one electrode</strong> and <strong>one time segment</strong> and compute <strong>Granger prediction</strong> between that electrode (the “ seed ” ) and <strong>all other electrodes</strong> in <strong>that time segment</strong>. Before selecting a time segment, examine the ERP from that electrode and choose a time window that, based on the ERP, is likely to contain stationary data. Justify your selection of time segment and model order. Show the results in a topographical map and comment on any striking or salient features you observe. </p></li><li><p>From the electrode and time segment used above, recompute Granger prediction separately for the first 40 trials and the last 40 trials. Make topographical maps of the early and late experiment effects and their difference. Are there any notable topographical features that can be seen in the difference topographical map? If so, how would you interpret these effects if they were statistically significant (there is no need to perform statistics; base your answer on qualitative visual inspection)? </p></li></ol><hr><h2 id="29-Mutual-Information"><a href="#29-Mutual-Information" class="headerlink" title="29 | Mutual Information"></a>29 | Mutual Information</h2><ol><li>Pick two electrodes and two frequencies (one frequency per electrode) and compute mutual information over time and trials between power from the first electrode and phase from the second electrode. Justify your choice of bin size. Next, recompute mutual information using phase from the first electrode and power from the second electrode. Make sure you use the same bin size you used in the previous analysis, so the results are directly comparable. Plot the time courses of the mutual information from these two analyses. Do you notice any striking features in the results, and are there differences between using phase and power from the two different electrodes? </li></ol><ol><li>Pick one electrode and two frequency bands. Compute mutual information between phase in that electrode and power in all other electrodes, separately in those two frequency bands. Run this analysis for a prestimulus period (e.g., – 500 to – 100 ms) and a task-related period (e.g., +100 to +500 ms). Show topographical maps for each frequency band, the two time periods, and additionally for mutual information during the task period minus the baseline period. Comment on any topographically salient features and any differences between baseline and task periods. </li></ol><hr><h2 id="30"><a href="#30" class="headerlink" title="30 |"></a>30 |</h2><hr><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ol><li><p>把以ms为单位的时间转化为时间的索引index可以用<code>dsearchn</code>函数：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% convert requested times to indices</span></span><br><span class="line">times2saveidx = dsearchn(EEG.times&#x27;,times2save&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>把数据翻转后拼接在前后段，以减少artifacts，可以用<code>fliplr</code>或<code>flipud</code>实现：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">data2filter = [<span class="built_in">fliplr</span>(data2filter) data2filter <span class="built_in">fliplr</span>(data2filter)];</span><br><span class="line"></span><br><span class="line">filtered_result = filtered(<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span> : <span class="number">2</span>*<span class="keyword">end</span>/<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Neural </category>
          
          <category> Analyzing Neural Time Series Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
            <tag> Neural </tag>
            
            <tag> 数字信号处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记 | Analyzing Neural Time Series Data</title>
      <link href="/post/751f48aa.html"/>
      <url>/post/751f48aa.html</url>
      
        <content type="html"><![CDATA[<h1 id="2-D-topographical-ocations-of-EEG-electrodes"><a href="#2-D-topographical-ocations-of-EEG-electrodes" class="headerlink" title="2-D topographical ocations of EEG electrodes"></a>2-D topographical ocations of EEG electrodes</h1><ul><li>64  electrodes</li></ul><p><img src="https://s2.loli.net/2024/09/29/OcaVRBxHXpkID6W.png" alt="image-20240814152033522" style="zoom:60%;" /> </p><hr><h1 id="Brain-rhythm-frequency-bands"><a href="#Brain-rhythm-frequency-bands" class="headerlink" title="Brain rhythm frequency bands"></a>Brain rhythm frequency bands</h1><blockquote><p>delta (2(0.5)-4 Hz)</p><p>theta (4-8 Hz)</p><p>alpha (8-12 Hz)</p><p>beta (15-30 Hz)</p><p>lower gamma (30-80 Hz)</p><p>upper gamma (80-150 Hz)</p><p>subdelta and omega (up to 600 Hz)</p></blockquote><hr><h1 id="Intra-and-Intertrial-Timing"><a href="#Intra-and-Intertrial-Timing" class="headerlink" title="Intra- and Intertrial Timing"></a>Intra- and Intertrial Timing</h1><ul><li><strong>*Intra</strong>trial*：单个trail内。</li><li><strong>*Inter</strong>tial*: 不同trial之间。the duration of time between the end of one trial and the start of the next trial</li></ul><hr><h1 id="Phase-Locked-and-Nonphase-Locked"><a href="#Phase-Locked-and-Nonphase-Locked" class="headerlink" title="Phase-Locked and Nonphase-Locked"></a>Phase-Locked and Nonphase-Locked</h1><hr><h1 id="7-数据预处理"><a href="#7-数据预处理" class="headerlink" title="7 | 数据预处理"></a>7 | 数据预处理</h1><h2 id="The-Balance-between-Signal-and-Noise-信号与噪声的取舍平衡"><a href="#The-Balance-between-Signal-and-Noise-信号与噪声的取舍平衡" class="headerlink" title="The Balance between Signal and Noise | 信号与噪声的取舍平衡"></a>The Balance between Signal and Noise | 信号与噪声的取舍平衡</h2><p>保留更多的信号通常也意味着保留更多的噪声。</p><p>某些数据是信号还是噪声取决于实验的目的。</p><hr><h2 id="Creating-Epochs"><a href="#Creating-Epochs" class="headerlink" title="Creating Epochs"></a>Creating Epochs</h2><p>提取epoch的过程可以认为是将一段完整的数据划分成不同的小段</p><h4 id="1-如何选择“time-0”的时刻"><a href="#1-如何选择“time-0”的时刻" class="headerlink" title="1. 如何选择“time=0”的时刻"></a>1. 如何选择“time=0”的时刻</h4><ul><li>对于大多数实验，选择刺激开始的时刻作为time=0</li><li>对于其他情况，如有多个刺激时，可选择第一个刺激或最关键的刺激开始的时刻作为time=0</li><li>time-lock（time=0时刻的选择）是可以根据需要调节变化的</li></ul><h4 id="2-time-0前后需要包含多长时间"><a href="#2-time-0前后需要包含多长时间" class="headerlink" title="2. time=0前后需要包含多长时间"></a>2. time=0前后需要包含多长时间</h4><p>对于<strong>ERPs</strong>分析，划分的小段只需要包含你<strong>想要分析的时间段加上baseline</strong>，例如相对于0时刻的-200ms到800ms。</p><p>对于<strong>时频分析</strong>，需要划分<strong>更长</strong>的时间段，以避免<strong>边缘伪影（edge artifacts）</strong>，即需要<strong>预留足够长的缓冲区，使边缘伪影消退</strong>。此外，提取的频带越小，需要预留的缓冲区也应该越长。在时频功率谱中，边缘伪影很容易识别，因此可以先试分析一组数据再确定需要预留的缓冲区长度。通常情况下，将缓冲区长度设置为所分析的最低频率所对应的三个周期就足够了（例如，对2Hz的频率，设置缓冲区为1500ms）。</p><p>如果划分的epoch不够长，可以使用“reflection”的方法，即将这一段数据关于开始和结尾时刻首尾对称一下，再拼接到数据前和数据后，这样就可以得到三倍长的epoch。</p><p><img src="https://s2.loli.net/2024/09/29/xorJd2qVzkguWZL.png" alt="image-20240812153014767"></p><hr><h2 id="Matching-Trial-Count-across-Conditions-Trial数量的设置与平衡"><a href="#Matching-Trial-Count-across-Conditions-Trial数量的设置与平衡" class="headerlink" title="Matching Trial Count across Conditions | Trial数量的设置与平衡"></a>Matching Trial Count across Conditions | Trial数量的设置与平衡</h2><h4 id="1-不同的实验条件尽量设置相同的trial数："><a href="#1-不同的实验条件尽量设置相同的trial数：" class="headerlink" title="1. 不同的实验条件尽量设置相同的trial数："></a><strong>1. 不同的实验条件尽量设置相同的trial数：</strong></h4><p>理想情况下，所有条件（例如实验设计中的不同实验条件或组别）应该有相同数量的试验。这样可以确保分析结果的公平性和可比性。</p><h4 id="2-trial数量对不同分析的影响："><a href="#2-trial数量对不同分析的影响：" class="headerlink" title="2. trial数量对不同分析的影响："></a><strong>2. trial数量对不同分析的影响</strong>：</h4><ul><li><p><strong>基于相位的分析</strong>：相位分析对试验数量特别敏感。如果trial数量较少，结果中会出现正偏差（positive bias），即trial数量少的实验条件可能显示出更大的结果。这是因为相位分析对于小样本量更容易受到随机波动的影响，导致条件间结果的偏差。</p></li><li><p><strong>基于功率的分析</strong>：功率分析也可能出现一些正偏差。因为功率值通常是正值，数据中的噪声更倾向于增加功率值，所以较少的试验数量可能导致功率结果偏高。</p></li></ul><h4 id="3-应对低trial数量的方法："><a href="#3-应对低trial数量的方法：" class="headerlink" title="3. 应对低trial数量的方法："></a><strong>3. 应对低trial数量的方法</strong>：</h4><p>对于ERP分析，如果试验数量较少，与其依赖峰值时间（peak times）的分析，不如取一段时间范围内的平均幅值（mean amplitude）。这种方法对噪声更为稳健，不容易受到个别异常值的影响。</p><h4 id="4-应对不同实验条件的trial数量不一致的方法："><a href="#4-应对不同实验条件的trial数量不一致的方法：" class="headerlink" title="4. 应对不同实验条件的trial数量不一致的方法："></a><strong>4. 应对不同实验条件的trial数量不一致的方法</strong>：</h4><p>如果出现不同的实验条件下的trial数目不一致，假设最小的trial数为N，那么可以通过以下方法来平衡trial数：</p><ul><li>（不建议采用）直接选前N个trial</li><li>随机选N个trial</li><li>根据一些相关的行为或实验变量，如反应时间等，有目的地选N个trial</li></ul><hr><h2 id="Trial-Rejection"><a href="#Trial-Rejection" class="headerlink" title="Trial Rejection"></a>Trial Rejection</h2><hr><h1 id="9-Overview-of-Time-Domain-EEG-Analyses"><a href="#9-Overview-of-Time-Domain-EEG-Analyses" class="headerlink" title="9 | Overview of Time-Domain EEG Analyses"></a>9 | Overview of Time-Domain EEG Analyses</h1><h2 id="Event-Related-Potentials-ERPs"><a href="#Event-Related-Potentials-ERPs" class="headerlink" title="Event-Related Potentials (ERPs)"></a>Event-Related Potentials (ERPs)</h2><p>To create ERPs, simply align the time-domain EEG to the time=0 event (this was probably already done during preprocessing) and <strong>average across trials</strong> at each time point.</p><ul><li>指定 time points</li><li>trial average</li></ul><hr><h2 id="Butterfly-Plots"><a href="#Butterfly-Plots" class="headerlink" title="Butterfly Plots"></a>Butterfly Plots</h2><p>A butterfly ploy shows <strong>the ERP from all electrodes</strong> overlaid in the same figure.</p><hr><h2 id="Global-Field-Power-Topographical-Variance-Plots"><a href="#Global-Field-Power-Topographical-Variance-Plots" class="headerlink" title="Global Field Power / Topographical Variance Plots"></a>Global Field Power / Topographical Variance Plots</h2><p>The global field power is <strong>the standard deviation</strong> of activity over <strong>all electrodes</strong>.</p><hr><h2 id="The-Flicker-Effect"><a href="#The-Flicker-Effect" class="headerlink" title="The Flicker Effect"></a>The Flicker Effect</h2><p>The flicker effect in EEG research refers to entrainment of brain activity to a rhythmic extrinsic driving factor. This effect is also referred to as steady-state evoked potential, frequency tagging, SSVEP (steady-state visual evoked potential), SSAEP (auditory evoked potential), or something similar. </p><p>The flicker effect is arguably an underutilized tool in cognitive electrophysiology. The main benefit of the flicker effect is that it allows you to <strong>“ tag ” the processing of a specific stimulus</strong>.</p><p><strong>(from ChatGPT)</strong></p><p>假设你正在进行一项视觉注意力的研究，目的是研究大脑如何同时处理多个视觉刺激。你在屏幕上呈现两个物体：一个物体以12 Hz的频率闪烁（即每秒闪烁12次），另一个物体以15 Hz的频率闪烁。你让参与者专注于两个物体之一，然后使用EEG记录他们的大脑活动。</p><p>在这种情况下，闪烁效应会导致大脑中处理视觉信息的区域（通常是视觉皮层）出现与这两个频率相对应的节律性活动。12 Hz的物体会在大脑中产生12 Hz的节律性活动，15 Hz的物体会产生15 Hz的节律性活动。通过分析EEG数据中的频率成分，你可以识别出大脑中对应这两个不同频率的活动区域。</p><p>即使EEG无法像功能性磁共振成像（fMRI）那样精确地显示大脑中具体的活动区域，你仍然可以通过这些频率标记来“分离”出大脑中对12 Hz和15 Hz刺激分别作出反应的神经元群体。换句话说，虽然EEG的空间分辨率较低，但通过闪烁效应，你可以“假设”出对不同刺激反应的特定神经区域。</p><p><strong>具体的例子说明</strong>：</p><ul><li><p><strong>12 Hz闪烁的物体</strong>：如果参与者主要关注这个物体，你会看到EEG数据中12 Hz频率的功率增加，这表明视觉皮层中的某个区域在处理这个物体。</p></li><li><p><strong>15 Hz闪烁的物体</strong>：如果参与者关注这个物体，EEG数据中15 Hz频率的功率会增加，显示另一个区域在处理这个物体。</p></li></ul><p>通过这种方法，即使两个物体在大脑中产生的活动区域相距较近，由于频率不同，你依然能够区分开来。这就相当于“模拟”出了一种高空间分辨率，使得你可以推断大脑中不同区域对不同刺激的反应。</p><hr><h2 id="Topographical-Maps"><a href="#Topographical-Maps" class="headerlink" title="Topographical Maps"></a>Topographical Maps</h2><p>Creating a topographical map is conceptually similar to interpolating an electrode, except that instead of estimating the activity at one point in space corresponding to a missing electrode, activity is estimated at many point in space between electrodes.</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">topoplot()</span><br></pre></td></tr></table></figure><hr><h2 id="Microstates"><a href="#Microstates" class="headerlink" title="Microstates"></a>Microstates</h2><p>In EEG as well as ERP map series, for brief, subsecond time periods, map landscapes typically remain quasi-stable, then change very quickly into different landscapes.</p><p>Durations tend to be around the <strong>alpha range (70-130 ms)</strong>, and topographical distributions tend to fit into <strong>four or five distinct patterns</strong>.</p><hr><h2 id="ERP-Images"><a href="#ERP-Images" class="headerlink" title="ERP Images"></a>ERP Images</h2><p>An ERP image is a 2-D representation of the EEG data from <strong>a single electrode</strong>. Rather than all trials averaged together to form an ERP, the <strong>single-trial</strong> EEG traces are stacked vertically and then color coded to show changes in amplitude as changes in color. </p><hr><h1 id="10-amp-11-卷积、傅里叶变换"><a href="#10-amp-11-卷积、傅里叶变换" class="headerlink" title="10&amp;11 | 卷积、傅里叶变换"></a>10&amp;11 | 卷积、傅里叶变换</h1><p>一段关于<strong>卷积</strong>、<strong>离散傅里叶变换（DFT）</strong>和快速傅里叶变换（FFT）的视频：</p><p><a href="https://www.bilibili.com/video/BV1Vd4y1e7pj/?t=0.8&amp;vd_source=e7f03c857e620b80dcde0db3e7f51d26">【官方双语】那么……什么是卷积？</a></p><h2 id="Supplementary-Code-for-Figure-11-5"><a href="#Supplementary-Code-for-Figure-11-5" class="headerlink" title="Supplementary Code for Figure 11.5"></a>Supplementary Code for Figure 11.5</h2><p>对于书中所提供的图11.5对应代码的一些细节注释</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Figure 11.5</span></span><br><span class="line"></span><br><span class="line">N       = <span class="number">10</span>;         <span class="comment">% length of sequence  长度为10的向量</span></span><br><span class="line">data    = <span class="built_in">randn</span>(<span class="number">1</span>,N); <span class="comment">% random numbers</span></span><br><span class="line">srate   = <span class="number">200</span>;        <span class="comment">% sampling rate in Hz 采样率200Hz</span></span><br><span class="line">nyquist = srate/<span class="number">2</span>;    <span class="comment">% Nyquist frequency -- the highest frequency you can measure in the data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize Fourier output matrix</span></span><br><span class="line">fourier = <span class="built_in">zeros</span>(<span class="built_in">size</span>(data)); </span><br><span class="line"></span><br><span class="line"><span class="comment">% These are the actual frequencies in Hz that will be returned by the</span></span><br><span class="line"><span class="comment">% Fourier transform. The number of unique frequencies we can measure is</span></span><br><span class="line"><span class="comment">% exactly 1/2 of the number of data points in the time series (plus DC). </span></span><br><span class="line"><span class="comment">% 一个长度为 N 的信号需要 N 个正交基（frequency）才能完全表示</span></span><br><span class="line"><span class="comment">% 但在这里只保留了N/2+1个frequencies，是因为对于实数值信号，负频率与正频率对应的幅值、相位信息是对称的</span></span><br><span class="line"><span class="comment">% 所以舍去了N/2个负频率</span></span><br><span class="line">frequencies = <span class="built_in">linspace</span>(<span class="number">0</span>,nyquist,N/<span class="number">2</span>+<span class="number">1</span>);   <span class="comment">% 生成的频率从 0 到 100 Hz，共有 N/2 + 1 个点，间隔为srate/N</span></span><br><span class="line">time = ((<span class="number">1</span>:N)<span class="number">-1</span>)/N;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Fourier transform is dot-product between sine wave and data at each frequency</span></span><br><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:N      </span><br><span class="line">    <span class="comment">% fi（归一化频率，index，无单位）有N个取值，与frequencies（物理频率，Hz）为线性映射关系</span></span><br><span class="line">    <span class="comment">% 所以使用这两种频率DFT后的结果一致（幅值、相位相等）</span></span><br><span class="line">    sine_wave   = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time);</span><br><span class="line">    fourier(fi) = sum(sine_wave.*data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fourier=fourier/N;  <span class="comment">% 归一化，使得振幅具有实际意义，并保证能量的一致性</span></span><br></pre></td></tr></table></figure><h2 id="The-Fast-Fourier-Transform-FFT"><a href="#The-Fast-Fourier-Transform-FFT" class="headerlink" title="The Fast Fourier Transform | FFT"></a>The Fast Fourier Transform | FFT</h2><p>如何将 fft 函数的输出与实际的频率和幅值对应起来：</p><ul><li>采样率：$F_s$     采样点数：$N$</li><li>FFT后向量中某点索引：$n$<ul><li>该点频率：$f_n=(n-1)\cdot F_s/N$ </li><li>该点幅值：$abs(Result_{FFT})/(N/2)$</li></ul></li></ul><hr><h1 id="12-小波-Wavelet"><a href="#12-小波-Wavelet" class="headerlink" title="12 | 小波 Wavelet"></a>12 | 小波 Wavelet</h1><h2 id="How-to-Wake-Wavelets-小波的创造"><a href="#How-to-Wake-Wavelets-小波的创造" class="headerlink" title="How to Wake Wavelets | 小波的创造"></a>How to Wake Wavelets | 小波的创造</h2><p>不同于使用傅里叶变换进行的分析，使用小波变换时小波的频率和数目可以自行选择。一组具有相同性质但频率不同的<strong>小波</strong>叫作<strong>小波族</strong>，构造一组小波族有如下限制：</p><ol><li><strong>不能用比你划分的时间小段（epochs）更慢的频率。</strong>例如，你有一段1s长的数据，那么你不能分析低于1Hz的活动，应该让这1s中包含多个活动周期，建议使用4Hz或更快的小波。</li><li><p><strong>小波的频率不能高于奈奎斯特频率（采样率的一半）</strong></p></li><li><p>选择相近的频率所获得的结果会很相近（例如15.0Hz和14.9Hz），且越密集的频率所需要的计算时间会越长，<strong>一般而言，在3Hz到60Hz之间选择15到30个频率就够了</strong>。</p></li></ol><hr><h1 id="13-Complex-Morlet-Wavelets-cmw"><a href="#13-Complex-Morlet-Wavelets-cmw" class="headerlink" title="13 | Complex Morlet Wavelets (cmw)"></a>13 | Complex Morlet Wavelets (cmw)</h1><h2 id="Create-complex-sine-wave"><a href="#Create-complex-sine-wave" class="headerlink" title="Create complex sine wave"></a>Create complex sine wave</h2><p>复数域的Wavelet函数也是由sine函数和Gaussian相乘得来，只是所使用的sine函数是在复数域表示的（<script type="math/tex">e^{i2\pi ft}</script>）</p><ul><li><script type="math/tex">cmw=Ae^{-t^2/2s^2}e^{i2\pi ft}</script> (the x-axis offset for Gaussian are omitted)</li><li><script type="math/tex; mode=display">A=\frac{1}{(s\sqrt{\pi})^{1/2}}</script></li></ul><h2 id="The-Result-of-cmw"><a href="#The-Result-of-cmw" class="headerlink" title="The Result of cmw"></a>The Result of cmw</h2><p>复数wavelet与信号点积的结果有三个维度：<strong>时间、实部、虚部</strong>。将该结果绘制在复平面上，其在实轴、虚轴上的投影分别对应于wavelet的实部、虚部与信号的点积结果。</p><p>点积结果在复平面上所对应向量的长度反映了信号（signal）和核（kernal）的相似（重叠）程度，而且该长度与二者间的相位关系无关。相位关系由向量与实轴的夹角表示。</p><ul><li><strong>在实轴上的投影：带通滤波信号</strong>，其正负符号反映<strong>相位</strong>关系</li><li><strong>向量长度（振幅）：</strong>反映wavelet与signal的<strong>相似性</strong>或<strong>重叠度</strong>，其<strong>平方称为功率</strong><ul><li><code>abs(X).^2;</code> or <code>X.*conj(X);</code> (乘以共轭)</li></ul></li><li><strong>与实轴夹角：</strong>反映了在wavelet<strong>中心时间点</strong>（即分析时段的中间时刻）和wavelet的<strong>主频率</strong>（即小波的主要振荡频率）下，信号的<strong>相位</strong>信息。<ul><li><code>angle(X);</code> </li></ul></li><li>上述提到的功率和相位值只能作为估计值，因为它们会受到邻近时间点活动的影响。</li></ul><p><img src="https://s2.loli.net/2024/09/29/XMOHwQElB3y81gT.png" alt="image-20240819201632545" style="zoom:67%;" /></p><h2 id="Parameters-of-Wavelets"><a href="#Parameters-of-Wavelets" class="headerlink" title="Parameters of Wavelets"></a>Parameters of Wavelets</h2><ul><li><p><strong>最低频率</strong></p><ul><li>如果关注alpha-band activity，大概在5或6Hz即可</li><li>划分的时间区段（epoch）尽可能包含多个周期（如果epoch长1s，则不要低于4Hz）</li></ul></li><li><p><strong>最高频率</strong></p><ul><li>不能超过<strong>奈奎斯特频率（采样率的一半）</strong></li><li>单个wavelet周期尽可能包含更多的信号数据点，可以提高信噪比</li><li>没有特别的期望的话，可能选择4Hz到6Hz的频率范围</li></ul></li><li><p><strong>频率数目</strong></p><ul><li>一般取20-30个频率足够覆盖较宽的频率范围。条件允许的情况下当然是越多越好，但是相近的频率不一定能提供更多信息。</li></ul></li><li><p><strong>频率分布间隔</strong></p><ul><li><p><strong>线性分布</strong></p><ul><li><p>突出频谱的<strong>高频段</strong></p></li><li><p>可以直接使用 <code>imagesc(EEG.times,frequencies,tf_data);</code> 绘图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">imagesc(EEG.times,frex,eegpower)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>],<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1000</span>],<span class="string">&#x27;ydir&#x27;</span>,<span class="string">&#x27;norm&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;WRONG Y-AXIS LABELS!!!!&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Frequency (Hz)&#x27;</span>), xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>对数分布（推荐）</strong>：</p><ul><li><p>4-8Hz（theta）和30-80Hz（lower gamma）在y轴上占据的宽度会比较接近</p></li><li><p>突出频谱的<strong>低频段</strong></p></li><li><p>使用 <code>imagesc(EEG.times,[],tf_data)</code> 绘图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">imagesc(EEG.times,[],eegpower)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>],<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1000</span>],<span class="string">&#x27;ydir&#x27;</span>,<span class="string">&#x27;norm&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:<span class="number">6</span>:num_frex,<span class="string">&#x27;yticklabel&#x27;</span>,<span class="built_in">round</span>(<span class="built_in">logspace</span>(<span class="built_in">log10</span>(min_freq),<span class="built_in">log10</span>(max_freq),<span class="number">6</span>)*<span class="number">10</span>)/<span class="number">10</span>)<span class="comment">% important!</span></span><br><span class="line">title(<span class="string">&#x27;CORRECT Y-AXIS LABELS!!!!&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>wavelets 的长度</strong></p><ul><li>要足够长，使得<strong>两侧能衰减到0</strong>（接近0）</li><li><strong>没有长度限制</strong>，如果 -1s ~ +1s 不够，就设置成 -2s ~ +2s，不同的频率长度也不一定要相同</li><li>wavelet 的图像要<strong>设置在时间轴中央</strong>（关于中间时刻对称），最简单的方法是将时间范围设置成  -x seconds to +x seconds</li><li>wavelet 的<strong>采样率要和 EEG.data 一致</strong></li></ul></li><li><p><strong>Gaussian函数要包含多少个周期</strong></p><ul><li>“包含的周期数目”指的是Gaussian函数标准差公式<script type="math/tex">s=\frac{n}{2\pi f}</script>中的<strong><script type="math/tex">n</script></strong></li><li>包含周期数越多，<strong>频率精度</strong>越高，<strong>时间精度</strong>越低</li><li>包含周期的数目也可随频率改变</li><li>应至少包含3个周期，至多包含14个周期</li><li>在wavelet的非零段，需要保证数据（进行卷积的信号片段）的<strong>平稳性</strong>（均值、方差等统计特性保持稳定）</li></ul></li></ul><h2 id="相邻频率对小波卷积的贡献程度"><a href="#相邻频率对小波卷积的贡献程度" class="headerlink" title="相邻频率对小波卷积的贡献程度"></a>相邻频率对小波卷积的贡献程度</h2><ul><li><p><strong>Full width at half-maximum (FWHM)</strong></p><ul><li><p>指频谱上功率在峰值的左右两侧分别为<strong>50%</strong>时的频率宽度：<strong><script type="math/tex">FWHM=2\sqrt{2\ln 2}\sigma</script></strong>，其中<script type="math/tex">\sigma</script>是频率响应的<strong>标准差</strong></p><ul><li>首先标准化功率谱，使得峰值为1，两端衰减至0</li><li>找到功率值为0.5的点对应的频率，即可计算出FWHM</li></ul><p><img src="https://s2.loli.net/2024/08/22/IGb3NMwy4gUQfjA.png" alt="image-20240822161841368"></p></li></ul></li></ul><h2 id="卷积的Matlab计算技巧"><a href="#卷积的Matlab计算技巧" class="headerlink" title="卷积的Matlab计算技巧"></a>卷积的Matlab计算技巧</h2><ul><li>FFT的数据点数为<strong><script type="math/tex">2^n</script></strong>时，计算速度更快。可以通过适当的<strong>补零</strong>来实现</li><li>不需要对每个trial进行一次卷积，可以<strong>将所有trial连接成一个长时间序列</strong>，再对整个时间序列执行一次卷积</li></ul><hr><h1 id="14-Bandpass-Filtering-and-the-Hilbert-Transform"><a href="#14-Bandpass-Filtering-and-the-Hilbert-Transform" class="headerlink" title="14 | Bandpass Filtering and the Hilbert Transform"></a>14 | Bandpass Filtering and the Hilbert Transform</h1><h2 id="The-Procedure-of-Hilbert-Transform-Hilbert变换及其步骤"><a href="#The-Procedure-of-Hilbert-Transform-Hilbert变换及其步骤" class="headerlink" title="The Procedure of Hilbert Transform | Hilbert变换及其步骤"></a>The Procedure of Hilbert Transform | Hilbert变换及其步骤</h2><ul><li><p>对于一个只有实部的信号<script type="math/tex">A(t)\cos(2\pi ft)</script>，我们无法获得其相位信息，Hilbert变换能够帮助我们<strong>从实信号中提取出虚部</strong>，从而获得相位信息</p></li><li><p><strong>正频率与负频率</strong></p><ul><li><p><strong>正频率：</strong>介于<strong>0</strong>与<strong>奈奎斯特频率</strong>之间的频率（不包含0和奈奎斯特频率）</p></li><li><p><strong>负频率：</strong>大于奈奎斯特频率</p></li><li><p><strong>为什么要区分正频率与负频率？</strong></p><p><strong>信号的实部与虚部</strong>：一个纯实信号（如 <script type="math/tex">M\cos⁡(2πft)</script>）在频域中有对称的正负频率分量，它们共同构成了这个信号的傅里叶表示。然而，虚部（如<script type="math/tex">iM\sin ⁡(2πft)</script>）的引入使得信号不再是对称的，因此需要对正频率和负频率分量分别进行处理，以生成一个复信号。</p></li></ul></li><li><p><strong>Hilbert变换的步骤：</strong></p><ul><li><p>对信号做<strong>Fourier变换</strong>，得到<script type="math/tex">M(t)\cos (2\pi ft)</script>，乘以复数单位 <script type="math/tex">i</script>，得到<strong><script type="math/tex">iM(t)cos(2\pi ft)</script></strong></p></li><li><p><strong>正负频率的处理</strong></p><p><strong>正频率的处理</strong></p><ul><li><strong>逆时针旋转四分之一周期</strong>：正频率分量的傅里叶系数在复平面上表示时，通过逆时针旋转四分之一周期（即<script type="math/tex">-90°</script>或<script type="math/tex">\frac{\pi}{2}</script>），可以将余弦信号（<script type="math/tex">\cos ⁡(2πft)</script>)转化为正弦信号（<script type="math/tex">\sin⁡(2πft)</script>）。</li><li><strong>数学处理</strong>：这种旋转通过将傅里叶系数乘以 <script type="math/tex">−i</script>（即$-i=e^{-i\pi/2}$）来实现。这样，当你把旋转后的正频率系数加回到原来的正频率系数时，实际操作效果是将这些系数变成了原来系数的两倍。</li></ul><p><strong>负频率的处理</strong></p><ul><li><strong>顺时针旋转四分之一周期</strong>：负频率分量对应的傅里叶系数需要顺时针旋转四分之一周期（即$90°$或$\frac{\pi}{2}$），将余弦信号（$\cos ⁡(2πft)$）转化为负的正弦信号。</li><li><strong>数学处理</strong>：这个旋转通过将负频率傅里叶系数乘以 <script type="math/tex">i</script>（即 <script type="math/tex">i=e^{i\pi /2}</script>）来实现。由于这导致$i$和$i$相乘等于-1，负频率的系数经过处理后在添加回原来的系数时会变成零。这意味着负频率部分被完全消除。</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/08/24/bBZKcUlpuLw8CVn.png" alt="image-20240824004215712" style="zoom: 15%;" /></p><ul><li><strong>Hilbert变换的代码</strong></li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% the FFT-based hilbert transform</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% generate random numbers</span></span><br><span class="line">n = <span class="number">21</span>;</span><br><span class="line">randomnumbers = <span class="built_in">randn</span>(n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% take FFT</span></span><br><span class="line">f = fft(randomnumbers);</span><br><span class="line"><span class="comment">% create a copy that is multiplied by the complex operator</span></span><br><span class="line">complexf = <span class="number">1</span><span class="built_in">i</span>*f;</span><br><span class="line"></span><br><span class="line"><span class="comment">% find indices of positive and negative frequencies</span></span><br><span class="line">posF = <span class="number">2</span>:<span class="built_in">floor</span>(n/<span class="number">2</span>)+<span class="built_in">mod</span>(n,<span class="number">2</span>);<span class="comment">% 正频率：0到奈奎斯特频率</span></span><br><span class="line">negF = <span class="built_in">ceil</span>(n/<span class="number">2</span>)+<span class="number">1</span>+~<span class="built_in">mod</span>(n,<span class="number">2</span>):n;</span><br><span class="line"></span><br><span class="line"><span class="comment">% rotate Fourier coefficients</span></span><br><span class="line"><span class="comment">% (note 1: this works by computing the iAsin(2pft) component, i.e., the phase quadrature)</span></span><br><span class="line"><span class="comment">% (note 2: positive frequencies are rotated counter-clockwise; negative frequencies are rotated clockwise)</span></span><br><span class="line">f(posF) = f(posF) + <span class="number">-1</span><span class="built_in">i</span>*complexf(posF);</span><br><span class="line">f(negF) = f(negF) +  <span class="number">1</span><span class="built_in">i</span>*complexf(negF);</span><br><span class="line"><span class="comment">% The next two lines are an alternative and slightly faster method. </span></span><br><span class="line"><span class="comment">% The book explains why this is equivalent to the previous two lines.</span></span><br><span class="line"><span class="comment">% f(posF) = f(posF)*2;</span></span><br><span class="line"><span class="comment">% f(negF) = f(negF)*0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% take inverse FFT</span></span><br><span class="line">hilbertx = ifft(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">% compare with Matlab function hilbert</span></span><br><span class="line">hilbertm = hilbert(randomnumbers);</span><br></pre></td></tr></table></figure><ul><li>Hilbert变换并<strong>不改变信号的实部</strong>，可用此性质<strong>检验变换后的信号</strong>是否正确</li><li>在Matlab中，函数<code>hilbert()</code>的输入可以是一个矩阵<code>filtered_data = zeros(demension_1,demension_2)</code>，但是矩阵的第一个维度必须是时间（<code>filtered_data = zeros(EEG.pnts,EEG.nbchan)</code>），即对于二维矩阵，矩阵的<strong>每一列</strong>是一组信号</li><li>在进行Hilbert变换前，建议先对信号进行滤波，从而将信号分离成不同的频段，以便于分析</li></ul><h2 id="Bandpass-Filtering-带通滤波"><a href="#Bandpass-Filtering-带通滤波" class="headerlink" title="Bandpass Filtering | 带通滤波"></a>Bandpass Filtering | 带通滤波</h2><ul><li><p><strong>FIR &amp; IIR Filters</strong> </p><ul><li><strong>FIR (Finit Impluse Response, 有限冲激响应)：</strong>提供脉冲输入后，响应会在某一点终止。更稳定，且不容易引入非线性相位畸变</li><li><strong>FIR (Infinit Impluse Response, 无限冲激响应)：</strong>提供脉冲输入后，响应不会终止。算法计算复杂度更低，耗时少</li></ul></li><li><p><strong>Bandpass, Band-Stop, High-Pass, Low-Pass</strong></p><p><img src="https://s2.loli.net/2024/09/29/UG1BSRzbhwNugQK.jpg" alt="img" style="zoom: 67%;" /></p></li><li><p><strong>Create a filter kernel in Matlab</strong></p><ul><li><p><code>firls()</code>：通过最小二乘创建FIR滤波器。常用于<strong>宽频带</strong></p><ul><li><p><strong>第一个参数：The order of the filter</strong>，定义kernel的长度（单位为ms），决定了滤波器频率响应的精度。通常设置为<strong>下频界的2~5倍</strong>（如果下频界为10Hz（100ms），那么就是200到500ms）</p></li><li><p><strong>第二个参数：</strong>一个包含一组频率的频率向量，决定滤波器频率响应的形状。对于带通滤波器，可以使用六个频率：①零频率，②下过渡区开始的频率，③带通的下界，④带通的上界，⑤上过渡区结束的频率，⑥奈奎斯特频率。<strong>最后将这6个频率除以奈奎斯特频率</strong>（即以奈奎斯特频率为1）</p><p><img src="https://s2.loli.net/2024/09/29/aPqrFSNpTf2QGcm.png" alt="image-20240824003328931" style="zoom: 80%;" /></p><ul><li><strong>第三个参数：</strong>一个元素为0~1的向量，通过控制第二个输入参数的纵坐标来修改滤波器频响形状。对于带通滤波器，可以使用[0 0 1 1 0 0]，其中的“1”对应带通平台的上下频界，第一个和最后一个“0”对应直流和奈奎斯特频率，第二个和第五个“0”对应过渡区的频率界。</li></ul></li></ul></li><li><p><code>fir1()</code>：带有<strong>紧密过渡区</strong>的窗函数线性相位滤波器。常用于<strong>窄频带</strong></p><ul><li>第二个参数只需输入带通下界、带通上界两个频率值</li></ul></li><li><p><code>fir2()</code>：基于频率采样的滤波器结构</p></li><li><p><code>firrcos()</code>：凸起的余弦形滤波器</p></li><li><p><code>gaussfir()</code>：高斯形滤波器</p></li><li><p><code>firpm()</code>：Parks-McClellan</p></li></ul></li><li><p>频域内的<strong>尖锐边缘</strong>会引起时域内的<strong>伪影振荡</strong>，使用包含<strong>过渡区</strong>的滤波器可以缓解这一点，但是会牺牲一定的频率精度</p></li><li><p>检验滤波器是否合格：$sse=\Sigma_{i=1}^{n}(ideal_i-actual_i)^2$，sse即the sum of squared errors，对理想滤波器而言，n指的是滤波器的6个定位点（第二个参数）。</p></li><li><p>得到kernel后，使用<strong><code>filtfilt()</code>函数</strong>完成对信号的滤波，该函数输入的第一个为kernel；第二个参数为一个标量和向量，代表kernel的权重。通常设为；第三个参数为被处理信号。</p><ul><li>使用<code>filter()</code>函数会引入相位延迟，而<code>filtfilt()</code> 通过两次应用<code>filter</code>函数来消除相位延迟。具体来说，它首先对信号进行正向滤波，然后反转信号顺序，再次应用相同的滤波器，最后再将信号反转回来。</li></ul></li><li><p>Butterworth (IIR) Filter</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 5th-order butterworth filter</span></span><br><span class="line">[butterB,butterA] = butter(<span class="number">5</span>,[(center_freq-filter_frequency_spread)/nyquist (center_freq+filter_frequency_spread)/nyquist],<span class="string">&#x27;bandpass&#x27;</span>);</span><br><span class="line">butter_filter     = filtfilt(butterB,butterA,data2filter);</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="15-Short-Time-FFT"><a href="#15-Short-Time-FFT" class="headerlink" title="15 | Short-Time FFT"></a>15 | Short-Time FFT</h1><ul><li><p>Short-Time FFT 即取一小段时间内的数据进行fft，为了减小artifact，需要对这一段数据的两侧进行减弱处理</p><ul><li><p>可以用<strong>Hann、Hamming、Gaussian</strong>三种函数（tapers）完成减弱处理，推荐用<strong>Hann</strong>，因为它最终会衰减到0。其他taper还包括Kaiser, cosine, Blackman, …</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">timewin= <span class="number">400</span>; <span class="comment">% in ms, for stFFT</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(timewin/(<span class="number">1000</span>/EEG.srate));</span><br><span class="line"></span><br><span class="line"><span class="comment">% create hamming</span></span><br><span class="line">hamming_win = <span class="number">.54</span> - <span class="number">.46</span>*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>));</span><br><span class="line"><span class="comment">% create hann</span></span><br><span class="line">hann_win    = <span class="number">.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% create gaussian</span></span><br><span class="line">gaus_win = <span class="built_in">exp</span>(<span class="number">-.5</span>*(<span class="number">2.5</span>*(-timewinidx/<span class="number">2</span>:timewinidx/<span class="number">2</span><span class="number">-1</span>)/(timewinidx/<span class="number">2</span>)).^<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>得到FFT结果后，建议以目标频率周围几个频率的频响平均值（或Gaussian加权平均值）作为最终结果，可以提高信噪比</p></li></ul></li><li><p>时间段长度的选择</p><ul><li>A trade-off between temporal and frequency precision and resolution</li><li>时间段长度应至少包含<strong>所分析频率的一个周期</strong></li><li>时间段长度可以设为频率的函数（低频-时间段长；高频-时间段短）</li></ul></li></ul><hr><h1 id="16-Multitapers"><a href="#16-Multitapers" class="headerlink" title="16 | Multitapers"></a>16 | Multitapers</h1><ul><li><p>常用于低信噪比的情况，如高频活动或功率的单试次估计</p><p><img src="https://s2.loli.net/2024/09/29/znwZEO7RShHbMXl.png" alt="image-20240826221516720"></p></li><li><p><strong>The Tapers</strong></p><ul><li><p>multitapers使用的tapers是<strong>discrete prolate spheroidal sequences</strong>，也叫做Slepian tapers。可以使用Matlab中的<code>dpss()</code>函数生成。一组slepian tapers相互正交</p></li><li><h4 id="dpss-函数的基本调用格式如下："><a href="#dpss-函数的基本调用格式如下：" class="headerlink" title="dpss 函数的基本调用格式如下："></a><strong><code>dpss</code> 函数的基本调用格式如下：</strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br></pre></td></tr></table></figure><ul><li><code>N</code>：时间段的长度（以样本点为单位）。</li><li><code>NW</code>：时间带宽参数。它是时间段长度和频带宽度的乘积，<code>NW = N * (W / (Fs/2))</code>，其中 <code>W</code> 是频带宽度（以采样率的一半为单位，所以要除以采样率的一半），<code>Fs</code> 是采样率。</li><li><code>tapers</code>：返回的锥窗函数的矩阵，每一列是一个taper。</li><li><code>eigenvalues</code>：对应的特征值，表示每个taper在指定频带内包含的能量。</li></ul><h4 id="确定参数"><a href="#确定参数" class="headerlink" title="确定参数"></a><strong>确定参数</strong></h4><ul><li><strong>时间段长度 <code>N</code></strong>：取决于你想要的时间分辨率。</li><li><strong>带宽参数 <code>NW</code></strong>：它控制频谱的平滑程度。<code>NW</code> 的值越大，频谱越平滑，但时间分辨率越低。通常，<code>NW</code> 的值在 2 到 4 之间，也可随频率值改变。</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1000</span>; <span class="comment">% 假设有1000个样本点</span></span><br><span class="line">W = <span class="number">2</span>;    <span class="comment">% 频带宽度, 以赫兹为单位</span></span><br><span class="line">Fs = <span class="number">1000</span>; <span class="comment">% 采样率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算NW参数</span></span><br><span class="line">NW = N * (W / (Fs/<span class="number">2</span>));</span><br><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br></pre></td></tr></table></figure><h4 id="确定锥窗数量"><a href="#确定锥窗数量" class="headerlink" title="确定锥窗数量"></a><strong>确定锥窗数量</strong></h4><p><code>dpss</code> 函数返回的锥窗数量是 <code>2*NW</code> 四舍五入后的整数。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">numTapers = <span class="built_in">round</span>(<span class="number">2</span> * NW);</span><br></pre></td></tr></table></figure><h4 id="分析特征值"><a href="#分析特征值" class="headerlink" title="分析特征值"></a><strong>分析特征值</strong></h4><p><code>tapers</code> 的最后一个特征值一般较低（例如 0.7 或 0.8），表示该taper的频谱表现较差，通常可以忽略这些较差的锥窗。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 检查特征值</span></span><br><span class="line"><span class="built_in">disp</span>(eigenvalues);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 忽略最后一个特征值较低的taper</span></span><br><span class="line">tapersToUse = tapers(:, eigenvalues &gt; <span class="number">0.9</span>);</span><br></pre></td></tr></table></figure><h3 id="5-完整示例代码"><a href="#5-完整示例代码" class="headerlink" title="5. 完整示例代码"></a>5. <strong>完整示例代码</strong></h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 参数设置</span></span><br><span class="line">N = <span class="number">1000</span>; <span class="comment">% 样本点数</span></span><br><span class="line">W = <span class="number">2</span>;    <span class="comment">% 频带宽度</span></span><br><span class="line">Fs = <span class="number">1000</span>; <span class="comment">% 采样率</span></span><br><span class="line">NW = N * (W / (Fs/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成tapers</span></span><br><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示特征值</span></span><br><span class="line"><span class="built_in">disp</span>(eigenvalues);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择特征值大于0.9的tapers</span></span><br><span class="line">tapersToUse = tapers(:, eigenvalues &gt; <span class="number">0.9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制tapers</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(tapersToUse);</span><br><span class="line">title(<span class="string">&#x27;Selected DPSS Tapers&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (samples)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/29/RdGDVt4Iap2oYjW.png" alt="test_dps"></p></li></ul></li><li><p>通过使用多个taper，multitaper方法在频率轴上引入了一定的<strong>平滑效应</strong>。这种平滑可以减少频率分辨率的精细度，使得<strong>频谱变得更加连续和平滑</strong>。</p><p><strong>（ChatGPT的例子）</strong>假设你在一个任务中研究Gamma频段活动，并且发现某些被试的伽马频段峰值在50Hz，而另一些被试的峰值在65Hz。如果你使用精细的小波分析，每个被试的频谱可能显示出各自独特的伽马活动峰值，但这些峰值的差异可能在跨被试平均时抵消，导致难以在群体水平上识别伽马活动。此时，通过使用multitapers方法并引入适当的频率平滑，你可以让50Hz和65Hz的峰值在频谱中更接近，从而在群体平均时更容易识别出Gamma频段的整体活动。这种平滑可以帮助你在不损失重要频率信息的情况下，更好地捕捉和解释群体层面的神经活动。</p></li><li><p>适用情况</p><ul><li>noisy data, small number of trials</li><li>single-trial analyses, analyze frequencies above around 30 Hz</li><li>high-frequency power above around 60 Hz</li></ul></li></ul><hr><h1 id="18-Time-Frequency-Power-and-Baseline-Normalization"><a href="#18-Time-Frequency-Power-and-Baseline-Normalization" class="headerlink" title="18 | Time-Frequency Power and Baseline Normalization"></a>18 | Time-Frequency Power and Baseline Normalization</h1><h2 id="1-f-Power-Scaling"><a href="#1-f-Power-Scaling" class="headerlink" title="1/f Power Scaling"></a>1/f Power Scaling</h2><ul><li>EEG的<strong>时频功率</strong>和<strong>频率</strong>呈现<strong>幂函数</strong>的关系：$power=\frac{c}{frequency^x}$，难以进行数据分析</li></ul><h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><ul><li><strong>baseline</strong>指的是一段时间，通常在<strong>试验开始前几百毫秒</strong>，在这段时间内<strong>很少或没有任务相关的脑电活动</strong>。</li></ul><h2 id="Decibel-Conversion"><a href="#Decibel-Conversion" class="headerlink" title="Decibel Conversion"></a>Decibel Conversion</h2><ul><li><strong>计算公式：</strong></li></ul><script type="math/tex; mode=display">dB_{tf}=10\log10(\frac{activity_{tf}}{\overline{baseline_f}})</script><p>​    由于对数函数的存在，该公式不适用于存在非正值的数据，但功率值总是为正的。</p><ul><li><strong>Matlab计算代码</strong></li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 定义baseline所处时间段</span></span><br><span class="line">baselinetime = [ <span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 找到baseline所划分时间段的时间索引</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct 转换为分贝指</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(tf_data(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>);<span class="comment">% 以baseline时间段内功率的时间平均值作为baseline_power，即分贝计算的分母</span></span><br><span class="line">dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,tf_data,baseline_power));</span><br><span class="line"><span class="comment">% FYI: the following lines of code are equivalent to the previous line:</span></span><br><span class="line"><span class="comment">% dbconverted = 10*( bsxfun(@minus,log10(tf_data),log10(baseline_power)));</span></span><br><span class="line"><span class="comment">% dbconverted = 10*log10( tf_data ./ repmat(baseline_power,1,EEG.pnts) );</span></span><br><span class="line"><span class="comment">% dbconverted = 10*( log10(tf_data) - log10(repmat(baseline_power,1,EEG.pnts)) );</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">contourf(EEG.times,frequencies,dbconverted,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;ytick&#x27;</span>,<span class="built_in">round</span>(<span class="built_in">logspace</span>(<span class="built_in">log10</span>(frequencies(<span class="number">1</span>)),<span class="built_in">log10</span>(frequencies(<span class="keyword">end</span>)),<span class="number">10</span>)*<span class="number">100</span>)/<span class="number">100</span>,<span class="string">&#x27;yscale&#x27;</span>,<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-500</span> <span class="number">1500</span>],<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-12</span> <span class="number">12</span>])</span><br></pre></td></tr></table></figure><ul><li><strong>一些细节</strong><ul><li>对于多个trial平均后的数据，经分贝转换后的功率通常分布在$\pm 1-4\ dB$</li><li>通常采用对称的颜色映射分布，便于比较增大与减小的幅度。某些情况下也可以用不对称的分布来突出某些特征</li></ul></li></ul><h2 id="Percentage-Change"><a href="#Percentage-Change" class="headerlink" title="Percentage Change"></a>Percentage Change</h2><ul><li><strong>计算公式</strong></li></ul><script type="math/tex; mode=display">prctchange_{tf}=100\frac{activity_{tf}-\overline{baseline_f}}{\overline{baseline}_f}</script><h2 id="Baseline-Division"><a href="#Baseline-Division" class="headerlink" title="Baseline Division"></a>Baseline Division</h2><ul><li><strong>计算公式</strong><script type="math/tex; mode=display">BaselineDivision = \frac{activity_{tf}}{\overline{baseline_f}}</script></li></ul><h2 id="Z-Transform"><a href="#Z-Transform" class="headerlink" title="Z-Transform"></a>Z-Transform</h2><ul><li><strong>计算公式</strong><script type="math/tex; mode=display">Z_{tf}=\frac{activity_{tf}-\overline{baseline_f}}{\sqrt{n^{-1}\sum_{i=1}^{n}(baseline_{if}-\overline{baseline_f})^2}}</script>其中n是baseline中的时间点数目，分母是baseline的标准差。当baseline的标准差较大时，不建议使用Z-Tranform</li></ul><h2 id="均值or中位数"><a href="#均值or中位数" class="headerlink" title="均值or中位数"></a>均值or中位数</h2><ul><li>在trial数量少、噪声大的情况下，中位数更不易受到离群值的影响</li><li>在对所有trial进行平均前，先对单个trial进行baseline normalization（single-trial Z-transform），可以减少离群数据的影响</li></ul><h2 id="如何选择Baseline"><a href="#如何选择Baseline" class="headerlink" title="如何选择Baseline"></a>如何选择Baseline</h2><ul><li><strong>ERP</strong><ul><li>baseline通常终止于time=0</li></ul></li><li><strong>time-frequency analyses</strong><ul><li>baseline通常设置为 <strong>-500 ~ -200 ms</strong> 或 <strong>-400 ~ -100 ms</strong>。因为在提取频域信息时，每个时间点上的数据会“泄露”到周围的时间点上，所以应该尽量避开刺激前的一段时间</li><li>要确保选择的baseline时间段内<strong>没有多余的刺激</strong>，比如试验开始的提示等</li><li>尽可能使用<strong>pretrial period</strong>作为baseline，而非preresponse period等其他时间段，以减少刺激相关神经活动的影响</li><li>baseline通常包含<strong>几百毫秒</strong></li><li>如果无法使用pretrial period作为baseline，可以考虑如下替代方案<ul><li>使用休息时间作为baseline。但被试对待休息与试验时心态的差异可能会影响最终结果</li><li>使用对照条件（区别于实验条件）作为baseline。对照与实验条件下反应时间的差异可能会影响最终结果</li><li>使用整个实验过程作为baseline。难以观测到功率在整个实验中的持续变化</li></ul></li><li>如果有多种不同的试验条件（condition），需要考虑使用 <strong>condition-specific baseline</strong> 还是 <strong>condition-average baseline</strong> ，即不同条件是否要使用同一段baseline</li></ul></li></ul><h2 id="Signal-to-Noise-Ratio-SNR-Estimates-信噪比的估计"><a href="#Signal-to-Noise-Ratio-SNR-Estimates-信噪比的估计" class="headerlink" title="Signal-to-Noise Ratio (SNR) Estimates| 信噪比的估计"></a>Signal-to-Noise Ratio (SNR) Estimates| 信噪比的估计</h2><ul><li><p>信噪比：可以认为是信号的<strong>平均值</strong>与信号的<strong>标准差</strong>的比值</p></li><li><p>计算公式：</p><script type="math/tex; mode=display">SNR=\frac{\mu}{\sigma}</script></li><li><p>对ERP而言</p><ul><li>$\mu$可以认为是某个ERP成分的峰值，$\sigma$可以认为是baseline的时间方差</li></ul></li><li><p>对time-frequency analyses</p><ul><li>$SNR_{tf}$：$\mu$为所有trial的平均功率，$\sigma$为所有trial的功率标准差，$tf$表示一个时频点</li><li>$SNR_{base}$：$\mu$为所有trial的平均功率，$\sigma$为baseline的功率标准差</li></ul></li></ul><h2 id="检验Trial的数量是否足够"><a href="#检验Trial的数量是否足够" class="headerlink" title="检验Trial的数量是否足够"></a>检验Trial的数量是否足够</h2><p>随机选取n个trial，计算这n个trial的平均值与所有trial平均值的相关系数，相关性越强，说明trial的数目越充足。对于没有进行baseline transform的非正态分布数据，通常计算Spearman相关系数</p><p><img src="https://s2.loli.net/2024/09/29/T6y49I3SCU7rxzt.png" alt="Figure18.13"></p><h2 id="DownSampling-降采样"><a href="#DownSampling-降采样" class="headerlink" title="DownSampling | 降采样"></a>DownSampling | 降采样</h2><p>时频分解后由于泄露，信号的时间精度会降低，因此时间分辨率可以适当降低，比如降低到 40 或 50 Hz</p><hr><h1 id="19-Intertrial-Phase-Clustering"><a href="#19-Intertrial-Phase-Clustering" class="headerlink" title="19 | Intertrial Phase Clustering"></a>19 | Intertrial Phase Clustering</h1><h2 id="Intertrial-Phase-Clustering-ITPC"><a href="#Intertrial-Phase-Clustering-ITPC" class="headerlink" title="Intertrial Phase Clustering (ITPC)"></a>Intertrial Phase Clustering (ITPC)</h2><ul><li><p><strong>主要思路</strong>：将不同trial在某一时刻的相位向量绘制在复平面上，模长为1，角度为各相位值，再计算所有向量的平均值，所得新向量的平均长度介于0和1之间，反映了<strong>多个Trial间相位的一致性(ITPC)</strong>，新向量的相位角则反映了<strong>相位的平均大小</strong></p></li><li><p><strong>计算公式：</strong></p><script type="math/tex; mode=display">ITPC_{tf}=|n^{-1}\Sigma^n_{r=1}e^{ik_{tfr}}|</script></li></ul><p><img src="https://s2.loli.net/2024/09/29/fy7Y6U3l42MNoR5.png" alt="image-20240829212545402" style="zoom:50%;" /></p><ul><li><p>Trial数目越多，ITPC值减小并趋于稳定。所以尽量保证Trial数目足够多，且不同实验条件下的Trial数尽量保持一致</p></li><li><p>Trial数目不足且不一致时可采用的措施</p><ul><li><p>对trial进行筛选，以匹配不同条件下的trial数目</p></li><li><p>采用baseline ITPC，因为不服从1/f的分布，通常采用linear baseline</p></li><li><p>将$ITPC$转换为$ITPC_Z$</p><script type="math/tex; mode=display">ITPC_Z=n\cdot ITPC^2</script></li></ul></li></ul><h2 id="Effect-of-Temporal-Jitter-on-ITPC"><a href="#Effect-of-Temporal-Jitter-on-ITPC" class="headerlink" title="Effect of Temporal Jitter on ITPC"></a>Effect of Temporal Jitter on ITPC</h2><ul><li>Temporal Jitter：刺激呈现等事件发生时间的波动或不确定性</li><li>Temporal Jitter对相位的影响大于对功率的影响，且在高频处的影响更大</li></ul><h2 id="ITPC-and-Power"><a href="#ITPC-and-Power" class="headerlink" title="ITPC and Power"></a>ITPC and Power</h2><ul><li>ITPC和Power通常是不相关的，可以分别进行分析说明</li><li>功率越小，相位越难估计（可以想象功率为0的极端情况）</li></ul><h2 id="Weighted-ITPC-wITPC"><a href="#Weighted-ITPC-wITPC" class="headerlink" title="Weighted  ITPC (wITPC)"></a>Weighted  ITPC (wITPC)</h2><ul><li>wITPC中向量的长度不是1，而是和试验中的行为或试验变量有关，比如反应时间、刺激亮度、瞳孔反映等</li></ul><script type="math/tex; mode=display">wITPC_{tf}=|n^{-1}\Sigma^n_{r=1}b_re^{ik_{tfr}}|</script><ul><li><blockquote><p><strong>wITPCz（待补充）</strong></p></blockquote></li></ul><hr><h1 id="20-Differences-among-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency"><a href="#20-Differences-among-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency" class="headerlink" title="20 | Differences among Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency"></a>20 | Differences among Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency</h1><ul><li><p>Non-Phase-Locked Power (Induced Power)</p><ul><li>计算方法：首先从每次试验的数据中减去ERP，然后对单次试验进行时间-频率分解，计算功率。这种方法去除了所有相位锁定 的成分，因此剩下的功率仅代表非相位锁定的部分</li></ul></li><li><p>Phase-Locked Power</p><ul><li>计算方法：从总功率中减去非相位锁定功率，注意需要先将总功率和非锁相功率分别转化为分贝，再相减</li><li>高频活动在多个周期后难以保持相位锁定，因此相位锁定功率中通常不包含大于20Hz左右的高频成分</li></ul></li><li>ERP Time-Frequency Power<ul><li>先计算ERP，再进行频域变换，而不是先进行频域变换，再计算ERP</li><li>It is appropriate to use <strong>the ERP baseline</strong> to normalize the ERP time-frequency power, rather than using the base line period power from the total or non-phase-locked analysis.</li></ul></li></ul><hr><h1 id="22-Surface-Laplacian"><a href="#22-Surface-Laplacian" class="headerlink" title="22 | Surface Laplacian"></a>22 | Surface Laplacian</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>采用Surface Laplacian可以突出局部的空间特征，削弱空间上广泛分布的活动</li><li>“Surface Laplacian” 和 “Current Scalp Dencity” 的区别<ul><li>Surface Laplacian 只是一种空间滤波的方法</li><li>Current Scalp Dencity 强调滤波后的结果</li></ul></li><li>Surface Laplacian只能用于<strong>EEG</strong>（不能用于MEG），且通常用于<strong>电极数目大于64</strong>的EEG数据</li><li>The Laplacian is more sensitive to <strong>radial dipoles</strong> than it is to tangential dipoles.</li><li><p>Activity seen in the surface Laplacian is dominated (although not necessarily entirely driven) by radial dipoles in regions of the cortex close to the skull (such as  <strong>gyral crowns</strong>). </p></li><li><p>The Laplacian must be applied to time-domain data, not to time-frequency data.</p></li></ul><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>The <strong>weights</strong> that are applied to the data such that the activity at each electrode becomes a weighted sum of activity of all other electrodes.</p><script type="math/tex; mode=display">G_{ij}=(4\pi)^{-1}\sum^{order}_{n=1}\frac{(2n+1)P_n(cosdist_{ij})}{(n(n+1))^m}</script><script type="math/tex; mode=display">H_{ij}=(4\pi)^{-1}\sum^{order}_{n=1}\frac{-2(n+1)P_n(cosdist_{ij})}{(n(n+1))^{m-1}}</script><p>The <strong>cosine distance</strong> among all pairs of electrodes</p><script type="math/tex; mode=display">cosdist_{ij}=1-\frac{(X_i-X_j)^2+(Y_i-Y_j)^2+(Z_i-Z_j)^2}{2}</script><p>The <strong>Laplacian for electrode <em>i</em></strong> at one time point</p><script type="math/tex; mode=display">lap_i=\sum^{nelec}_{j=1}C_iH_{ij}</script><p>The C matrix is where <strong>the data</strong> are finally introduced</p><script type="math/tex; mode=display">C_i=d_i-\frac{\sum^{nelec}_{j=1}d_j}{\sum^{nelec}_{j=1}Gs_j^{-1}}Gs^{-1}</script><script type="math/tex; mode=display">d_i=data_j^{-1}Gs</script><script type="math/tex; mode=display">Gs=G+\lambda</script><h2 id="Surface-Laplacian-for-Connectivity-Analyses"><a href="#Surface-Laplacian-for-Connectivity-Analyses" class="headerlink" title="Surface Laplacian for Connectivity Analyses"></a>Surface Laplacian for Connectivity Analyses</h2><ul><li>经过Surface Laplacian的处理后，电极间信号的相关性与电极距离的联系减弱，但间隔比较近的电极仍然会相互影响，因此应该避免对<strong>间隔5cm以内</strong>的电极采用空间相关性的规律解释。</li></ul><p><img src="https://s2.loli.net/2024/09/29/E2wYj3o5KCczsIm.png" alt="image-20240902170921494" style="zoom:67%;" /></p><hr><h1 id="23-Principal-Components-Analyses-PCA"><a href="#23-Principal-Components-Analyses-PCA" class="headerlink" title="23 | Principal Components Analyses (PCA)"></a>23 | Principal Components Analyses (PCA)</h1><p><a href="https://www.bilibili.com/video/BV1E5411E71z/?spm_id_from=333.337.search-card.all.click&amp;vd_source=e7f03c857e620b80dcde0db3e7f51d26">用最直观的方式告诉你：什么是主成分分析PCA</a></p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li>与 Surface Laplacian 相反，PCA反映的不是电极的局部特征，而是弱化局部特征后的总体特征</li></ul><p><img src="https://s2.loli.net/2024/09/29/S1gxXyBbeauTrIA.png" alt="image-20240904111437587" style="zoom: 67%;" /></p><h2 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h2><h3 id="计算协方差"><a href="#计算协方差" class="headerlink" title="计算协方差"></a>计算协方差</h3><p>协方差的矩阵计算公式:</p><script type="math/tex; mode=display">covariance = (n-1)^{-1}(X-\bar{X})(X-\bar{X})^T</script><p>如果把<strong>电极</strong>作为<strong>变量</strong>，电极数目为变量的维度，每一个<strong>时间点</strong>下各个电极的数据看作一次<strong>观测</strong>得到的结果，组成一个列向量，那么经过多个时间点的观测后，我们可以得到一个 <strong>$electrodes(m) \times time\ points(n)$</strong> 的矩阵$X$：</p><script type="math/tex; mode=display">X=\begin{bmatrix} d_{e_1t_1} & d_{e_1t_2} & \cdots & d_{e_1t_n}\\ d_{e_2t_1} & d_{e_2t_2} & \cdots & d_{e_2t_n}\\ \vdots & \vdots & \ddots & \vdots\\ d_{e_mt_1} & d_{e_mt_2} & \cdots & d_{e_mt_n}\end{bmatrix}</script><p>协方差公式中的$\bar{X}$是各列向量的平均值，即关于时间点的平均值，<strong>n</strong>是时间点的数目。协方差矩阵的对角线元素则为对应维度的方差</p><p>对于多个试次的数据，可以采用<strong>三种方式</strong>计算协方差：</p><ul><li>先计算<strong>ERP</strong>，再以ERP作为各数据值得到矩阵$X$。该计算方法得到的是<strong>phase-locked</strong> (evoked) covariance</li><li>将各试次作为不同的观测点，得到的$X$矩阵有$electrode$行，$time\ points \times trials$列，进一步以此矩阵计算协方差。得到的是<strong>total</strong> (phase-locked and non-phase-locked) covariance</li><li>（常用）先对每一个试次计算协方差，最后平均。该方法可以提高信噪比，得到的是<strong>total</strong> (phase-locked and non-phase-locked) covariance</li></ul><h3 id="计算协方差矩阵的特征值和特征向量"><a href="#计算协方差矩阵的特征值和特征向量" class="headerlink" title="计算协方差矩阵的特征值和特征向量"></a>计算协方差矩阵的特征值和特征向量</h3><p>采用matlab中的<code>eig</code>或<code>svd</code>函数计算协方差矩阵的特征值和特征向量。注意，Matlab函数<code>eig</code>以<strong>升序</strong>返回特征值和特征向量，但是让结果按<strong>降序</strong>排序会更直观。</p><ul><li>特征向量是旋转后的坐标轴方向</li><li>特征值是旋转后坐标轴的长度，经归一化可后作为对应主成分的<strong>百分比方差</strong>，即对<strong>每个特征值除以所有特征值的和，再乘以100</strong></li></ul><p>特征向量矩阵中的每一列都是一个<strong>主成分</strong>，该列的每行元素存储对应电极的<strong>权重（weight）</strong>，通常权重的正负符号不重要</p><h3 id="结果的呈现与解释说明"><a href="#结果的呈现与解释说明" class="headerlink" title="结果的呈现与解释说明"></a>结果的呈现与解释说明</h3><ul><li><strong>PCA map：</strong>特征向量矩阵<strong>每一列</strong>可由<code>topoplot</code>绘制成一张<strong>PCA map</strong>图</li><li><strong>time course：</strong>将每个时间点下的各电极<strong>权重（特征向量中的一行）</strong>与电极对应的时间序列<strong>数据（$X_i-\bar{X_i}$）</strong>相乘，再相加，得到一个时间点下的<strong>time course</strong>。每一个主成分（每一列）对应一个权重，也就对应一组time course（即<strong>各电极的加权和</strong>）。得到主成分时间序列数据（time course）后，可以对这些数据采用与其他时间序列数据相同的方法进行分析，比如计算ERP或时频功率等。</li><li>可以根据特征值的大小对主成分进行取舍</li><li>可以计算所有特征值比阈值低的成分对应的方差，以估计全局脑电图响应的“噪声”</li><li>特征值下降的快慢可以理解为系统的复杂度的大小，下降得越快，被舍弃的成分越多，系统的复杂度越小</li></ul><h2 id="Independent-Components-Analysis（ICA）"><a href="#Independent-Components-Analysis（ICA）" class="headerlink" title="Independent Components Analysis（ICA）"></a>Independent Components Analysis（ICA）</h2><h3 id="PCA和ICA的区别"><a href="#PCA和ICA的区别" class="headerlink" title="PCA和ICA的区别"></a>PCA和ICA的区别</h3><ul><li>PCA的作用：去相关性、降维</li><li>ICA的作用：分离独立源</li></ul><hr><h1 id="24-Single-Dipole-and-Distributed-Source-Imaging"><a href="#24-Single-Dipole-and-Distributed-Source-Imaging" class="headerlink" title="24 | Single-Dipole and Distributed-Source Imaging"></a>24 | Single-Dipole and Distributed-Source Imaging</h1><h2 id="Forward-Solution-amp-Inverse-Problem"><a href="#Forward-Solution-amp-Inverse-Problem" class="headerlink" title="Forward Solution &amp; Inverse Problem"></a>Forward Solution &amp; Inverse Problem</h2><p><img src="https://s2.loli.net/2024/09/29/Z9IAaHlrRNCYS2P.png" alt="image-20240905155005900" style="zoom:50%;" /></p><h2 id="Inverse-Problem"><a href="#Inverse-Problem" class="headerlink" title="Inverse Problem"></a>Inverse Problem</h2><ul><li><strong>Dipole Fitting：</strong>需要确定偶极子（dipole）的位置、方向、大小</li><li><strong>Distributed-Source Imaging：</strong>已经确定了偶极子的位置和方向，只需要确定大小</li><li>you should be cautious when hearing claims of functional-anatomical dissociations of <strong>less than a few centimeters</strong> based on results of source reconstruction. Such high spatial accuracy is possible but not common. </li></ul><hr><h1 id="25-Introduction-to-the-Various-Connectivity-Analyses"><a href="#25-Introduction-to-the-Various-Connectivity-Analyses" class="headerlink" title="25 | Introduction to the Various Connectivity Analyses"></a>25 | Introduction to the Various Connectivity Analyses</h1><ul><li>Connectivity：指在同一时刻下考虑多个信号之间关系的分析。</li><li>需区分的概念：<ul><li><strong>functional connectivity：</strong>linear or nonlinear covariation between fluctuations in activity recorded from distinct neural networks. 更接近于<strong>相关性（correlation）</strong></li><li><strong>effective connectivity：</strong>a causal influence of activity in one neural network over activity in another neural network. 更接近于<strong>因果关系（causation）</strong></li></ul></li><li>两个电极之间的功能连接（connectivity）可以反映不同大脑区域之间的真实连接，也可能是由于这两个电极测量了来自同一脑源的活动。</li></ul><hr><h1 id="26-Phase-Based-Connectivity"><a href="#26-Phase-Based-Connectivity" class="headerlink" title="26 | Phase-Based Connectivity"></a>26 | Phase-Based Connectivity</h1><h2 id="ISPC-Intersite-phase-clustering"><a href="#ISPC-Intersite-phase-clustering" class="headerlink" title="ISPC (Intersite phase clustering)"></a>ISPC (Intersite phase clustering)</h2><p>ISPC是一种用以描述基于相位的功能连接的方法，与ITPC相似，但计算的是两电极之间随<strong>时间或试次</strong>变化的<strong>相位角差</strong>的平均值</p><script type="math/tex; mode=display">ISPC_f=|n^{-1}\sum^n_{t=1}e^{i(\phi_{xt}-\phi_{yt})}|</script><p>其中 <strong>n</strong> 是时间点数目或试次数目，<strong>$\phi_x$</strong> 和 <strong>$\phi_{y}$</strong> 是电极 x 和 y 在频率f下的相角，t是时间点或试次。</p><ul><li>ISPC反映的不是两电极相位差的大小，而是<strong>相位差随时间或试次的一致性</strong></li><li>ISPC是无向的（A→B的ISPC和B→A的相同）</li></ul><h2 id="ISPC-time-and-ISPC-trial"><a href="#ISPC-time-and-ISPC-trial" class="headerlink" title="ISPC-time and ISPC-trial"></a>ISPC-time and ISPC-trial</h2><p>通过上面的公式，我们可以得到的是在<strong>一个时间窗口</strong>内<strong>一个试次</strong>的ISPC，如果有多个试次，而且我们想要得到ISPC随时间/试次的变化，可以采用如下方法：</p><ul><li><p><strong><em>ISPC-time</em></strong>：设置一个滑动的小时间窗，计算单个试次在每个时间窗下的ISPC（类似于short-time FFT），得到多个试次下的ISPC随时间的变化，最后再进行试次平均，得到ISPC<strong>在不同时刻下</strong>的值。小时间窗的长度选取规则类似于wavelet中the number of cycles的选取。</p></li><li><p><strong><em>ISPC-trials</em></strong>：关注某一<strong>时间点</strong>下<strong>不同试次</strong>的相位差大小。ISPC-trial所反映是在不同的试次下，两电极间的相位差是否能保持一致，其值越大，说明相位差在不同试次下越能保持一致。</p><ul><li><p>对试次的数目比较敏感，试次数目需要足够多，才能获得稳定的结果</p></li><li><p>如果在不同实验条件下的试次不同，可以考虑使用 <strong>weighted ISPC-trials (wISPC-trials)</strong>，其原理与 wITPC 相近。</p></li></ul></li><li><p>计算时的区别：</p><ul><li><p><strong><em>ISPC-time</em></strong>：先在滑动时间窗内时间平均，最后试次平均</p></li><li><p><strong><em>ISPC-trial</em></strong>：在不同时间点下进行试次平均</p><p><img src="https://s2.loli.net/2024/09/29/4b627IyN5OcGRlh.png" alt="image-20240910225214537" style="zoom:50%;" /></p></li></ul></li><li><p><strong>Matlab代码实现</strong>：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 对于频率，通常采用对数分布</span></span><br><span class="line">freqs2use  = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">4</span>),<span class="built_in">log10</span>(<span class="number">30</span>),<span class="number">15</span>); <span class="comment">% 4-30 Hz in 15 steps</span></span><br><span class="line"><span class="comment">% 非频率值，可以采用线性分布，timewindow的宽度是下面取值的两倍</span></span><br><span class="line">timewindow = <span class="built_in">linspace</span>(<span class="number">1.5</span>,<span class="number">3</span>,<span class="built_in">length</span>(freqs2use)); <span class="comment">% number of cycles on either end of the center point (1.5 means a total of 3 cycles))</span></span><br></pre></td></tr></table></figure><p><strong>ISPC-time (ispc)</strong> 和 <strong>ISPC-trial (ps)</strong> 的计算：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:<span class="built_in">length</span>(freqs2use)</span><br><span class="line">    <span class="comment">% phase angle differences（维度为time×trials）</span></span><br><span class="line">    phase_diffs = phase_sig1-phase_sig2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% compute ISPC over trials（trial平均，时间没有平均，所以ps的是&quot;频率×时间&quot;的矩阵）</span></span><br><span class="line">    ps(fi,:) = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase_diffs(times2saveidx,:)),<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算每一个时间点（timewindow中点）下的ISPC</span></span><br><span class="line">    <span class="keyword">for</span> ti=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% compute phase synchronization（ISPC-time，每个时间窗可计算出一个值，1×trial）</span></span><br><span class="line">        phasesynch = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase_diffs(times2saveidx(ti)-time_window_idx:times2saveidx(ti)+time_window_idx,:)),<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% average over trials（trial平均）</span></span><br><span class="line">        ispc(fi,ti) = <span class="built_in">mean</span>(phasesynch);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> <span class="comment">% end frequency loop</span></span><br></pre></td></tr></table></figure><p>最后可以让每个时间点<strong>减去baseline</strong>时间内的ISPC平均值，突出任务相关影响：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% ISPC-time</span></span><br><span class="line">contourf(times2save,freqs2use,ispc-<span class="built_in">repmat</span>(<span class="built_in">mean</span>(ispc(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">size</span>(ispc,<span class="number">2</span>)),<span class="number">20</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% ISPC-trial</span></span><br><span class="line">contourf(times2save,freqs2use,<span class="built_in">bsxfun</span>(@minus,ps,<span class="built_in">mean</span>(ps(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>)),<span class="number">20</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Spectral-Coherence-Magnitude-Squared-Coherence-波谱相干"><a href="#Spectral-Coherence-Magnitude-Squared-Coherence-波谱相干" class="headerlink" title="Spectral Coherence (Magnitude-Squared Coherence) | 波谱相干"></a><strong>Spectral Coherence (Magnitude-Squared Coherence)</strong> | 波谱相干</h2><p>波谱相干可以理解为是把<strong>信号功率作为权重</strong>的<strong>加权ISPC</strong></p><h3 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h3><p>常见的波谱相干公式：=</p><script type="math/tex; mode=display">Coher_{xy}=\left| \frac{S_{xy}}{S_{xx}S_{yy}}\right|</script><p>$S_{xy}$ 是电极x和y处的互功率谱密度，$S_{xx}$ 和 $S_{yy}$ 是电极x和y处的自功率谱密度。上式中的分子有时会平方，从而和分母的量级相配合。</p><p>为便于理解，可以将波谱相干公式写成下面的形式：</p><script type="math/tex; mode=display">C_{xy}=\left| n^{-1}\sum^n_{t=1}\lvert m_{tx}m_{ty}\rvert e^{i\phi_{txy}}\right|^{2}</script><p>$m_x$和$m_y$是解析信号（没有负频率分量的复值函数）X和Y的功率大小（magnitudes），$\phi_{xy}$是电极X和Y之间的相位角差，t指trial或时间点。</p><p>可以发现使用这一公式计算出的$C_{xy}$值会随着功率大小改变，而功率又会随频率、时间、任务等改变，所以可以将这一公式进行归一化，得到如下波谱相干公式：</p><script type="math/tex; mode=display">Coher_{xy}=\frac{C_{xy}}{\left(n^{-1}\sum^n_{t=1}|m_{tx}|^2\right)\left(n^{-1}\sum^n_{t=1}|m_{ty}|^2\right)}</script><p>由这种方法得到的波谱相干性大小将介于0和1之间，1代表完全相干，0代表完全独立。</p><h3 id="Matlab代码实现"><a href="#Matlab代码实现" class="headerlink" title="Matlab代码实现"></a>Matlab代码实现</h3><ul><li>计算自功率谱大小时，使用信号乘以其共轭的方法 <code>sig1.*conj(sig1)</code>，耗时比直接平方<code>(sig1).^2</code>更短</li><li>计算互功率谱$S_{xy}$时，使用信号1乘以信号2的共轭的方法<code>sig1.*conj(sig2)</code>，耗时比欧拉公式<code>abs(sig1).*abs(sig2).*exp(1i*(angle(sig1)-angle(sig2)))</code>更短</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% select channels</span></span><br><span class="line">channel1 = <span class="string">&#x27;fz&#x27;</span>;</span><br><span class="line">channel2 = <span class="string">&#x27;o1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% wavelet and FFT parameters</span></span><br><span class="line">time          = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">half_wavelet  = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">n_wavelet     = <span class="built_in">length</span>(time);</span><br><span class="line">n_data        = EEG.pnts*EEG.trials;       </span><br><span class="line">n_convolution = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">chanidx    = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">% always initialize!</span></span><br><span class="line">chanidx(<span class="number">1</span>) = <span class="built_in">find</span>(strcmpi(channel1,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line">chanidx(<span class="number">2</span>) = <span class="built_in">find</span>(strcmpi(channel2,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">% data FFTs （把一个电极里所有trial的数据排列成一个行向量，减少计算的次数）</span></span><br><span class="line">data_fft1 = fft(<span class="built_in">reshape</span>(EEG.data(chanidx(<span class="number">1</span>),:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line">data_fft2 = fft(<span class="built_in">reshape</span>(EEG.data(chanidx(<span class="number">2</span>),:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize</span></span><br><span class="line">spectcoher = <span class="built_in">zeros</span>(<span class="built_in">length</span>(freqs2use),<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:<span class="built_in">length</span>(freqs2use)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create wavelet and take FFT</span></span><br><span class="line">    s = num_cycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*freqs2use(fi));</span><br><span class="line">    wavelet_fft = fft( <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*freqs2use(fi).*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(s^<span class="number">2</span>))) ,n_convolution);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% phase angles from channel 1 via convolution</span></span><br><span class="line">    convolution_result_fft = ifft(wavelet_fft.*data_fft1,n_convolution);</span><br><span class="line">    convolution_result_fft = convolution_result_fft(half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line">    <span class="comment">% 把原来排成一行的结果变回 electrodes×trials</span></span><br><span class="line">    sig1 = <span class="built_in">reshape</span>(convolution_result_fft,EEG.pnts,EEG.trials);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% phase angles from channel 2 via convolution</span></span><br><span class="line">    convolution_result_fft = ifft(wavelet_fft.*data_fft2,n_convolution);</span><br><span class="line">    convolution_result_fft = convolution_result_fft(half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line">    <span class="comment">% 把原来排成一行的结果变回 electrodes×trials</span></span><br><span class="line">    sig2 = <span class="built_in">reshape</span>(convolution_result_fft,EEG.pnts,EEG.trials);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% compute power and cross-spectral power</span></span><br><span class="line">    <span class="comment">% 自功率谱</span></span><br><span class="line">    spec1 = <span class="built_in">mean</span>(sig1.*<span class="built_in">conj</span>(sig1),<span class="number">2</span>);</span><br><span class="line">    spec2 = <span class="built_in">mean</span>(sig2.*<span class="built_in">conj</span>(sig2),<span class="number">2</span>);</span><br><span class="line">    <span class="comment">% 交叉功率谱的平方</span></span><br><span class="line">    specX = <span class="built_in">abs</span>(<span class="built_in">mean</span>(sig1.*<span class="built_in">conj</span>(sig2),<span class="number">2</span>)).^<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% alternative notation for the same procedure, using the Euler-like expression: Me^ik</span></span><br><span class="line">    <span class="comment">%spec1 = mean(abs(sig1).^2,2);</span></span><br><span class="line">    <span class="comment">%spec2 = mean(abs(sig2).^2,2);</span></span><br><span class="line">    <span class="comment">%specX = abs(mean( abs(sig1).*abs(sig2) .* exp(1i*(angle(sig1)-angle(sig2))) ,2)).^2;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 计算Coherence。compute spectral coherence, using only requested time points</span></span><br><span class="line">    spectcoher(fi,:) = specX(times2saveidx)./(spec1(times2saveidx).*spec2(times2saveidx));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% yet another equivalent notation, just FYI</span></span><br><span class="line">    <span class="comment">%spec1 = sum(sig1.*conj(sig1),2);</span></span><br><span class="line">    <span class="comment">%spec2 = sum(sig2.*conj(sig2),2);</span></span><br><span class="line">    <span class="comment">%specX = sum(sig1.*conj(sig2),2);</span></span><br><span class="line">    <span class="comment">%spectcoher(fi,:) = abs(specX(times2saveidx)./sqrt(spec1(times2saveidx).*spec2(times2saveidx))).^2;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>最终的结果可以减去baseline时间段的coherence：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">contourf(times2save,freqs2use,spectcoher-<span class="built_in">repmat</span>(<span class="built_in">mean</span>(spectcoher(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">size</span>(spectcoher,<span class="number">2</span>)),<span class="number">20</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Phase-Lag-Based-Measures"><a href="#Phase-Lag-Based-Measures" class="headerlink" title="Phase Lag-Based Measures"></a>Phase Lag-Based Measures</h2><p>spurious connectivity results that are caused by two electrodes measuring activity from <strong>the same source</strong> will have phase lags of <strong>zero</strong> or <strong>$\pi$</strong> ( <em>$\pi$</em> if the electrodes are on opposite sides of the dipole). 由体积传导（同源）引起的相位差通常为<strong>0或$\pi$</strong>。</p><h3 id="Imaginary-Coherence"><a href="#Imaginary-Coherence" class="headerlink" title="Imaginary Coherence"></a>Imaginary Coherence</h3><p>Imaginary coherence uses almost the same equation as that for spectual coherence, except <strong>the imaginary part of te spectual coherence is taken before the magnitude</strong>.</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% imaginary coherence</span></span><br><span class="line">    spec1 = sum(sig1.*<span class="built_in">conj</span>(sig1),<span class="number">2</span>); <span class="comment">%imaginart</span></span><br><span class="line">    spec2 = sum(sig2.*<span class="built_in">conj</span>(sig2),<span class="number">2</span>);</span><br><span class="line">    specX = sum(sig1.*<span class="built_in">conj</span>(sig2),<span class="number">2</span>);</span><br><span class="line">    spectcoher(fi,:) = <span class="built_in">abs</span>(<span class="built_in">imag</span>(specX(times2saveidx)./<span class="built_in">sqrt</span>(spec1(times2saveidx).*spec2(times2saveidx))));</span><br></pre></td></tr></table></figure><h3 id="Phase-Lag-Index（PLI）"><a href="#Phase-Lag-Index（PLI）" class="headerlink" title="Phase-Lag Index（PLI）"></a>Phase-Lag Index（PLI）</h3><p>根据上面的结论，我们可以有一个感性的认识：由体积传导引起的相位差通常分布在极坐标的0或$\pi$附近（关于实轴对称，指向左右），而不含体积传导的相位差将会分布在虚轴的正半轴或负半轴附近（关于虚轴对称，指向上下）。</p><p>The Phase-lag index（PLI）就通过计算互功率谱密度的虚部符号平均值，来定量地描述相位信号受体积传导效应影响的大小：</p><script type="math/tex; mode=display">PLI_{xy}=\left| n^{-1}\sum^n_{i=1}sgn(imag(S_{xyt})) \right|</script><p><img src="https://s2.loli.net/2024/09/29/p7HZrQYSWBsAi5T.png" alt="image-20240911163535796" style="zoom: 33%;" /></p><p>The weighted phase-lag index（wPLI）通过添加一个权重，使得离虚轴越近（虚部越大）的互功率谱密度值对PLI的贡献更大：</p><script type="math/tex; mode=display">PLI_{xy}=\frac{n^{-1} \sum^n_{i=1}\left|imag(S_{xyt}) \right|sgn(imag(S_{xyt}))}{n^{-1} \sum^n_{i=1}\left|imag(S_{xyt}) \right|}</script><h3 id="The-phase-slope-index"><a href="#The-phase-slope-index" class="headerlink" title="The phase-slope index"></a>The phase-slope index</h3><p>略</p><h2 id="Mean-Phase-Angle"><a href="#Mean-Phase-Angle" class="headerlink" title="Mean Phase Angle"></a>Mean Phase Angle</h2><p>在前文的计算中，我们关注的是计算得的connectivity（平均相位差向量/ISPC）的长度，以此来表征相位差的随时间或试次集中程度。实际上，<strong>平均相位差向量的相角（mean phase angle）</strong>也值得关注：</p><ul><li><p>它反映了两个电极之间的<strong>平均相位差</strong></p></li><li><p>可以测试相角或相角差是否在某些指定的相角上存在显著差异。这可以用于检测体积传导对结果造成的污染，也可以用于测试首选相位角是否对Connectivity的计算结果（不太理解）</p><script type="math/tex; mode=display">u=nISPC\cos{(\phi-\Phi)}\sqrt{\frac{2}{n}}</script><p>其中n是试次数目或时间点数目，$\phi$是测得的相角差，$\Phi$是要检验的假设相位角。</p><p>在数据点数目大的情况下，<strong>v-test</strong> 容易产生假阳性并具有对称性问题。为克服这些局限性，<strong>gv-test</strong>（Gaussian v-test）通过用高斯函数替代余弦成分，改进了对大量数据点的处理，减少了假阳性，并更精确地针对特定相位区域进行检验。</p><p>在计算出ISPC后，可以用gv-test以检验该结果是否受体积传导影响。如果gv-test提供了相位角差为0或$\pi$的证据，结果可能表明相位差为0、$\pi$或数据受体积传导污染。</p></li></ul><hr><h1 id="27-Power-Based-Connectivity"><a href="#27-Power-Based-Connectivity" class="headerlink" title="27 | Power-Based Connectivity"></a>27 | Power-Based Connectivity</h1><h2 id="Pearson-versus-Spearman-Coefficient"><a href="#Pearson-versus-Spearman-Coefficient" class="headerlink" title="Pearson versus Spearman Coefficient"></a>Pearson versus Spearman Coefficient</h2><h3 id="1-Pearson-相关系数"><a href="#1-Pearson-相关系数" class="headerlink" title="1. Pearson 相关系数"></a>1. Pearson 相关系数</h3><h4 id="公式-3"><a href="#公式-3" class="headerlink" title="公式"></a>公式</h4><script type="math/tex; mode=display">r=\frac{\sum^n_{t=1}(x_t-\bar{x})(y_t-\bar{y})}{\sqrt{\sum^n_{t=1}(x_t-\bar{x})^2\sum^n_{t=1}(y_t-\bar{y})^2}}</script><p>矩阵形式</p><p>当x、y是行向量时</p><script type="math/tex; mode=display">r=\frac{x_1y_1^T}{\sqrt{(x_1x_1^T)(y_1y_1^T)}}</script><p>其中$x_1$、$y_1$是矩阵x、y的每行分别减去其对应的行均值后的结果</p><p>当x、y是 electrode×time 矩阵时</p><script type="math/tex; mode=display">r=\frac{x_1y_1^T}{\sqrt{diag(x_1x_1^T)diag(y_1y_1^T)^T}}</script><p>其中的分数线表示分子分母矩阵对应<strong>按元素相除</strong>，该公式计算的是数据x、y<strong>行与行之间</strong>的相关系数</p><h4 id="matlab代码实现："><a href="#matlab代码实现：" class="headerlink" title="matlab代码实现："></a>matlab代码实现：</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% a、b中的每行代表一个电极上的数据</span></span><br><span class="line">a = <span class="built_in">randn</span>(<span class="number">4</span>,<span class="number">100</span>);</span><br><span class="line">b = <span class="built_in">randn</span>(<span class="number">4</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">a1=a-<span class="built_in">mean</span>(a,<span class="number">2</span>);</span><br><span class="line">b1=b-<span class="built_in">mean</span>(b,<span class="number">2</span>);</span><br><span class="line">c = [a; b];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Matlab自带函数corrcoef和corr </span></span><br><span class="line">corr1 = corrcoef(c&#x27;);</span><br><span class="line"><span class="comment">% corrcoef计算结果为8×8的矩阵，其中包含a、b与自身各行间的相关系数，将这一部分舍去</span></span><br><span class="line">corr1 = corr1(<span class="number">1</span>:<span class="number">4</span>,<span class="number">5</span>:<span class="number">8</span>);</span><br><span class="line"><span class="comment">% corr函数计算结果为4×4的矩阵</span></span><br><span class="line">corr2 = corr(a&#x27;,b&#x27;,<span class="string">&#x27;type&#x27;</span>,<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Pearson相关系数公式</span></span><br><span class="line">corr3 = <span class="built_in">zeros</span>(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4</span></span><br><span class="line">        corr3(<span class="built_in">i</span>,<span class="built_in">j</span>) = (a1(<span class="built_in">i</span>,:)*b1(<span class="built_in">j</span>,:)&#x27;)/<span class="built_in">sqrt</span>( (a1(<span class="built_in">i</span>,:)*a1(<span class="built_in">i</span>,:)&#x27;)*(b1(<span class="built_in">j</span>,:)*b1(<span class="built_in">j</span>,:)&#x27;) );</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Pearson公式矩阵计算</span></span><br><span class="line">corr4 = a1*b1&#x27;./<span class="built_in">sqrt</span>(<span class="built_in">diag</span>(a1*a1&#x27;)*<span class="built_in">diag</span>(b1*b1&#x27;)&#x27;);</span><br></pre></td></tr></table></figure><h4 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h4><p>对<strong>Pearson相关系数</strong>结果的解释说明建立在数据是<strong>正态分布</strong>的假设前提上</p><h3 id="2-Spearman相关系数"><a href="#2-Spearman相关系数" class="headerlink" title="2. Spearman相关系数"></a>2. Spearman相关系数</h3><p>将Pearson公式中x、y元素的值替换成它们在各自向量中对应的从小到大排列顺序，计算后得到的即为Spearman系数。</p><p>在Matlab中，获取从小到大排列顺序可以由<code>tiedrank</code>实现。例如：对 [10 20 30 40 20] 从最小值到最大值进行计数，两个 20 值分别是第 2 个和第 3 个，因此它们都得到秩 2.5（2 和 3 的平均值）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">tiedrank([<span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">20</span>])</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">    <span class="number">1.0000</span>    <span class="number">2.5000</span>    <span class="number">4.0000</span>    <span class="number">5.0000</span>    <span class="number">2.5000</span> </span><br></pre></td></tr></table></figure><h3 id="3-两种相关系数的适用场景"><a href="#3-两种相关系数的适用场景" class="headerlink" title="3. 两种相关系数的适用场景"></a>3. 两种相关系数的适用场景</h3><ul><li><p>当数据<strong>不是正态分布</strong>或是<strong>存在离群值</strong>时，应该使用<strong>Spearman相关系数</strong>，如果数据正态分布其没有离群值，那么两种相关系数的计算结果相近。而实际的EEG中，time-frequency 功率数据不是正态分布的（见Chap.18），所以通常采用Spearman相关系数。</p></li><li><p>经过baseline-averaged（decibel or percentage change）以及trial averaged的功率数据通常是正态分布的，可以使用Pearson相关系数进行分析。例如一些跨被试的实验分析。</p></li></ul><h3 id="4-Fisher-Z-transform"><a href="#4-Fisher-Z-transform" class="headerlink" title="4. Fisher-Z transform"></a>4. Fisher-Z transform</h3><p>相关系数的计算结果 r 在 [-1,1] 之间分布，可以通过 <strong>Fisher-Z transform</strong> 转化为近似正态分布：</p><script type="math/tex; mode=display">r_{fz}=0.5\times\log(\frac{1+r}{1-r})</script><p>Fisher-Z transform实际上是双曲函数<code>tanh</code>的反函数<code>atanh</code>。</p><h2 id="Power-Correlations-over-Time"><a href="#Power-Correlations-over-Time" class="headerlink" title="Power Correlations over Time"></a>Power Correlations over <strong>Time</strong></h2><h4 id="1-计算步骤"><a href="#1-计算步骤" class="headerlink" title="1. 计算步骤"></a>1. 计算步骤</h4><ul><li><p>选择两个<strong>电极</strong>，对数据进行时频提取</p></li><li><p>选择要计算的<strong>时间段</strong>和<strong>频带</strong>（time-frequency window），两电极的频带不一定要相同</p></li><li><p>计算两个电极在该时间段、频带内功率数据的<strong>相关系数</strong></p></li><li><p>时间段的选取：</p><ul><li>过长无法检测到瞬态变化</li><li>过短数据点太少，结果鲁棒性不强</li><li>至少要比所选频段的一个周期更长</li><li>对任务相关的数据，至少需要2-4个周期</li><li>对静息状态的数据，为提高信噪比，可以将数据分成几个互不重叠的几秒的时间段，分别计算相关系数，最后再平均</li></ul></li><li><p><strong>Cross-correlation | 互相关</strong></p><p>在互相关的计算中，将一个时间序列相对于另一个时间序列进行时间偏移（时移的长度不能大于一个周期），每次时移重复计算一次相关系数，观察是否相关系数存在一个峰值。</p><p>可以通过Matlab中<code>xcov</code>的<code>coeff</code>选项实现，但该函数计算的不是Spearman相关系数，所以使用前要<strong>先用<code>tiedrank</code>函数</strong>对输入数据进行排序</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Compute how many time points are in one cycle, and limit xcov to this lag</span></span><br><span class="line">nlags = <span class="built_in">round</span>(EEG.srate/centerfreq);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用前先用`tiedrank`函数进行排序</span></span><br><span class="line"><span class="comment">% note that data are first tiedrank&#x27;ed, which results in a Spearman rho</span></span><br><span class="line"><span class="comment">% instead of a Pearson r. </span></span><br><span class="line">[corrvals,corrlags] = xcov(tiedrank(<span class="built_in">abs</span>(convolution_result_fft1(:,trial2plot)).^<span class="number">2</span>),tiedrank(<span class="built_in">abs</span>(convolution_result_fft2(:,trial2plot)).^<span class="number">2</span>),nlags,<span class="string">&#x27;coeff&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% convert correlation lags from indices to time in ms</span></span><br><span class="line">corrlags = corrlags * <span class="number">1000</span>/EEG.srate; </span><br></pre></td></tr></table></figure></li></ul><h2 id="Power-Correlation-over-Trials"><a href="#Power-Correlation-over-Trials" class="headerlink" title="Power Correlation over Trials"></a>Power Correlation over Trials</h2><h4 id="1-方法一"><a href="#1-方法一" class="headerlink" title="1. 方法一"></a>1. 方法一</h4><ul><li>选择两个电极，分别对每个电极选择要计算的<strong>时间段</strong>和<strong>频带</strong>，所选择的时频区间不一定要相同</li><li>提取所需时频区间的信号功率，然后对于每一个试次，计算<strong>时频区间内的所有功率的平均值</strong>，得到一个数值</li><li>最后计算两个电极所有试次对应数值间的相关系数</li></ul><h4 id="2-方法二"><a href="#2-方法二" class="headerlink" title="2. 方法二"></a>2. 方法二</h4><ul><li>选择两个电极，分别对每个电极选择要计算的<strong>频带</strong>，所选择的频率不一定要相同</li><li>对每一个时间点，计算一次所有试次间的相关系数，这样可以得到<strong>相关系数随时间变化</strong>的时间序列</li><li>如果选取多个频率，可以绘制出相关系数的 time-frequency map</li></ul><h4 id="3-方法三"><a href="#3-方法三" class="headerlink" title="3. 方法三"></a>3. 方法三</h4><ul><li>以一个电极作为<strong>“seed electrode”</strong>，同时选取一个 <strong>“seed time-frequency window”</strong></li><li>对其他电极、时频区间，计算它们与seed electrode的相关系数。由此可以得到一个相关系数的 time-frequency-electrode map</li></ul><h2 id="Partial-Correlations"><a href="#Partial-Correlations" class="headerlink" title="Partial Correlations"></a>Partial Correlations</h2><p>保持Z不变，计算X和Y之间的偏相关系数，可以消除Z的影响：</p><script type="math/tex; mode=display">r_{xy\cdot z}=\frac{r_{xy}-r_{xz}r_{yz}}{\sqrt{1-r_{xz}^2}\sqrt{1-r_{yz}^2}}</script><ul><li>用于消除体积传导效应的影响：如果X和Y是两个相距几厘米（比较远）的电极，而X和Z是相邻的电极。如果X和Y之间的相关性与Z和Y之间的相关性非常相似，那么X和Z之间可能存在体积传导，可以通过计算偏相关系数消除</li></ul><h2 id="Matlab技巧"><a href="#Matlab技巧" class="headerlink" title="Matlab技巧"></a>Matlab技巧</h2><ul><li><p>进行时频分解后，可以先降采样，再计算相关系数</p></li><li><p>如果数据中没有特殊的值，可以自编代码计算Speaman相关系数，耗时比<code>corr</code>和<code>corrcoef</code>更短。在没有数值相同的数据的情况下，可以用下面的公式计算Spearman相关系数</p><script type="math/tex; mode=display">r=1-\frac{6\sum^n_{t=1}(x_t-y_t)^2}{n(n^2-1)}</script><p>其中，x、y是两组功率数据，t是trial或time，n是trial或time的数目。</p><p>如果对计算速度有更高的要求，可以用最小二乘拟合。</p></li></ul><hr><h1 id="28-Granger-Prediction"><a href="#28-Granger-Prediction" class="headerlink" title="28 | Granger Prediction"></a>28 | Granger Prediction</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul><li><p>Results from Granger causality analyses neither establish nor require causality. </p></li><li><p>Granger Prediction讨论的问题是：如果你知道电极B在过往时间内的活动，那么是否能够预测电极A在未来时间的活动？由此预测出的结果是否会比在只知道电极A在过往时间内活动的条件下预测出的结果更好？如果有统计数据支持“是”，那么可以说B对A存在着Granger预测（Granger因果）效应。</p></li><li><p>在进行Granger prediction前不应该降采样，采样率在250-1000Hz会比较合适</p></li></ul><h2 id="Univariate-Autoregression-单变量自回归"><a href="#Univariate-Autoregression-单变量自回归" class="headerlink" title="Univariate Autoregression | 单变量自回归"></a>Univariate Autoregression | 单变量自回归</h2><ul><li><strong>k阶单变量自回归AR(k)：</strong>用一个变量的时间数列作为<strong>因变量</strong>数列，用同一变量向<strong>过去推移k个时间步长</strong>的时间数列作<strong>自变量</strong>数列</li></ul><script type="math/tex; mode=display">X_t=\sum^k_{n=1}a_nX_{t-n}+e_{xt}</script><ul><li>a是自回归系数，e是每个时间点的误差项</li><li>自回归模型假设时间序列是平稳的（Stationary），即统计特性不随时间改变，这也是使用Granger Prediction的条件</li></ul><h2 id="Bivariate-Autoregression-双变量自回归"><a href="#Bivariate-Autoregression-双变量自回归" class="headerlink" title="Bivariate Autoregression | 双变量自回归"></a>Bivariate Autoregression | 双变量自回归</h2><script type="math/tex; mode=display">X_t=\sum^k_{n-1}a_nX_{t-n}+\sum^k_{n=1}b_nY_{t-n}+e_{xyt}</script><script type="math/tex; mode=display">Y_t=\sum^k_{n-1}c_nY_{t-n}+\sum^k_{n=1}d_nX_{t-n}+e_{yxt}</script><ul><li><p>a、b、c、d是自回归系数，e是拟合误差，如果Y对X的预测值没有影响，即$X_t$公式中不包含Y，那么$e_{xyt}=e_{xt}$</p></li><li><p>Matlab从数据中提取自回归系数可以通过 BSMART Toolbox 中的<code>armorf.m</code>函数</p></li></ul><h2 id="Autoregression-Errors-and-Error-Variances"><a href="#Autoregression-Errors-and-Error-Variances" class="headerlink" title="Autoregression Errors and Error Variances"></a>Autoregression Errors and Error Variances</h2><ul><li><p><strong>误差e越小</strong>，说明回归模型的拟合效果越好。误差的大小可以用误差的方差来衡量。</p></li><li><p><strong>GrangerPrediction的数学定义（从y到x）</strong>：</p><script type="math/tex; mode=display">GrangerPrediction=\ln(\frac{var(e_x)}{var(e_{xy})})</script><p>GrangerPrediction通常是正的，因为多变量自回归的拟合效果通常比单变量自回归的拟合效果更好，如果计算出的GrangerPrediction小于零，需要检查一下模型是否合适、数据是否违反了平稳性。</p><p><strong>GrangerPrediction越大，$e_{xy}$越小，可以认为x和y之间的Connectivity越强。</strong></p></li></ul><h2 id="Granger-Prediction-over-Time"><a href="#Granger-Prediction-over-Time" class="headerlink" title="Granger Prediction over Time"></a>Granger Prediction over Time</h2><p>代码实现：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% load sample EEG data</span></span><br><span class="line">load sampleEEGdata</span><br><span class="line"></span><br><span class="line"><span class="comment">% define channels for granger prediction</span></span><br><span class="line">chan1name = <span class="string">&#x27;o1&#x27;</span>;</span><br><span class="line">chan2name = <span class="string">&#x27;f5&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Granger prediction parameters</span></span><br><span class="line"><span class="comment">% 时间窗口的长度</span></span><br><span class="line">timewin = <span class="number">200</span>; <span class="comment">% in ms</span></span><br><span class="line"><span class="comment">% 自回归拟合阶数（单位是ms）</span></span><br><span class="line">order   =  <span class="number">27</span>; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% temporal down-sample results (but not data!)</span></span><br><span class="line"><span class="comment">% 对结果进行降采样（在计算完GrangerPrediction之后）</span></span><br><span class="line">times2save = <span class="number">-400</span>:<span class="number">20</span>:<span class="number">1000</span>; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert parameters to indices</span></span><br><span class="line">timewin_points = <span class="built_in">round</span>(timewin/(<span class="number">1000</span>/EEG.srate));</span><br><span class="line"><span class="comment">% 把阶数从ms转化为采样点数</span></span><br><span class="line">order_points   = <span class="built_in">round</span>(order/(<span class="number">1000</span>/EEG.srate));</span><br><span class="line"></span><br><span class="line"><span class="comment">% find the index of those channels</span></span><br><span class="line">chan1 = <span class="built_in">find</span>(strcmpi(chan1name,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line">chan2 = <span class="built_in">find</span>(strcmpi(chan2name,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 为提高平稳性，需要减去ERP</span></span><br><span class="line"><span class="comment">% remove ERP from selected electrodes to improve stationarity</span></span><br><span class="line">eegdata = <span class="built_in">bsxfun</span>(@minus,EEG.data([chan1 chan2],:,:),<span class="built_in">mean</span>(EEG.data([chan1 chan2],:,:),<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert requested times to indices</span></span><br><span class="line">times2saveidx = dsearchn(EEG.times&#x27;,times2save&#x27;);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize</span></span><br><span class="line"><span class="comment">% x2y和y2x都是 1×length(times2save) 的零矩阵</span></span><br><span class="line">[x2y,y2x] = deal(<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(times2save))); <span class="comment">% the function deal assigns inputs to all outputs</span></span><br><span class="line">bic = <span class="built_in">zeros</span>(<span class="built_in">length</span>(times2save),<span class="number">15</span>); <span class="comment">% Bayes info criteria (hard-coded to order=15)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> timei=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line"></span><br><span class="line">    <span class="comment">% data from all trials in this time window 提取timewindow内数据（在这里没有降采样）</span></span><br><span class="line">    tempdata = <span class="built_in">squeeze</span>(eegdata(:,times2saveidx(timei)-<span class="built_in">floor</span>(timewin_points/<span class="number">2</span>):times2saveidx(timei)+<span class="built_in">floor</span>(timewin_points/<span class="number">2</span>)-<span class="built_in">mod</span>(timewin_points+<span class="number">1</span>,<span class="number">2</span>),:));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% detrend and zscore all data</span></span><br><span class="line">    <span class="keyword">for</span> triali=<span class="number">1</span>:<span class="built_in">size</span>(tempdata,<span class="number">3</span>)   <span class="comment">% size(tempdata,3)就是EEG.trials</span></span><br><span class="line">        <span class="comment">% detrend：去趋势，去除低频漂移。zscore：使数据均值为0，方差为1</span></span><br><span class="line">        tempdata(<span class="number">1</span>,:,triali) = zscore(detrend(<span class="built_in">squeeze</span>(tempdata(<span class="number">1</span>,:,triali))));</span><br><span class="line">        tempdata(<span class="number">2</span>,:,triali) = zscore(detrend(<span class="built_in">squeeze</span>(tempdata(<span class="number">2</span>,:,triali))));</span><br><span class="line"></span><br><span class="line">        <span class="comment">% At this point with real data, you should check for stationarity</span></span><br><span class="line">        <span class="comment">% and possibly discard or mark data epochs that are extreme stationary violations.</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% reshape tempdata for armorf 把所有trials的数据拼接成一行</span></span><br><span class="line">    tempdata = <span class="built_in">reshape</span>(tempdata,<span class="number">2</span>,timewin_points*EEG.trials);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% fit AR models (model estimation from bsmart toolbox)</span></span><br><span class="line">    <span class="comment">% 计算误差e</span></span><br><span class="line">    [Ax,Ex] = armorf(tempdata(<span class="number">1</span>,:),EEG.trials,timewin_points,order_points);</span><br><span class="line">    [Ay,Ey] = armorf(tempdata(<span class="number">2</span>,:),EEG.trials,timewin_points,order_points);</span><br><span class="line">    [Axy,E] = armorf(tempdata     ,EEG.trials,timewin_points,order_points);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% time-domain causal estimate</span></span><br><span class="line">    <span class="comment">% 计算GrangerPrediction</span></span><br><span class="line">    y2x(timei)=<span class="built_in">log</span>(Ex/E(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    x2y(timei)=<span class="built_in">log</span>(Ey/E(<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% test BIC for optimal model order at each time point</span></span><br><span class="line">    <span class="comment">% (this code is used for the following cell)</span></span><br><span class="line">    <span class="keyword">for</span> bici=<span class="number">1</span>:<span class="built_in">size</span>(bic,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% run model</span></span><br><span class="line">        [Axy,E] = armorf(tempdata,EEG.trials,timewin_points,bici);</span><br><span class="line">        <span class="comment">% compute Bayes Information Criteria</span></span><br><span class="line">        bic(timei,bici) = <span class="built_in">log</span>(det(E)) + (<span class="built_in">log</span>(<span class="built_in">length</span>(tempdata))*bici*<span class="number">2</span>^<span class="number">2</span>)/<span class="built_in">length</span>(tempdata);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% draw lines</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(times2save,x2y)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(times2save,y2x,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(&#123;[ <span class="string">&#x27;GP: &#x27;</span> chan1name <span class="string">&#x27; -&gt; &#x27;</span> chan2name ];[ <span class="string">&#x27;GP: &#x27;</span> chan2name <span class="string">&#x27; -&gt; &#x27;</span> chan1name ]&#125;)</span><br><span class="line">title([ <span class="string">&#x27;Window length: &#x27;</span> num2str(timewin) <span class="string">&#x27; ms, order: &#x27;</span> num2str(order) <span class="string">&#x27; ms&#x27;</span> ])</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Granger prediction estimate&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Model-Order"><a href="#Model-Order" class="headerlink" title="Model Order"></a>Model Order</h2><p>可以通过计算Bayes information criterion（BIC）来确定自回归模型的阶数：</p><script type="math/tex; mode=display">BIC = \ln{(\det{E})}+(2^2m\ln n)n^{-1}</script><p>E是双变量误差矩阵，2是电极数目，m是回归模型阶数，n是时间点数目。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> bici=<span class="number">1</span>:<span class="built_in">size</span>(bic,<span class="number">2</span>)<span class="comment">% bici是回归模型阶数值，</span></span><br><span class="line">，对不同的阶数值，分别计算</span><br><span class="line">        <span class="comment">% run model</span></span><br><span class="line">        [Axy,E] = armorf(tempdata,EEG.trials,timewin_points,bici);</span><br><span class="line">        <span class="comment">% compute Bayes Information Criteria</span></span><br><span class="line">        bic(timei,bici) = <span class="built_in">log</span>(det(E)) + (<span class="built_in">log</span>(<span class="built_in">length</span>(tempdata))*bici*<span class="number">2</span>^<span class="number">2</span>)/<span class="built_in">length</span>(tempdata);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>BIC的值越小越好，但在不同的时间点BIC最小值所对应的阶数可能会不同，因此很难找出一个最优的阶数。</p><h2 id="Frequency-Domain-Granger-Prediction"><a href="#Frequency-Domain-Granger-Prediction" class="headerlink" title="Frequency Domain Granger Prediction"></a>Frequency Domain Granger Prediction</h2><ul><li>计算Frequency domain Granger Prediction时，不能先滤波再计算GrangerPrediction。具体代码实现：</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">min_freq = <span class="number">10</span>; <span class="comment">% in Hz, using minimum of 10 Hz because of 200-ms window</span></span><br><span class="line">max_freq = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">order_points = <span class="number">15</span>;<span class="comment">% 自回归模型阶数</span></span><br><span class="line"></span><br><span class="line">frequencies = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(min_freq),<span class="built_in">log10</span>(max_freq),<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize：2代表 电极1→电极2、电极2→电极1 两个方向的结果</span></span><br><span class="line">tf_granger=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="built_in">length</span>(frequencies),<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> timei=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line"></span><br><span class="line">    <span class="comment">% data from all trials in this time window</span></span><br><span class="line">    <span class="comment">% (note that the ERP-subtracted data are used)</span></span><br><span class="line">    <span class="comment">% eegdata中只保留了两个电极的数据，需要减去ERP</span></span><br><span class="line">    tempdata = <span class="built_in">squeeze</span>(eegdata(:,times2saveidx(timei)-<span class="built_in">floor</span>(timewin_points/<span class="number">2</span>):times2saveidx(timei)+<span class="built_in">floor</span>(timewin_points/<span class="number">2</span>)-<span class="built_in">mod</span>(timewin_points+<span class="number">1</span>,<span class="number">2</span>),:));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% detrend and zscore all data</span></span><br><span class="line">    <span class="keyword">for</span> triali=<span class="number">1</span>:<span class="built_in">size</span>(tempdata,<span class="number">3</span>)</span><br><span class="line">        tempdata(<span class="number">1</span>,:,triali) = zscore(detrend(<span class="built_in">squeeze</span>(tempdata(<span class="number">1</span>,:,triali))));</span><br><span class="line">        tempdata(<span class="number">2</span>,:,triali) = zscore(detrend(<span class="built_in">squeeze</span>(tempdata(<span class="number">2</span>,:,triali))));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% reshape tempdata for armorf</span></span><br><span class="line">    tempdata = <span class="built_in">reshape</span>(tempdata,<span class="number">2</span>,timewin_points*EEG.trials);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% fit AR models</span></span><br><span class="line">    [Ax,Ex] = armorf(tempdata(<span class="number">1</span>,:),EEG.trials,timewin_points,order_points);</span><br><span class="line">    [Ay,Ey] = armorf(tempdata(<span class="number">2</span>,:),EEG.trials,timewin_points,order_points);</span><br><span class="line">    [Axy,E] = armorf(tempdata     ,EEG.trials,timewin_points,order_points);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% code below is adapted from bsmart toolbox function pwcausal.m</span></span><br><span class="line">    <span class="comment">% corrected covariance</span></span><br><span class="line">    eyx = E(<span class="number">2</span>,<span class="number">2</span>) - E(<span class="number">1</span>,<span class="number">2</span>)^<span class="number">2</span>/E(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    exy = E(<span class="number">1</span>,<span class="number">1</span>) - E(<span class="number">2</span>,<span class="number">1</span>)^<span class="number">2</span>/E(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    N = <span class="built_in">size</span>(E,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fi=<span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line"></span><br><span class="line">        <span class="comment">% transfer matrix (note the similarity to Fourier transform) </span></span><br><span class="line">        <span class="comment">% 不理解这样做的原因</span></span><br><span class="line">        H = <span class="built_in">eye</span>(N);</span><br><span class="line">        <span class="keyword">for</span> m = <span class="number">1</span>:order_points</span><br><span class="line">            H = H + Axy(:,(m<span class="number">-1</span>)*N+<span class="number">1</span>:m*N)*<span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*m*<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi)/EEG.srate);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        Hi = inv(H);</span><br><span class="line">        S  = H\E*Hi&#x27;/EEG.srate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">% granger prediction per frequency</span></span><br><span class="line">        tf_granger(<span class="number">1</span>,fi,timei) = <span class="built_in">log</span>( <span class="built_in">abs</span>(S(<span class="number">2</span>,<span class="number">2</span>))/<span class="built_in">abs</span>(S(<span class="number">2</span>,<span class="number">2</span>)-(Hi(<span class="number">2</span>,<span class="number">1</span>)*exy*<span class="built_in">conj</span>(Hi(<span class="number">2</span>,<span class="number">1</span>)))/EEG.srate) );</span><br><span class="line">        tf_granger(<span class="number">2</span>,fi,timei) = <span class="built_in">log</span>( <span class="built_in">abs</span>(S(<span class="number">1</span>,<span class="number">1</span>))/<span class="built_in">abs</span>(S(<span class="number">1</span>,<span class="number">1</span>)-(Hi(<span class="number">1</span>,<span class="number">2</span>)*eyx*<span class="built_in">conj</span>(Hi(<span class="number">1</span>,<span class="number">2</span>)))/EEG.srate) );</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> <span class="comment">% end time loop</span></span><br></pre></td></tr></table></figure><ul><li>自回归模型的阶数过小（小于奈奎斯特频率）会影响Granger Prediction的频率精度</li></ul><h2 id="Time-Series-Covariance-Stationarity"><a href="#Time-Series-Covariance-Stationarity" class="headerlink" title="Time Series Covariance Stationarity"></a>Time Series Covariance Stationarity</h2><ul><li><p>Stationarity is a statistical term that refers to a time series having the same statistical properties over time.</p></li><li><p>Stationarity is an assumption of autoregression model estimation.</p></li><li><p><strong>Methods to make data stationary</strong></p><ul><li><strong>Detrending</strong> and <strong>z-normalization</strong> (subtract the mean and divide by the standard deviation)</li><li>Using <strong>shorter time segments</strong></li><li><strong>Subtracting the ERP</strong> from single trials (non-phase-locked)</li><li>Apply Granger prediction to the <strong>derivative</strong> of the time series, that is, the difference between activity at each time point and the previous time point. </li></ul></li><li><p>评估数据的平稳性：可以用 The Granger Causal Connectivity Analysis toolbox 中的函数<code>cca_kpss</code>和<code>cca_check_cov_stat</code></p></li></ul><h2 id="Baseline-Normalization-of-Granger-Prediction-Results"><a href="#Baseline-Normalization-of-Granger-Prediction-Results" class="headerlink" title="Baseline Normalization of Granger Prediction Results"></a>Baseline Normalization of Granger Prediction Results</h2><ul><li><p>两种baseline normalization方法：</p><ul><li>最终结果减去baseline</li><li>转化为相对于baselined的百分比：<code>100*(x2y-mean(x2y(baseidx(1):baseidx(2))))/mean(x2y(baseidx(1):baseidx(2)))</code></li></ul></li><li><p>The percentage change transform facilitated an interpretation of the patterns of the connectivity that are specifically <strong>task related</strong>. </p></li></ul><hr><h1 id="29-Mutual-Information-互信息"><a href="#29-Mutual-Information-互信息" class="headerlink" title="29 | Mutual Information | 互信息"></a>29 | Mutual Information | 互信息</h1><p> <strong>Mutual information</strong> is a simple but robust framework for quantifying the amount of <strong>shared information between two variables</strong>.</p><h2 id="Entropy-Shannon-entropy-信息熵"><a href="#Entropy-Shannon-entropy-信息熵" class="headerlink" title="Entropy ( Shannon entropy, 信息熵)"></a>Entropy ( Shannon entropy, 信息熵)</h2><p>Shannon entropy 指一个变量包含的信息量</p><h3 id="1-计算一段连续数据的entropy"><a href="#1-计算一段连续数据的entropy" class="headerlink" title="1. 计算一段连续数据的entropy"></a>1. 计算一段连续数据的entropy</h3><script type="math/tex; mode=display">H(X)=-\sum^n_{i=1}p(x_i)\log_2p(x_i)</script><p>在数据的最小值和最大值之间划分n个bin，每个bin内装着符合一定范围的数据，$p(x_i)$代表第i个bin中数据个数占总数据的百分比，H即为entropy的度量。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% number of bin numbers</span></span><br><span class="line">nbins = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% bin data, transform to probability, and eliminate zeros</span></span><br><span class="line">hdat = hist(signal1,nbins(nbini));</span><br><span class="line">hdat = hdat./sum(hdat);</span><br><span class="line">    </span><br><span class="line"><span class="comment">% compute entropy</span></span><br><span class="line"><span class="comment">% eps是matlab中的最小数值分辨率，用来防止出现1og(0)的情况</span></span><br><span class="line">entropyByBinSize = -sum(hdat.*<span class="built_in">log2</span>(hdat+<span class="built_in">eps</span>));</span><br></pre></td></tr></table></figure><p>可以看出，entropy与数据的时间排列无关，只与数据的值的分布有关</p><h3 id="2-确定bin的数目"><a href="#2-确定bin的数目" class="headerlink" title="2. 确定bin的数目"></a>2. 确定bin的数目</h3><ul><li><p>Freedman-Diaconis rule：</p><script type="math/tex; mode=display">nbins = \lceil \frac{\max(x)-\min(x)}{2Q_xn^{-1/3}}\rceil</script><p>其中$Q_x$是数据的四分位数范围（将数据从小到大排列，用排在75%的数据减去排在25%的数据），n是数据点数目</p></li><li><p>Scott ’ s rule：</p><p>用3.5s代替Freedman-Diaconis rule里的2Q，其中s指的是数据的标准差（数据需要正态分布）</p></li><li><p>Sturges ’ s rule：</p><script type="math/tex; mode=display">nbins=1+\log_2n</script></li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">fd_bins      = <span class="built_in">ceil</span>(maxmin_range/(<span class="number">2.0</span>*iqr(signal1)*n^(<span class="number">-1</span>/<span class="number">3</span>))); <span class="comment">% Freedman-Diaconis </span></span><br><span class="line">scott_bins   = <span class="built_in">ceil</span>(maxmin_range/(<span class="number">3.5</span>*std(signal1)*n^(<span class="number">-1</span>/<span class="number">3</span>))); <span class="comment">% Scott</span></span><br><span class="line">sturges_bins = <span class="built_in">ceil</span>(<span class="number">1</span>+<span class="built_in">log2</span>(n)); <span class="comment">% Sturges</span></span><br></pre></td></tr></table></figure><ul><li>对同一组分析，nbins的值要保持一致，如果有多个变量，可以分别计算合适的nbins值，最后取平均值作为所有变量的nbins</li></ul><h3 id="3-对Entropy的理解"><a href="#3-对Entropy的理解" class="headerlink" title="3. 对Entropy的理解"></a>3. 对Entropy的理解</h3><ul><li><p>熵是对不确定性的一种度量方法。更高的熵表明该系统可以具有<strong>更多的状态或取值</strong>。</p></li><li><p>entropy可以over time也可以over trial计算，而且因为它不受时间排列的影响，所以也可以把所有time和trial的数据合成一组数据计算。</p></li></ul><h3 id="4-Joint-Entropy-联合熵"><a href="#4-Joint-Entropy-联合熵" class="headerlink" title="4. Joint Entropy | 联合熵"></a>4. Joint Entropy | 联合熵</h3><script type="math/tex; mode=display">H(X,Y)=-\sum^m_{j=1}\sum^n_{i=1}p(x_i,y_y)\log_2p(x_i,y_i)</script><p>$p(x_i,y_i)$是在 $signal_1$ 中落在第$x_i$个 bin 且在 $signal_2$ 中落在第 $y_2$ 个 bin 的点的概率（看下面的代码会比较好理解）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 分别计算每组数据需要的bins的数目，最后取平均值作为使用的bins数目</span></span><br><span class="line"><span class="comment">% determine the optimal number of bins for each variable</span></span><br><span class="line">n            = <span class="built_in">length</span>(signal1);</span><br><span class="line">maxmin_range = <span class="built_in">max</span>(signal1)-<span class="built_in">min</span>(signal1);</span><br><span class="line">fd_bins1     = <span class="built_in">ceil</span>(maxmin_range/(<span class="number">2.0</span>*iqr(signal1)*n^(<span class="number">-1</span>/<span class="number">3</span>))); <span class="comment">% Freedman-Diaconis </span></span><br><span class="line"></span><br><span class="line">n            = <span class="built_in">length</span>(signal2);</span><br><span class="line">maxmin_range = <span class="built_in">max</span>(signal2)-<span class="built_in">min</span>(signal2);</span><br><span class="line">fd_bins2     = <span class="built_in">ceil</span>(maxmin_range/(<span class="number">2.0</span>*iqr(signal2)*n^(<span class="number">-1</span>/<span class="number">3</span>))); <span class="comment">% Freedman-Diaconis </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 取均值</span></span><br><span class="line"><span class="comment">% and use the average...</span></span><br><span class="line">fd_bins = <span class="built_in">ceil</span>((fd_bins1+fd_bins2)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 将 signal1 和 signal2 分箱。每个信号的数值范围会被分成 fd_bins 个区间（bin）</span></span><br><span class="line"><span class="comment">% [bincounts,ind] = histc(x,binranges), ind存储的是每个index上的数据被放在了哪一个bin里</span></span><br><span class="line"><span class="comment">% bin data (using histc this time)</span></span><br><span class="line">edges = <span class="built_in">linspace</span>(<span class="built_in">min</span>(signal1),<span class="built_in">max</span>(signal1),fd_bins+<span class="number">1</span>);</span><br><span class="line">[nPerBin1,bins1] = histc(signal1,edges);</span><br><span class="line"></span><br><span class="line">edges = <span class="built_in">linspace</span>(<span class="built_in">min</span>(signal2),<span class="built_in">max</span>(signal2),fd_bins+<span class="number">1</span>);</span><br><span class="line">[nPerBin2,bins2] = histc(signal2,edges);</span><br><span class="line"></span><br><span class="line"><span class="comment">% compute joint frequency table</span></span><br><span class="line">jointprobs = <span class="built_in">zeros</span>(fd_bins);</span><br><span class="line"><span class="keyword">for</span> i1=<span class="number">1</span>:fd_bins</span><br><span class="line">    <span class="keyword">for</span> i2=<span class="number">1</span>:fd_bins</span><br><span class="line">        <span class="comment">% 计算在 signal1 中落在第 i1 个 bin 且在 signal2 中*对应位置的点*落在第 i2 个 bin 的点的数量</span></span><br><span class="line">        <span class="comment">% 注意与 sum(bins1==i1)+sum(bins2==i2) 不同</span></span><br><span class="line">        <span class="comment">% bins1==i1 和 bins2==i2 分别是两组布尔向量1和2，bins1==i1 &amp; bins2==i2是布尔向量3，</span></span><br><span class="line">        <span class="comment">% 当1和2中对应位置的元素都为1时，3中对应位置的元素才是1</span></span><br><span class="line">        jointprobs(i1,i2) = sum(bins1==i1 &amp; bins2==i2);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 进行归一化，使联合频率表中的值变为概率，整个矩阵的总和为 1</span></span><br><span class="line">jointprobs=jointprobs./sum(jointprobs(:));</span><br></pre></td></tr></table></figure><h2 id="Mutual-Information"><a href="#Mutual-Information" class="headerlink" title="Mutual Information"></a>Mutual Information</h2><h3 id="1-计算公式"><a href="#1-计算公式" class="headerlink" title="1. 计算公式"></a>1. 计算公式</h3><script type="math/tex; mode=display">MI(X,Y)=H(X)+H(Y)-H(X,Y)</script><p>mutual information 不能区分线性和非线性、正相关和负相关等两个变量形状之间的关系</p><h3 id="2-所需数据点的数目"><a href="#2-所需数据点的数目" class="headerlink" title="2. 所需数据点的数目"></a>2. 所需数据点的数目</h3><p>数据点数目越少，对entropy和mutual information的计算值就越偏大：</p><script type="math/tex; mode=display">\Delta H=\frac{bins-1}{2Nln2}</script><script type="math/tex; mode=display">\Delta MI=\frac{(bins-1)^2}{2N\ln2}</script><h2 id="Lagged-Mutual-Information"><a href="#Lagged-Mutual-Information" class="headerlink" title="Lagged Mutual Information"></a>Lagged Mutual Information</h2><p>把一组数据相对于另一组数据进行时移，这样计算出的互信息可以反映有向的功能连接</p><hr><h1 id="30-Cross-Frequency-Coupling"><a href="#30-Cross-Frequency-Coupling" class="headerlink" title="30 | Cross-Frequency Coupling"></a>30 | Cross-Frequency Coupling</h1><p>Cross-frequency coupling analyses require both the <strong>high temopral resolution and temporal precision</strong>.</p><h2 id="A-Priori-Phase-Amplitude-Coupling-PAC"><a href="#A-Priori-Phase-Amplitude-Coupling-PAC" class="headerlink" title="A Priori Phase-Amplitude Coupling (PAC)"></a>A Priori Phase-Amplitude Coupling (PAC)</h2><p>the phase of one frequency band ⬌ the power of another frequency band (typically higher)</p><h3 id="区分："><a href="#区分：" class="headerlink" title="区分："></a>区分：</h3><ul><li>a <strong>priori</strong> phase-amplitude coupling：在先验假设的前提下，已经确定了要检验的两个频带</li><li><strong>mixed a priori/exploratory</strong> phase-amplitude coupling ：已确定一个频带，对其他频带进行探索性分析</li><li>exploratory phase-amplitude coupling：两个频带都没有确定</li></ul><h3 id="PAC的计算："><a href="#PAC的计算：" class="headerlink" title="PAC的计算："></a>PAC的计算：</h3><p>和wITPC类似，只不过使用的weight（$a_t$）是某一频带的power（原始数据，未经baseline normalization），而欧拉公式中的phase（$\phi_t$）是另一个待分析频带的phase</p><script type="math/tex; mode=display">PAC=\left|n^{-1}\sum^n_{t=1}a_te^{i\phi_t}\right|</script><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">obsPAC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(pwr.*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase)));</span><br></pre></td></tr></table></figure><h3 id="PAC-Z"><a href="#PAC-Z" class="headerlink" title="$PAC_Z$"></a>$PAC_Z$</h3><ul><li><strong>零假设下的PAC值分布</strong>：打乱power的时间顺序（随机置换），计算得一个PAC，重复多次，由此计算出的所有PAC的分布构成零假设下的PAC分布。</li><li><strong>$PAC_Z$</strong>：将前面计算观测得到的一个PAC值 减去 零假设下PAC分布的平均值，再除以 零假设下PAC分布的标准差，则可以得到$PAC_Z$</li><li>归一化后的PAC值（$PAC_Z$）不会受功率的大小影响，也不受离群值影响，且便于统计分析。</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 计算观测得到的一个PAC值</span></span><br><span class="line">obsPAC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(pwr.*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase)));</span><br><span class="line"><span class="comment">% 随机置换的次数</span></span><br><span class="line">num_iter = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">% 每随机置换一次，计算得到的PAC值</span></span><br><span class="line">permutedPAC = <span class="built_in">zeros</span>(<span class="number">1</span>,num_iter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:num_iter</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% select random time point</span></span><br><span class="line">    random_timepoint = randsample(<span class="built_in">round</span>(<span class="built_in">length</span>(eeg)*<span class="number">.8</span>),<span class="number">1</span>)+<span class="built_in">round</span>(<span class="built_in">length</span>(eeg)*<span class="number">.1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% shuffle power</span></span><br><span class="line">    timeshiftedpwr = [ pwr(random_timepoint:<span class="keyword">end</span>) pwr(<span class="number">1</span>:random_timepoint<span class="number">-1</span>) ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% compute PAC</span></span><br><span class="line">    permutedPAC(<span class="built_in">i</span>) = <span class="built_in">abs</span>(<span class="built_in">mean</span>(timeshiftedpwr.*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% compute PACz</span></span><br><span class="line">pacz = (obsPAC-<span class="built_in">mean</span>(permutedPAC))/std(permutedPAC);</span><br></pre></td></tr></table></figure><ul><li><p>随机置换时间顺序的方法：</p><ul><li><p>在某个随机时间点截断数据，交换两段数据</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Permutation method 1: select random time point</span></span><br><span class="line">random_timepoint = randsample(<span class="built_in">round</span>(<span class="built_in">length</span>(eeg)*<span class="number">.8</span>),<span class="number">1</span>)+<span class="built_in">round</span>(<span class="built_in">length</span>(eeg)*<span class="number">.1</span>);</span><br><span class="line">timeshiftedpwr   = [ pwr(random_timepoint:<span class="keyword">end</span>) pwr(<span class="number">1</span>:random_timepoint<span class="number">-1</span>) ];</span><br><span class="line">permutedPAC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(timeshiftedpwr.*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase)));</span><br></pre></td></tr></table></figure></li><li><p>（不推荐）直接打乱时间</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Permutation method 2: totally randomize power time series</span></span><br><span class="line">permutedPAC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(pwr(randperm(<span class="built_in">length</span>(pwr))).*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase)));</span><br></pre></td></tr></table></figure></li><li><p>先对数据进行FFT，打乱FFT后所得数据的相位，再ifft</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Permutation method 3: FFT-based power time series randomization</span></span><br><span class="line">f = fft(pwr); <span class="comment">% compute FFT</span></span><br><span class="line">A = <span class="built_in">abs</span>(f);   <span class="comment">% extract amplitudes</span></span><br><span class="line">zphs=<span class="built_in">cos</span>(<span class="built_in">angle</span>(f))+<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">sin</span>(<span class="built_in">angle</span>(f)); <span class="comment">% extract phases</span></span><br><span class="line">   powernew=<span class="built_in">real</span>(ifft(A.*zphs(randperm(<span class="built_in">length</span>(zphs))))); <span class="comment">% recombine using randomized phases (note: use original phases to prove that this method reconstructs the original signal)</span></span><br><span class="line">powernew=powernew-<span class="built_in">min</span>(powernew);</span><br><span class="line">    </span><br><span class="line">permutedPAC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(powernew.*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase)));</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://s2.loli.net/2024/09/29/Az3yEu7c4GMsafj.png" alt="image-20240921182504988" style="zoom: 33%;" /></p><h2 id="Separating-Task-Related-Phase-and-Power-Coactivations-from-Phase-Amplitude-Coupling"><a href="#Separating-Task-Related-Phase-and-Power-Coactivations-from-Phase-Amplitude-Coupling" class="headerlink" title="Separating Task-Related Phase and Power Coactivations from Phase-Amplitude Coupling"></a>Separating Task-Related Phase and Power Coactivations from Phase-Amplitude <strong>Coupling</strong></h2><p>指的是当我们发现某频带的幅值和另一频带的相位存在幅相耦合时，我们应该如何判断它们之间究竟是真的存在耦合关系，还是它们独立地对刺激等任务作出了相同的<strong>time-locked</strong>响应。</p><p>当phase是time-locked时，相应的ITPC值应当较大。因此，我们应该尽可能避免在ITPC值较大的时间段内使用PAC，也可以从数据中减去ERP，去除相位锁定的成分，再计算PAC</p><h2 id="Mixed-A-Priori-Exploratory-Phase-Amplitude-Coupling"><a href="#Mixed-A-Priori-Exploratory-Phase-Amplitude-Coupling" class="headerlink" title="Mixed A Priori/Exploratory Phase-Amplitude Coupling"></a><strong>Mixed A Priori/Exploratory Phase-Amplitude Coupling</strong></h2><p>已确定一个频率，对其他频率进行探索性分析，即在 lower frequency for phase 和 upper frequency for power 中，选一个作为 priori band，另一个则为 exploratory band to find that <strong>the strongest coupling</strong> with the other frequency can be observed.</p><p>所以可以固定一个频率，遍历另一频率，对每一种组合计算一次$PAC_Z$，找到使$PAC_Z$最大的频率组合。但是找到这一对频率后，再对这两个频率计算出的PAC值使用p-value去解释其显著性就不太合适了，因为在这里我们已经发现它们在所有频率组合中是相关性最强的。</p><h2 id="Exploratory-Phase-Amplitude-Coupling"><a href="#Exploratory-Phase-Amplitude-Coupling" class="headerlink" title="Exploratory Phase-Amplitude Coupling"></a>Exploratory Phase-Amplitude Coupling</h2><p>两个频率都没有确定，对每一对频率组合都计算一次$PAC_Z$，计算量较大</p><hr><h1 id="31-Graph-Theory"><a href="#31-Graph-Theory" class="headerlink" title="31 | Graph Theory"></a>31 | Graph Theory</h1><h2 id="Networks-as-Matrices-and-Graphs"><a href="#Networks-as-Matrices-and-Graphs" class="headerlink" title="Networks as Matrices and Graphs"></a>Networks as Matrices and Graphs</h2><p><img src="https://s2.loli.net/2024/09/29/z9ThX3CskrKGLyR.png" alt="image-20240922155519508" style="zoom:50%;" /></p><p>An EEG all-to-all connectivity matrix, is one slice of a 5-D hypercube (electrodes - electrodes - time - frequency - condition)</p><p><img src="https://s2.loli.net/2024/09/29/b1UYfhuqBDWOIg6.png" alt="image-20240922155627509" style="zoom: 50%;" /></p><h2 id="Thresholding-Connectivity-Matrices"><a href="#Thresholding-Connectivity-Matrices" class="headerlink" title="Thresholding Connectivity Matrices"></a>Thresholding Connectivity Matrices</h2><ol><li>choose a threshold value</li><li>threshold value 以上的设为1（或保留原值），以下的设为0</li></ol><p>常用的 threshold value 选择方法：</p><ul><li>比connectivity的中值高一个标准差</li><li>保留前k个最大的connectivity</li></ul><h2 id="Connectivity-Degree"><a href="#Connectivity-Degree" class="headerlink" title="Connectivity Degree"></a>Connectivity Degree</h2><ul><li><p>Connectivity Degree 反映了某一电极作为“枢纽”的程度</p></li><li><p>计算方法：对某一电极，<strong>除自己以外的</strong>所有大于threshold value的connectivity数目。最后可以将结果除以“电极数目减一”，转化为百分比。</p></li><li><p>最终所得结果是一个 1×electrodes 的数值矩阵，可以用topographical map表示</p></li></ul><h2 id="Clustering-Coefficient-聚集系数"><a href="#Clustering-Coefficient-聚集系数" class="headerlink" title="Clustering Coefficient | 聚集系数"></a>Clustering Coefficient | 聚集系数</h2><ul><li><p>Clustering Coefficient 指的是在所有与电极A的connectivity大于threshold的电极中，有多少电极它们彼此之间的connectivity也在阈值之上。（你的朋友中有多少人彼此之间也同样是朋友）</p></li><li><p>计算公式</p><script type="math/tex; mode=display">clustcoef_i=\frac{\sum_{k=1}^{n}\sum_{j=k}^n v_{ij}}{n_i}</script><p>其中，i是电极，k,j是与i的connectivity大于阈值的电极，如果电极k和j之间的connectivity大于阈值，则$v_{ij}$是1，否则是0，因此分子即为包含电极i的三角形数目。分母$n_i$是电极 i 的Connectivity degree。如果degree为1，则cluster coefficient为0</p></li></ul><p><img src="https://s2.loli.net/2024/09/29/5hNdbzIXxQBJqFE.png" alt="image-20240922173157359" style="zoom: 67%;" /></p><h2 id="Path-Length-平均路径长度"><a href="#Path-Length-平均路径长度" class="headerlink" title="Path Length | 平均路径长度"></a>Path Length | 平均路径长度</h2><ul><li>Path Length 是某个电极（node）到其他电极的平均距离</li></ul><p><img src="https://s2.loli.net/2024/09/29/1PFIRjtMogdQqnr.png" alt="image-20240922185239163" style="zoom:67%;" /></p><h2 id="Small-World-Networks-小世界网络"><a href="#Small-World-Networks-小世界网络" class="headerlink" title="Small-World Networks | 小世界网络"></a>Small-World Networks | 小世界网络</h2><p><a href="https://www.nature.com/articles/30918">Collective dynamics of ‘small-world’ networks | Nature</a></p><p>Small-World Networks: high clustering coeffecience and low path length. When rewiring (transition from regular to random), path length drops faster than clustering coefficient.</p><p><img src="https://s2.loli.net/2024/09/29/3LlDW4zfQ8aeVpj.png" alt="image-20240922192001275" style="zoom:50%;" /></p><p>判断是否为Small-World Networks：</p><script type="math/tex; mode=display">swn=\frac{C/C_r}{L/L_r}</script><p>分子分母 分别是 <strong>当前图</strong>和<strong>random图</strong>(Erdős-Rényi random graphs)的<strong>平均clustering coefficient / path length比值</strong>。如果<strong>swn大于1</strong>，可以认为当前网络具有小世界网络的特征。</p><hr><h1 id="32-Advantages-and-Limitations-of-Different-Statistical-Procedures"><a href="#32-Advantages-and-Limitations-of-Different-Statistical-Procedures" class="headerlink" title="32 | Advantages and Limitations of Different Statistical Procedures"></a>32 | Advantages and Limitations of Different Statistical Procedures</h1><h2 id="Level-the-unit-of-data"><a href="#Level-the-unit-of-data" class="headerlink" title="Level: the unit of data"></a><strong>Level</strong>: the <strong>unit</strong> of data</h2><ul><li><strong>Within subject statistics (level-1)</strong>: consider the <strong>trial</strong> to be the unit for analysis. Recommended when having many trials from a small number of subjects. </li><li><strong>Group-level statistics (level-2)</strong>: consider the <strong>subject</strong> to be the unit for analysis</li></ul><h2 id="P-Value"><a href="#P-Value" class="headerlink" title="P-Value"></a>P-Value</h2><ul><li>通常情况下，p-Value&lt;0.05可以被认为是显著的</li><li>p-Value的最后一位小数通常是5或1，如果p=0.323会比较奇怪</li><li>对hypothesis-driven rearch，对p值的要求没那么严格，通常p=0.05就足够了，但对于exploratory analyses，需要对p值进行更严格的设置，或者结合multiple-comparisons corrections使用</li><li>p-Value的缺点：based on the number of data points，如果data points足够，很小的effects也可以有很小的p-value，反之，如果数据点少，即使effects很大，p-Value也可能很大</li></ul><h2 id="Multiple-Comparisons-Corrections-多重比较"><a href="#Multiple-Comparisons-Corrections-多重比较" class="headerlink" title="Multiple-Comparisons Corrections | 多重比较"></a>Multiple-Comparisons Corrections | 多重比较</h2><ul><li>Bonferroni correction: assumes that the tests are independent of each other, and corrects for the number of tests, not the amount of information available in those tests.</li><li>nonparametric permutation testing provides an appropriate control for multiple comparisons. </li></ul><h2 id="Type-I-and-Type-II-Errors"><a href="#Type-I-and-Type-II-Errors" class="headerlink" title="Type I and Type II Errors"></a>Type I and Type II Errors</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><strong>第一类错误（Type I Error）</strong>和<strong>第二类错误（Type II Error）</strong>是统计学中的两种常见错误类型，通常出现在假设检验的过程中。</p><ol><li><p><strong>第一类错误（Type I Error）</strong>：也称为<strong>假阳性错误</strong>，是指<strong>错误地拒绝了原假设（即 ( $H_0$ ) ）</strong>，也就是说，实际原假设是真实的，但我们在统计检验中认为它是假的。第一类错误的概率通常用 ( $\alpha$ ) （显著性水平）来表示。</p></li><li><p><strong>第二类错误（Type II Error）</strong>：也称为<strong>假阴性错误</strong>，是指<strong>错误地接受了原假设</strong>，也就是说，实际原假设是假的，但我们在统计检验中没有拒绝它。第二类错误的概率通常用 ( $\beta$ ) 来表示，1-$\beta$ 称为检验的<strong>统计功效（Power）</strong>。</p></li></ol><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h3><ul><li><strong>第一类错误</strong>：你认为有新发现（拒绝了原假设），但实际上没有（即原假设是真实的）。  </li><li><strong>第二类错误</strong>：你认为没有新发现（接受了原假设），但实际上有（即原假设是假的）。</li></ul><h3 id="3-图示"><a href="#3-图示" class="headerlink" title="3. 图示"></a>3. 图示</h3><div class="table-container"><table><thead><tr><th>实际情况 \ 检验结果</th><th>拒绝 ( $H_0$ ) （认为有新发现）</th><th>接受 ($ H_0$ ) （认为无新发现）</th></tr></thead><tbody><tr><td>( $H_0$ ) 真</td><td><strong>第一类错误</strong></td><td>正确决定</td></tr><tr><td>( $H_0$ ) 假</td><td>正确决定</td><td><strong>第二类错误</strong></td></tr></tbody></table></div><h3 id="4-例子"><a href="#4-例子" class="headerlink" title="4. 例子"></a>4. 例子</h3><p>假设你在不同的脑区测量α波段功率，比较安静状态和任务状态下的某个特定频段的EEG功率差异。</p><ul><li><strong>第一类错误</strong>：你发现两种状态下的α波功率存在显著差异，但实际上这是由于噪声或偶然性引起的，这两个条件实际上没有差异。</li><li><strong>第二类错误</strong>：实际情况下，安静状态下的α波功率显著高于任务状态，但由于数据的噪声、实验设计或其他因素，你没有检测到这个差异，得出两者功率相同的结论。</li></ul><p><img src="https://s2.loli.net/2024/09/29/xb1AGifyz7t8oag.png" alt="image-20240926202022307" style="zoom:67%;" /></p><h3 id="5-两种错误发生概率的关系"><a href="#5-两种错误发生概率的关系" class="headerlink" title="5. 两种错误发生概率的关系"></a>5. 两种错误发生概率的关系</h3><ul><li><p>$\alpha$ 和 $\beta$ 的关系：如上图中灰色虚线（$\alpha$ threshold）所示，$\alpha$ 增大， $\beta$ 就会相应减小。</p></li><li><p>对于exploratory的研究，我们希望第一类错误发生的概率$\alpha$小一些；对于 hypothesis-driven的研究，我们希望第二类错误发生的概率$\beta$小一些</p></li></ul><h2 id="如何选择统计方法"><a href="#如何选择统计方法" class="headerlink" title="如何选择统计方法"></a>如何选择统计方法</h2><ul><li>parametric statistics: assuming that data were drawn from <strong>a known distribution</strong> (like Gaussian distribution)</li><li><p>nonparametric statistics: <strong>no assumption is made about the population distribution</strong> from which the data were drawn. Often use <strong>permutation testing</strong>.</p></li><li><p>如果数据不是正态分布的，而又需要使用参数统计，可以先对数据进行处理，比如对于时频数据，进行baseline correction，对于PAC，进行permutation testing</p></li></ul><hr><h1 id="33-Nonparametric-Permutation-Testing-非参数置换检验"><a href="#33-Nonparametric-Permutation-Testing-非参数置换检验" class="headerlink" title="33 | Nonparametric Permutation Testing 非参数置换检验"></a>33 | Nonparametric Permutation Testing 非参数置换检验</h1><h2 id="Creating-a-Null-Hypothesis-Distribution"><a href="#Creating-a-Null-Hypothesis-Distribution" class="headerlink" title="Creating a Null-Hypothesis Distribution"></a>Creating a Null-Hypothesis Distribution</h2><ul><li>离散条件下的零假设：<ul><li>情景：有两种离散的condition（A和B），要验证的假说是A条件下的EEG activity比B大。</li><li>零假设：两种条件下的EEG没有差别。即，如果我把每一个数据点随机地看作是条件A或条件B下的（也可以随机地交换条件A和B下的数据），所使用的检验统计量也不会发生改变。</li></ul></li><li>连续条件下的零假设<ul><li>如果A和B是两个连续的变量，在零假设下，保持一个变量A不变，改变另一个变量B，检验统计量（如相关系数）不会发生改变</li></ul></li></ul><p><img src="https://s2.loli.net/2024/09/29/3IhT9wXoSlpK2RC.png" alt="image-20240926220347777" style="zoom:50%;" /></p><ul><li>重复上面的随机置换步骤，每置换一次可以计算出一个统计检验量，最终就可以得到在零假设下检验统计量的分布。</li><li>将我们在实验中观测得的检验统计量与零假设下的检验统计量分布相比较<ul><li>如果在零假设的分布内，不能拒绝原假设</li><li>如果far enough away from the null-hypothesis distribution，即在零假设下几乎不可能发生，那么可以拒绝原假设，即认为两种条件下的被检验量存在显著的差异。</li></ul></li></ul><h2 id="Determining-Statistical-Significance"><a href="#Determining-Statistical-Significance" class="headerlink" title="Determining Statistical Significance"></a>Determining Statistical Significance</h2><ul><li><p>p值的计算（两种方法）</p><ul><li><p>在<strong>零假设下</strong>所有比所观测到的检验统计量<strong>更极端</strong>的数据之和 除以 <strong>零假设下的总数据</strong></p><script type="math/tex; mode=display">p-Value=\frac{n_{v>v_e}}{n}</script></li><li><p>先将观测到的统计量转化为Z value</p><script type="math/tex; mode=display">Z=\frac{v_e-\overline{V_n}}{std(V_n)}</script><p>然后再根据其在Gaussian分布中的位置计算p值</p></li></ul></li></ul><h2 id="Multiple-Comparisons-多重比较"><a href="#Multiple-Comparisons-多重比较" class="headerlink" title="Multiple Comparisons | 多重比较"></a>Multiple Comparisons | 多重比较</h2><p><a href="https://www.math.pku.edu.cn/teachers/lidf/course/mvr/mvrnotes/html/_mvrnotes/multcomp.html">多重比较 | 多元统计分析讲义 (pku.edu.cn)</a></p><h3 id="1-所讨论的问题"><a href="#1-所讨论的问题" class="headerlink" title="1. 所讨论的问题"></a>1. 所讨论的问题</h3><p>多次进行检验， 如果每次检验的第一类错误概率是$\alpha$， 各次检验独立， 则检验$m$次， 在所有零假设都成立的情况下至少犯一次第一类错误的概率为</p><script type="math/tex; mode=display">1-(1-\alpha)^m</script><p>可以发现，检验的次数越多（m越大），犯第一类错误的概率越大。如何避免这种问题？</p><h3 id="2-Bonferroni-correction"><a href="#2-Bonferroni-correction" class="headerlink" title="2. Bonferroni correction"></a>2. Bonferroni correction</h3><ul><li>Divide the p-value threshold by the number of tests that will be evaluated.</li><li>If you have three statistical tests, the p-value significance threshold per test is <strong>0.05/3=0.016667</strong></li></ul><h3 id="3-correcting-for-multiple-comparisons-within-the-framework-of-nonparametric-permutation-testing"><a href="#3-correcting-for-multiple-comparisons-within-the-framework-of-nonparametric-permutation-testing" class="headerlink" title="3. correcting for multiple comparisons within the framework of nonparametric permutation testing"></a>3. correcting for multiple comparisons within the framework of nonparametric permutation testing</h3><ul><li>修正前：<strong>每个时频点</strong>有自己的统计值，基于这些值在每个时频点下生成<strong>原假设分布</strong></li><li>修正后：基于<strong>整个时频图</strong>生成原假设分布</li></ul><h3 id="4-Pixel-based-multiple-comparisons-correction"><a href="#4-Pixel-based-multiple-comparisons-correction" class="headerlink" title="4. Pixel-based multiple-comparisons correction"></a>4. Pixel-based multiple-comparisons correction</h3><p>步骤</p><ul><li>对每个时频点进行置换检验，计算p值，把<strong>整个时频图遍历一遍</strong>后，保留绝对值最大（最极端）的p值（如果是双侧检验，需保留最大和最小值）</li><li>重复上面的计算，得到一组最大/最小p值分布</li><li>对于双侧检验，以2.5%和97.5%处的p值作为阈值；对于单侧检验，以5%或95%处的p值作为阈值</li></ul><h3 id="5-Corrections-for-Multiple-Comparisons-Using-Cluster-Based-Statistics"><a href="#5-Corrections-for-Multiple-Comparisons-Using-Cluster-Based-Statistics" class="headerlink" title="5. Corrections for Multiple Comparisons Using Cluster-Based Statistics"></a>5. Corrections for Multiple Comparisons Using Cluster-Based Statistics</h3><ul><li>Because of autocorrelation in the data, a finding is significant if it is “ big enough, ” that is, if enough neighboring pixels also have suprathreshold values. Individual pixels that are significant are therefore considered false alarms. 单个、没有聚集的显著时频点可能是有问题的</li><li>步骤<ul><li>每个时频点生成一个零假设分布</li><li>threshold每个时频点的检验统计量（该threshold需自己设置，称为precluster threshold），生成一张map</li><li>识别map中的cluster，可以用Matlab函数<code>bwlabeln</code>或<code>bwconncomp</code></li><li>选择指标（聚集点数目和统计参数之和，或其他）最大的一个cluster，保存该指标</li><li>重复上述步骤，得到指标的一组分布，以分布的95%位置处的值作为cluster threshold</li></ul></li></ul><hr><h1 id="34-Within-Subject-Statistical-Analyses"><a href="#34-Within-Subject-Statistical-Analyses" class="headerlink" title="34 | Within-Subject Statistical Analyses"></a>34 | Within-Subject Statistical Analyses</h1>]]></content>
      
      
      <categories>
          
          <category> Neural </category>
          
          <category> Analyzing Neural Time Series Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
            <tag> Neural </tag>
            
            <tag> 数字信号处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记 | 系统模型、分析与控制</title>
      <link href="/post/c9daa1a1.html"/>
      <url>/post/c9daa1a1.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/10/15/gW6m7MFAe48kb5T.jpg" alt="Untitled" style="zoom: 33%;" /></p><h1 id="一、控制系统介绍"><a href="#一、控制系统介绍" class="headerlink" title="一、控制系统介绍"></a><strong>一、控制系统介绍</strong></h1><p><img src="https://s2.loli.net/2024/10/15/fPi2dFuaqtmU6VQ.png" alt="image-20241015093406434" style="zoom:50%;" /></p><ul><li><strong>闭环控制的主要特点：1. 检测偏差；2.根据偏差调整控制量，从而减小或消除偏差</strong></li><li>被控对象、被控变量、控制信号、过程、扰动、反馈控制</li><li>开环控制的优缺点</li><li>闭环控制的优缺点</li><li>考点：判断某系统是否是反馈控制系统</li></ul><h1 id="二、Laplace变换"><a href="#二、Laplace变换" class="headerlink" title="二、Laplace变换"></a><strong>二、Laplace变换</strong></h1><ul><li><p>会用公式就行</p><p><img src="https://s2.loli.net/2024/10/15/JyA3aEWx2eUP8iZ.png" alt="image-20241015093455248" style="zoom:50%;" /></p></li></ul><h1 id="三、机械和电气系统建模"><a href="#三、机械和电气系统建模" class="headerlink" title="三、机械和电气系统建模"></a><strong>三、机械和电气系统建模</strong></h1><ul><li><p><strong>质量-弹簧-阻尼系统</strong></p><p><img src="https://s2.loli.net/2024/10/15/dDnYbWuE7iKQzIw.png" alt="image-20241015093523691" style="zoom: 67%;" /></p><ul><li><p><strong>为什么不考虑重力（没有mg项）</strong>：因为是以静止状态下的平衡工作点（无外部输入）作为零点，此时重力已经被弹簧的拉力平衡掉了</p></li><li><p>其他的机械系统可以用同样的方法进行分析</p><p><img src="https://s2.loli.net/2024/10/15/r8eNCLjtuOyiqHo.png" alt="image-20241015093615701" style="zoom:67%;" /></p></li></ul></li><li><p>机械传动系统：平动-转动系统、齿轮传动系统</p></li><li><p><strong>电气系统</strong></p><ul><li><p>电阻：$u(t)=Ri(t)$</p><p>电容：$u(t)=\frac{1}{C}\int i(t)dt$ 或 $i(t)=C\frac{\mathrm{d} u(t)}{\mathrm{d} t}$</p><p>电感：$u(t)=\frac{1}{C}\frac{\mathrm{d} i(t)}{\mathrm{d} t}$</p></li><li><p>列KCL、KVL方程求解</p></li><li><p><strong>复阻抗法：</strong></p><p>电阻：$Z=R$</p><p>电容：$Z=\frac{1}{Cs}$</p><p>电感：$Z=Ls$</p></li><li><p><strong>运放：虚短、虚断</strong></p></li><li><p>微分方程的阶数由<strong>独立储能元件个数</strong>决定</p></li></ul></li></ul><h1 id="四、传递函数"><a href="#四、传递函数" class="headerlink" title="四、传递函数"></a><strong>四、传递函数</strong></h1><ul><li><p><strong>传递函数$G(s)$：</strong>线性定常系统、初值为0、单数单输出，输出的Laplace变换$Y(s)$与输入的Laplace变换$U(s)$的比值</p></li><li><p><strong>单位脉冲输入$δ(t)$，传递函数就是输出的Laplace变换</strong>：$G(s)=Y(s)$</p></li><li><p><strong>对输入求导，输出也会求相应的导数</strong></p><ul><li><p>已知输入为单位斜坡响应$u(t)=t$时的输出$y(t)$，则传递函数为$y’’(t)$</p></li><li><p>一阶系统：</p><p><img src="https://s2.loli.net/2024/10/15/DWzRgJOBtemkovd.png" alt="image-20241015093741538" style="zoom: 67%;" /></p></li></ul></li><li><p>典型传递函数：</p><ul><li>比例/放大环节 $G(s)=K$</li><li>积分环节 $G(s)=\frac{1}{s}$（若输入突然除去，积分停止，输出维持不变）</li><li>微分环节 $G(s)=s$</li><li>惯性环节 $G(s)=\frac{1}{Ts+1}$</li><li>一阶微分环节 $G(s)=Ts+1$</li><li>二阶振荡环节 $G(s)=\frac{1}{T^2s^2+2ζTs+1}$</li><li>二阶微分环节 $G(s)=T^2s^2+2ζTs+1$</li><li>延迟环节 $G(s)=e^{-\tau s}$</li></ul></li></ul><h1 id="五、方框图"><a href="#五、方框图" class="headerlink" title="五、方框图"></a><strong>五、方框图</strong></h1><ul><li><p><strong>方框图的简化</strong></p></li><li><p><strong>简单版Mason公式：适用于有一条前向通路的系统</strong></p><script type="math/tex; mode=display">\Phi (s)=\frac{G_A(s)}{1+{\textstyle \sum_{i=1}^{n}\pm G_{Bi}(s) }}</script><p><img src="https://s2.loli.net/2024/10/15/G6drwSJQ1DVjZpz.png" alt="image-20241015093913781" style="zoom:50%;" /></p></li><li><p><strong>几个定义</strong></p><p><img src="https://s2.loli.net/2024/10/15/6tzwFN9JP4X2AeE.png" alt="image-20241015094132292" style="zoom:67%;" /></p><ul><li><p>前向通路：$R(s)$到$B(s)$</p></li><li><p>反馈通路：$C(s)$到$B(s)$</p></li><li><p><strong>闭环传递函数</strong>：$\frac{C(s)}{R(s)}=\frac{G_1G_2}{1+G_1G_2H}$</p></li><li><p><strong>开环传递函数</strong>：反馈通路末端断开 $\frac{B(s)}{E(s)}=G_1G_2H$</p></li><li><p>前向传递函数：$\frac{C(S)}{E(s)}=G_1G_2$</p></li><li><p>误差传递函数</p><p>：以$E(s)$为输出，以$R(s)$或$N(s)$为输入的闭环传递函数</p><ul><li>$\frac{E(s)}{R(s)}=\frac{1}{1+G_1G_2H}$ 与开环传递函数有关</li><li>$\frac{E(s)}{N(s)}=\frac{-G_2H}{1+G_1G_2H}$</li></ul></li></ul></li><li><p>输入$R(s)$和扰动$N(s)$同时作用时的输出</p><ul><li>只考虑输入$R(s)$，则 $C(s)=\frac{G_1G_2}{1+G_1G_2H}R(s)$</li><li>只考虑$N(s)$，则 $C(s)=\frac{G_2}{1+G_1G_2H}N(s)$</li><li>同时考虑两者$C(s)=\frac{G_1G_2}{1+G_1G_2H}R(s)+\frac{G_2}{1+G_1G_2H}N(s)$</li></ul></li><li><p>可以发现系统的<strong>闭环传递函数（反馈通路没有断开）</strong>的分母均为$1+G_1G_2H$（系统的特征多项式），这说明</p><ul><li>不管外作用加在系统的哪一个位置（$R(s)$处还是$N(s)$处，或者其他位置），系统都有着<strong>相同的特征多项式</strong>，系统<strong>闭环传递函数</strong>都有着<strong>相同的极点</strong>，这是系统的一种固有特性</li></ul></li></ul><h1 id="六、信号流图"><a href="#六、信号流图" class="headerlink" title="六、信号流图"></a><strong>六、信号流图</strong></h1><ul><li><p>几个定义</p><ul><li>前向通路：从输入节点到输出节点，通过任一节点不多于一次的通路</li><li>回路：起点和终点重回，通过任一节点不多于一次</li><li>不接触回路：相互间没有任何公共节点的回路</li><li>增益：所在路径上所有传播（传递函数）的乘积</li></ul></li><li><p>根据系统方程绘制信号流图</p></li><li><p>根据方框图绘制信号流图</p><ul><li><p>节点的选取：一般取输入、输出、加法器后（支路汇总的地方）、出现分支的地方 作为节点</p><p><img src="https://s2.loli.net/2024/10/15/uYLM9P3pWHDf18T.png" alt="image-20241015094231726" style="zoom:50%;" /></p></li></ul></li><li><p><strong>Mason公式：找对通路、回路后套公式</strong></p><p><img src="https://s2.loli.net/2024/10/15/bTxo2FOlImsqSXN.png" alt="image-20241015094304633" style="zoom: 44%;" /></p></li></ul><h1 id="七、线性化"><a href="#七、线性化" class="headerlink" title="七、线性化"></a><strong>七、线性化</strong></h1><ul><li><p>输出和输入的关系不是线性关系时，可将非线性函数在平衡点附近线性化</p><p><img src="https://s2.loli.net/2024/10/15/exTSMt3ponDVwuq.png" alt="image-20241015094332695" style="zoom: 38%;" /></p></li></ul><h1 id="八、时域分析"><a href="#八、时域分析" class="headerlink" title="八、时域分析"></a>八<strong>、时域分析</strong></h1><ul><li><p>总结：</p><ul><li>典型<strong>输入信号</strong>有哪些</li><li><strong>一阶系统、二阶系统</strong>在这些典型输入信号下会有怎样的输出（<strong>瞬态响应、稳态响应</strong>）</li><li><strong>高阶系统</strong>的响应受哪些因素影响：零点、极点</li><li>怎样评价一个系统的性能好坏（稳准快）<ul><li>稳态性能指标：稳态误差</li><li>瞬态性能指标：$t_r$、$t_p$ 、$M_p$ 、$t_s$、$t_d$</li><li>这些性能和传递函数的零点极点有什么样的关联</li></ul></li><li>什么样的系统是稳定的：BIBO，极点</li><li>怎样判断一个系统是否稳定：劳斯稳定判据</li><li>对于一个稳定的系统，如何求其稳态误差</li><li>怎样提高系统的性能：PID控制</li></ul></li><li><p>典型输入信号：</p><ul><li><strong>阶跃信号</strong></li><li>斜坡信号</li><li>抛物线函数</li><li>脉冲信号</li><li>正弦信号</li></ul></li><li><p>瞬态响应：初始状态到稳态的响应过程</p></li><li><p>稳态响应：$t→∞$时，系统的输出</p></li><li><p>瞬态性能：</p><ul><li><strong>$t_r$ 上升时间（rise time）</strong>：有超调时为第一次到稳态所需时间；没有超调时为从稳态的10%上升到90%所需时间（快速性）</li><li>$t_p$  <strong>峰值时间（peak time）</strong>：上升至第一个峰值所需时间（快速性）</li><li><strong>$t_s$  调整时间（settling time）</strong>：到达并保持在允许误差范围内所需时间（快速性）</li><li><strong>$t_d$ 延时时间（delay time）</strong>：到达稳态$50\%$所需时间（快速性）</li><li>$M_p$ <strong>最大超调量</strong>：<strong>$\frac{c(t_p)-c(\infty)}{c(\infty)}\times100\%$（平稳性）</strong></li></ul></li><li><p><strong>一阶系统：</strong></p><ul><li><p>传递函数 $G(s)=\frac{1}{Ts+1}$</p></li><li><p>极点：$s=-\frac{1}{T}$</p></li><li><p><strong>单位阶跃响应：</strong></p><ul><li><p>输出 $c(t)=1-e^{-\frac{t}{T}}$</p><p><img src="https://s2.loli.net/2024/10/15/hXSimJD2yFE3TV4.png" alt="image-20241015094421026" style="zoom:50%;" /></p></li><li><p>$t_s=3T$（5%误差）       $t_s=4T$（2%误差）</p></li><li><p>T越大，<strong>极点离虚轴越近，响应越慢</strong></p><p><img src="https://s2.loli.net/2024/10/15/yBKGI8ta1mCixr6.png" alt="image-20241015094441680" style="zoom: 50%;" /></p></li></ul></li><li><p>单位脉冲响应、单位斜坡响应、单位加速度响应</p></li></ul></li><li><p><strong>二阶系统</strong></p><ul><li><p>传递函数$G(s)=\frac{\omega_n^{2}}{s^2+2\zeta\omega_n^2S+\omega_n^2}$</p></li><li><p>$\zeta$：阻尼比       $\omega_n$：固有频率（无阻尼自然频率）</p></li><li><p>极点：$s_1,s_2=-\zeta\omega_n\pm\omega_n\sqrt{\zeta^2-1}$</p></li><li><p><strong>过阻尼（$\zeta&gt;1$）</strong></p><ul><li><p>极点为两个不等负实根</p><p><img src="https://s2.loli.net/2024/10/15/fL3PlxOUCWGNnDJ.png" alt="image-20241015094503280" style="zoom: 47%;" /></p></li><li><p>$t_s=3\times\frac{1}{(\zeta-\sqrt{\zeta^2-1})\omega_n}$（5%误差）        $t_s=4\times\frac{1}{(\zeta-\sqrt{\zeta^2-1})\omega_n}$（2%误差）</p></li></ul></li><li><p><strong>临界阻尼（$\zeta=1$）</strong></p><ul><li><p>极点为两个相等实根</p></li><li><p>输出 $c(t)=1-e^{-\omega_nt}(1+\omega_nt)$</p><p><img src="https://s2.loli.net/2024/10/15/QnJL2p8iZaBk3AE.png" alt="image-20241015094523570" style="zoom:33%;" /></p></li><li><p>斜率最大的时刻：$t=\frac{1}{\omega_n}$</p></li><li><p>调整时间：到达稳态值95%，$t_s=\frac{4.7}{\omega_n}$</p></li></ul></li><li><p><strong>欠阻尼（$0&lt;\zeta&lt;1$）</strong></p><ul><li><p>一对共轭复数极点</p></li><li><p>$c(t)=1-\frac{e^{-\zeta\omega_nt}}{\sqrt{1-\zeta^2}}\sin{\omega_dt}$</p></li><li><p>有阻尼振荡频率 $\omega_d=\omega_n\sqrt{1-\zeta^2}$</p></li><li><p>振荡周期$T_d=\frac{2\pi}{\omega_d}$</p><p><img src="https://s2.loli.net/2024/10/15/y3nmw8SEx4cQqNJ.png" alt="image-20241015094541141" style="zoom:50%;" /></p></li></ul></li><li><p><strong>无阻尼（$\zeta=0$）</strong></p><ul><li>一对纯虚极点</li><li>$c(t)=1-\cos{\omega_nt}$</li></ul></li></ul></li><li><p><strong>高阶系统：</strong></p><ul><li>可以只考虑主导<strong>极点</strong>的影响</li><li><strong>主导极点</strong>：<strong>距离虚轴最近的极点</strong>、附近没有零点、其他极点到虚轴的距离是这对极点到虚轴距离的五倍以上</li><li>零点的影响：减小系统阻尼 $\zeta$，且越靠近虚轴，影响越明显</li><li>极点的影响：增大系统阻尼，越靠近虚轴越明显</li><li>若零点与极点距离很近，则他们的作用会相互抵消，对响应的影响可以忽略不计</li></ul></li><li><p><strong>系统稳定充要条件</strong>：特征方程的所有根都在s平面左半平面（实部为负，则 e 指数为负，瞬态响应可以衰减到 0，不会发生指数爆炸）</p></li><li><p><strong>劳斯判据：</strong></p><p><img src="https://s2.loli.net/2024/10/15/S59npKqlguj2Dy4.png" alt="image-20241015094604373"></p><ul><li><p>不稳定根（右半平面根）的个数：第一列参数符号变化的次数</p></li><li><p>存在一行的第一列元素为零：用 $\varepsilon$ 代替0，计算上下行符号有无变化，若不变化，则有一对虚根，若变化，则存在右半平面不稳定根</p></li><li><p>存在全零行：用辅助多项式（上一行的多项式）求得根</p></li><li><p>稳定裕量</p><p>$\delta$：所有根均位于$-\delta$的左侧</p><ul><li>要判断$s$和$-\delta$的关系，所以可以令$s_1=s+\delta$，转换成判断$s_1$和  $0$ 的关系，再使用劳斯判据</li></ul></li></ul></li><li><p><strong>稳态误差：</strong></p><ul><li><p>利用Laplace变换的<strong>终值定理</strong>求解</p><p>$t→\infty$时的误差</p><script type="math/tex; mode=display">e_ss=\lim_{s\to0}sE(s)</script></li><li><p>对于一个简单反馈系统</p><p><img src="https://s2.loli.net/2024/10/15/AHl56fCBOP9wWyK.png" alt="image-20241015094720920" style="zoom: 50%;" /></p><script type="math/tex; mode=display">e_ss=\lim_{t\to\infin}e(t)=\lim_{s\to0}sE(s)=\lim_{s\to0}s\frac{1}{1+G(s)H(s)}R(s)</script><p> 与开环传递函数有关</p></li><li><p>0型系统、Ⅰ型系统、Ⅱ型系统……</p><p><img src="https://s2.loli.net/2024/10/15/v7YDxrtCHZ5UK9y.png" alt="image-20241015094956200" style="zoom:33%;" /></p></li><li><p>稳态误差受哪些因素影响</p><p><img src="https://s2.loli.net/2024/10/15/Vl9ur2jFfEso8xP.png" alt="image-20241015095030138" style="zoom: 33%;" /></p></li><li><p>静态位置误差系数$K_p$：输入为<strong>单位阶跃</strong>时的稳态误差系数（上式中K的值）</p></li><li><p>静态速度误差系数$K_v$：输入为单位斜坡时的稳态误差系数</p></li><li><p>静态加速度误差系数$K_a$：输入为单位加速度时的稳态误差系数</p></li><li><p><strong>PID控制</strong></p><ul><li><p><strong>比例控制（Proportional）：将误差乘以一个系数，再让系统对经比例控制后的误差进行反应</strong></p><p><img src="https://s2.loli.net/2024/10/15/5WpC8xeQbFmysEq.png" alt="image-20241015100357482" style="zoom:50%;" /></p></li><li><p><strong>积分控制（Integral）：考虑过去误差的累积量，再让系统对这个累积量进行反应</strong></p><p><img src="https://s2.loli.net/2024/10/15/twlm8zsVOjaABUJ.png" alt="image-20241015100422746" style="zoom:50%;" /></p></li><li><p><strong>微分控制（Differential）：考虑将来的误差，计算误差的一阶导，从而对未来的误差进行预测</strong></p><p><img src="https://s2.loli.net/2024/10/15/N4pDGVRsTCFgrei.png" alt="image-20241015100504687" style="zoom:50%;" /></p></li></ul></li></ul></li><li><p>$\zeta$越大，振幅衰减越快，震荡周期越长（阻力大）</p><p><img src="https://s2.loli.net/2024/10/15/5GTNB7O2cUYmw3y.png" alt="image-20241015100534995" style="zoom: 50%;" /></p><p><img src="https://s2.loli.net/2024/10/15/pVIOM2bQtDWclAF.png" alt="image-20241015100559603" style="zoom:50%;" /></p></li></ul><h1 id="九、频域分析"><a href="#九、频域分析" class="headerlink" title="九、频域分析"></a><strong>九、频域分析</strong></h1><ul><li>频域分析：根据系统的<strong>开环</strong>频率特性判断<strong>闭环系统</strong>的性能</li><li>频率响应：系统对<strong>正弦信号</strong>的<strong>稳态响应</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 现代控制理论 </tag>
            
            <tag> 机械 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL之哈希表</title>
      <link href="/post/751f48bb.html"/>
      <url>/post/751f48bb.html</url>
      
        <content type="html"><![CDATA[<p>C++ STL中，哈希表对应的容器是unordered_map（since C++ 11）。</p><p>STL中，<strong>map</strong> 对应的数据结构是 <strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 <strong>O(logN)</strong>。而 <strong>unordered_map</strong> 对应 <strong>哈希表</strong>，哈希表的特点就是查找效率高，时间复杂度为常数级别 <strong>O(1)</strong>， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 unordered_map 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 map 容器。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p>unordered_map 是一种关联容器，用于存储由关键值 (Key Value，以下称为Key 值) 和映射值 (Mapped Value，以下称为映射值) 组成的元素，并且允许根据其 Key 值快速检索各个元素。</p></li><li><p>在 unordered_map 容器中，Key 值通常用来唯一标识元素，映射值是与该 Key 值关联内容的对象。Key 值与映射值的类型可能不同。</p></li><li><p>在 unordered_map 内部，元素没有按照其 Key 值与映射值的任何顺序进行排序 ，而是根据它们的 Hash 值组织成桶，允许它们通过其 Key 值直接快速访问单个元素（通常具有常数等级的平均时间复杂度）。</p></li><li><p>unordered_map 容器与 map 容器相比，通过 Key 值访问各个元素的速度更快，然而通过其元素子集进行范围迭代的效率通常较低。</p></li><li><p>unordered_map 实现了直接访问操作符 (operator[])，它允许使用 Key 值作为输入参数，直接访问映射值。</p></li><li><p>容器中的迭代器至少是前向迭代器。</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>引入头文件 <strong><unordered_map></strong> </p></li><li><p>unordered_map<key,value> m;</p></li><li><p>m.size();    //元素数量</p></li><li><p>m.insert(x);</p></li><li><p>m.find(key);</p><p>m.count(key);</p></li><li><p>m.erese(key);</p></li><li><p>m[key] → value</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li><p>基本使用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="string">&#x27;a&#x27;</span>] = <span class="number">9</span>;</span><br><span class="line">m[<span class="string">&#x27;?&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">m[<span class="string">&#x27;z&#x27;</span>] = <span class="number">99</span>;</span><br><span class="line">m[<span class="string">&#x27;A&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">m[<span class="string">&#x27;Z&#x27;</span>] = <span class="number">-2</span>;</span><br><span class="line">m[<span class="string">&#x27; &#x27;</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出元素个数</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找&#x27; &#x27;元素是否存在，若存在，输出其对应的值；</span></span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">count</span>(<span class="string">&#x27; &#x27;</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; m[<span class="string">&#x27; &#x27;</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出内部所有元素，体现无序性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">begins</span>(); it != m.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">Z -2</span><br><span class="line">  0</span><br><span class="line">A 50</span><br><span class="line">? 5</span><br><span class="line">z 99</span><br><span class="line">a 9</span><br></pre></td></tr></table></figure></li><li><p>Leetcode <a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Key is the number and value is its index in the vector</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hash;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> &lt;<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> numberToFind = target - number[i];</span><br><span class="line">            <span class="comment">//if numberToFind is found in map, return them</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(numberToFind) != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(hash[numberToFind);</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">                hash[numbers[i]] = i;                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;                              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 散落的知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建记录</title>
      <link href="/post/7cfd23b7.html"/>
      <url>/post/7cfd23b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="2023-2"><a href="#2023-2" class="headerlink" title="2023.2"></a>2023.2</h2><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>生成markdown文件，在命令行输入:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>在blog根目录下的source文件夹中的post文件夹会多一个 <strong>博客名字.md</strong> 的markdown文件，打开即可进行编辑。</p><h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>markdown语法参考链接 <a href="https://www.appinn.com/markdown/">Markdown语法说明（简体中文版）</a></p><h3 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h3><p>在根目录下git命令行输入三连指令，即可完成新页面的发布</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>如果在发布前想预览生成网站的效果，可输入</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><hr><h2 id="2024-7-25"><a href="#2024-7-25" class="headerlink" title="2024.7.25"></a>2024.7.25</h2><p>近日心血来潮地想起自己两年前心血来潮搭的网站，想到自己已经为这个域名掏了三年的钱包，还是要好好利用起来，于是再次开始维护。</p><h3 id="主页顶部图片更改"><a href="#主页顶部图片更改" class="headerlink" title="主页顶部图片更改"></a>主页顶部图片更改</h3><p>维护时首先想到的就是把主页顶部图片换了，顶部图片的更换非常简单，我目前使用的是butterfly主题，只需要在<code>_config.butterfly.yml</code>中修改<code>index_img</code>后的图片链接即可：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The banner image of home page （主页封面图片）</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/img/The_Valley_of_the_Wind.jpg</span></span><br></pre></td></tr></table></figure><p>顶部背景是在这个网站找的 <a href="https://alphacoders.com/resolution/4k-wallpapers">4K Wallpapers - Download For FREE</a>，清晰度很不错，直接copy网站上的图片链接加载速度要比把图片存在本地更快一些。</p><h3 id="文章页背景更换"><a href="#文章页背景更换" class="headerlink" title="文章页背景更换"></a>文章页背景更换</h3><p>之前不知什么时候给博客更换了一个花里胡哨的背景，使用一段时间后还是觉得白底黑字看起来最舒服，于是决定修改当前背景。背景更换需打开<code>Blog\themes\butterfly\source\css</code>目录下的<code>custom.css</code>，修改其中的<code>#web_bg</code></p><p>背景设置为渐变色</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#web_bg &#123;</span></span><br><span class="line"><span class="attr">background-image:</span> <span class="string">linear-gradient(to</span> <span class="string">top,</span> <span class="comment">#fef9d7 0%, #d299c2 100%);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>背景设置为纯色</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#web_bg &#123;</span></span><br><span class="line"><span class="attr">background-color:</span> <span class="comment">#ffffff;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="部署时spawn-failed报错问题的解决"><a href="#部署时spawn-failed报错问题的解决" class="headerlink" title="部署时spawn failed报错问题的解决"></a>部署时spawn failed报错问题的解决</h3><p>在完成一些参数的修改后，使用<code>hexo d</code>部署时却出现了spawn failed的报错。发现报错后首先尝试了目前主流的两种解决方案：</p><h4 id="1-重置git的deploy文件夹"><a href="#1-重置git的deploy文件夹" class="headerlink" title="1. 重置git的deploy文件夹"></a>1. 重置git的deploy文件夹</h4><p>删除blog文件夹中的<code>.deploy_git</code>文件夹，然后在终端cd进这个文件夹后输入<code>git config --global core.autocrlf false</code></p><h4 id="2-修改git-repo配置地址"><a href="#2-修改git-repo配置地址" class="headerlink" title="2. 修改git repo配置地址"></a>2. 修改git repo配置地址</h4><p>打开<code>_config.yml</code>配置文件，修改以下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"></span><br><span class="line"><span class="attr">repo:</span> <span class="string">https://github.com/yourname/yourname.github.io.git</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>其中的repo修改为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br></pre></td></tr></table></figure><h4 id="3-重置GitHub-SSH密钥"><a href="#3-重置GitHub-SSH密钥" class="headerlink" title="3. 重置GitHub SSH密钥"></a>3. 重置GitHub SSH密钥</h4><p>很遗憾，上面的两种方法最终都没能解决我的问题，但在查看<a href="https://blog.zhheo.com/p/128998ac.html">张洪Heo</a>的博客文章后我意识到可能是<strong>GitHub SSH密钥设置</strong>出现了问题。果然，在git命令行中尝试使用SSH连接时出现了错误。</p><p>git命令行输入：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey)</span><br></pre></td></tr></table></figure><p>登录许久未使用的用于部署网站的GitHub账号，发现<strong>原有的SSH密钥已被删除</strong>，原来作为安全预防措施，GitHub会自动删除一年内未使用过的 SSH 密钥。于是重新走了一遍设置GitHub密钥的流程（具体可参考“<a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a>”），问题终于成功解决。</p><hr><h2 id="2024-8-12"><a href="#2024-8-12" class="headerlink" title="2024.8.12"></a><strong>2024.8.12</strong></h2><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>在markdown中插入图片的语法为</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">src</span>)</span><br></pre></td></tr></table></figure><p>其中<code>src</code>既可以是本地图片的绝对/相对路径，比如<code>../images/test.png</code>，也可以是URL。<code>alt</code>是图片的注释，可以为空。</p><p>考虑到本地图片在网页中的加载速度较慢，且插入至markdown中的步骤比较繁琐，我采用了SMMS图床＋Typora自动上传的方法，这样只需要直接将图片粘贴到Typora中，图片就可以自动上传到图床。具体的配置步骤见<a href="https://blog.csdn.net/m0_56416743/article/details/132021539">Typora1.6.7+图床SMMS自动上传教程(PicGo-Core(command line)方式</a>。</p><p>（24.10.15补充）出现了上传失败的问题，报错<code>Can&#39;t find smms config, please provide api token, see https://sm.ms/home/apitoken</code>。打开Preference-Image里的配置文件，发现是token莫名失踪了，于是登录sm.ms图床，复制token，粘贴到.json文件中，就解决了。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;smms&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;smms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这里是token&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-smms-user&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="2024-10-15"><a href="#2024-10-15" class="headerlink" title="2024.10.15"></a>2024.10.15</h2><ul><li>添加了 Gitalk 评论功能，具体配置方法可以参考 <a href="https://www.cnblogs.com/qisi007/p/13731562.html">hexo博客添加gitalk评论系统 - 俗的太不一样</a></li><li>修改了部分主题配置，主页更好看啦。所有的配置参数都是基于 <a href="https://butterfly.js.org/posts/4aa8abbe">Butterfly 文檔(三) 主題配置</a> 修改的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP问题</title>
      <link href="/post/41ef174f.html"/>
      <url>/post/41ef174f.html</url>
      
        <content type="html"><![CDATA[<h1 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h1><ul><li><strong>NP问题</strong> 的全称是：Non deterministic Ploynomial问题，即非确定性多项式问题。</li><li><strong>多项式时间（Polynomial time）</strong> 在计算复杂度理论中，指的是一个问题的计算时间m(n)不大于问题大小n的多项式倍数。</li><li><p><strong>什么是非确定性问题？</strong> </p><p>  有些计算问题是确定性的，比如加减乘除之类，你只要按照公式推导，按部就班一步步来，就可以得到结果。但是，有些问题是无法按部就班直接地计算出来。比如，找大质数的问题。有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的。再比如，大的合数分解质因数的问题，有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式。</p><p>  这种问题的答案，是无法直接计算得到的，只能通过间接的“猜算”来得到结果。这也就是<em>非确定性问题</em>。而这些问题的通常有个算法，它不能直接告诉你答案是什么，但可以告诉你，某个可能的结果是正确的答案还是错误的。这个可以告诉你“猜算”的答案正确与否的算法，假如可以在多项式时间内算出来，就叫做<em>多项式非确定性问题</em>。</p></li><li><strong>NP问题</strong> 就是非确定性的多项式问题，也就是说，可以在多项式时间内验证一个解是否正确的问题是NP问题。</li><li><p><strong>P问题</strong> 是能在多项式时间内求出其解的问题，所有的P问题都是NP问题，但是是否P=NP，目前还没有被证明。</p><p>  （不是所有的NP问题都是难解的问题，比如数组排序的问题就是P类问题，但是P属于NP问题，所它也是NP问题，但是他并不难解。）</p></li><li><p><strong>NP困难问题：</strong> 对于一个判定问题A,如果所有的NP问题都可以多项式时间规约到A，那么这个问题就是NP困难问题。</p></li><li><p><strong>NPC问题：</strong> 对于一个NP问题A，如果所有的NP问题都可以多项式时间规约到A，那么这个问题就是NP困难问题。</p></li><li><p><strong>NPC</strong>，也称NP完全问题，它是NP问题的一个子类，比如哈密尔顿回路问题就是NPC问题。它是这样描述的，给定N个顶点，以及任意两个顶点之间的距离，求出一条回路，使其经过每个顶点，且回路的总距离最短。这个问题可以通过枚举求出解，但是他的时间复杂度是(N-1)!,随着N的增大，要计算解是不可能的。</p><p>  NPC有一种性质，那就是如果能证明NPC问题可以在多项式时间内求出其解，则所有的NP都可以在多项式时间内求解了，即P=NP成立。所以，我们一般认为NPC问题是难解的问题，因为他不太可能存在一个多项式时间的算法（如果存在则所有的NP问题都存在多项式时间算法，这太不可思议了，但是也不是不可能）。</p></li><li><p><strong>NP完全问题的证明:</strong> 要证明一个判定问题是NP完全的,只要在NP完全类中找到一个问题A,将这个问题归约到待证明问题即可.要证明问题是NP完全是很困难的,因为很多问题之间的转化过程是很难想到的.第一个被证明的NP完全问题是可满足性问题,它是判定一个合取范式的布尔公式F是否存在真值指派的问题.在很多NP完全问题的证明中,我们都可以用这个问题来归约,这里不再详述。</p></li></ul><hr><p>转自<a href="https://blog.csdn.net/zxj1988/article/details/6275458">CSDN博主zxj1988的文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 散落的知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
