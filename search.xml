<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Analyzing Neural Time Series Data - Exercises 04</title>
      <link href="/post/c9der4d1.html"/>
      <url>/post/c9der4d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-7-Exercise"><a href="#4-7-Exercise" class="headerlink" title="4.7 Exercise"></a>4.7 Exercise</h2><h4 id="4-7-1-Exercises-for-Script-A"><a href="#4-7-1-Exercises-for-Script-A" class="headerlink" title="4.7.1 Exercises for Script A"></a><strong>4.7.1 Exercises for Script A</strong></h4><ol><li><p>Create a 4 × 8 matrix of randomly generated numbers. </p></li><li><p>Loop through all rows and columns, and test whether each element is greater than 0.5. </p></li><li><p>Report the results of the test along with the value of the matrix element and its row-column position. For example, your Matlab script should print The 3rd row and 8th column has a value of 0.42345 and is not bigger than 0.5 . </p></li><li><p>Make sure to add exceptions to print out 1st, 2nd, and 3rd, instead of 1th, 2th, and 3th. </p></li><li><p>Put this code into a separate function that you can call from the command line with two inputs, corresponding to the number of rows and the number of columns of the matrix. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.1 Exercises for Script A</span></span><br><span class="line">matA = GreaterThanPointFive(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成一个 rowx × colx 的0~1随机数矩阵，并输出各行各列上的元素及其与0.5的大小关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matx</span> = <span class="title">GreaterThanPointFive</span><span class="params">(rowx, colx)</span></span></span><br><span class="line">    matx = <span class="built_in">rand</span>(rowx,colx);</span><br><span class="line">    NoString = [<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;st&#x27;</span>;<span class="string">&#x27;nd&#x27;</span>;<span class="string">&#x27;rd&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> rowi = <span class="number">1</span>:rowx</span><br><span class="line">        <span class="keyword">for</span> coli = <span class="number">1</span>:colx</span><br><span class="line">            <span class="keyword">if</span> matx(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is not bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="4-7-2-Exercises-for-Script-B"><a href="#4-7-2-Exercises-for-Script-B" class="headerlink" title="4.7.2 Exercises for Script B"></a><strong>4.7.2 Exercises for Script B</strong></h4><ol><li><p>Import and plot the picture of Amsterdam that comes with the online Matlab code. </p></li><li><p>On top of the picture, plot a thick red line from “ Nieuwmarkt ” (near the center of the picture) to “ Station Amsterdam Centraal ” (near the top of the picture). </p></li><li><p>Plot a magenta star over the Waterlooplein metro station (a bit South of Nieuwmarkt). </p></li><li><p>Find the maximum value on each color dimension (red, green, or blue) and plot a circle using that color. There may be more than one pixel with a maximum value; if so, pick one pixel at random. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.2 Exercises for Script B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 6. Import and plot picture</span></span><br><span class="line">amsterdamImg = imread(<span class="string">&quot;amsterdam.bmp&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">imagesc(amsterdamImg);</span><br><span class="line">axis image</span><br><span class="line">axis on</span><br><span class="line">grid on</span><br><span class="line">grid minor</span><br><span class="line"></span><br><span class="line"><span class="comment">% 7. plot a thick red line</span></span><br><span class="line">line([<span class="number">367</span>,<span class="number">395</span>],[<span class="number">325</span>,<span class="number">75</span>],<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 8. plot a magenta star</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">375</span>,<span class="number">490</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 9.find maximum value on each color dimension and plot a circle using it</span></span><br><span class="line"><span class="comment">% 分别提取RGB数值</span></span><br><span class="line">R = amsterdamImg(:,:,<span class="number">1</span>);</span><br><span class="line">G = amsterdamImg(:,:,<span class="number">2</span>);</span><br><span class="line">B = amsterdamImg(:,:,<span class="number">3</span>);</span><br><span class="line"><span class="comment">% 找到最大的RGB值</span></span><br><span class="line">R_max = <span class="built_in">max</span>(R);</span><br><span class="line">G_max = <span class="built_in">max</span>(G);</span><br><span class="line">B_max = <span class="built_in">max</span>(B);</span><br><span class="line"><span class="comment">% 找到最大值所在位置</span></span><br><span class="line">[R_maxRow, R_maxCol] = <span class="built_in">find</span>(R==R_max);</span><br><span class="line">[G_maxRow, G_maxCol] = <span class="built_in">find</span>(G==G_max);</span><br><span class="line">[B_maxRow, B_maxCol] = <span class="built_in">find</span>(B==B_max);</span><br><span class="line"><span class="comment">% 随机选择一个索引</span></span><br><span class="line">R_idx = randi(<span class="built_in">length</span>(R_maxRow));</span><br><span class="line">G_idx = randi(<span class="built_in">length</span>(G_maxRow));</span><br><span class="line">B_idx = randi(<span class="built_in">length</span>(B_maxRow));</span><br><span class="line"><span class="comment">% 获取坐标</span></span><br><span class="line">R_position = [R_maxRow(R_idx), R_maxCol(R_idx)];</span><br><span class="line">G_position = [G_maxCol(G_idx), G_maxCol(G_idx)];</span><br><span class="line">B_position = [B_maxCol(B_idx), B_maxCol(B_idx)];</span><br><span class="line"><span class="comment">% 在图像上最大值位置绘制圆圈</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(R_position(<span class="number">1</span>),R_position(<span class="number">2</span>),<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(G_position(<span class="number">1</span>),G_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(B_position(<span class="number">1</span>),B_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure><p><img src="D:/Desktop/Analyzing%20Neural%20Time%20Series%20Data_%20Theory%20and%20Practice/MyMatlabCode/Ex_04/Ex_04_B.bmp" alt="Ex_04_B" style="zoom: 67%;" /></p><h4 id="4-7-3-Exercises-for-Script-C"><a href="#4-7-3-Exercises-for-Script-C" class="headerlink" title="4.7.3 Exercises for Script C"></a><strong>4.7.3 Exercises for Script C</strong></h4><ol><li><p>From the function you wrote for exercise 5, generate a 32 × 3 number matrix in which the three numbers in each row correspond to the row, column, and result of the test (1 for bigger than 0.5; 0 for smaller than 0.5). </p></li><li><p>Write this 32 × 3 matrix to a text file that contains this matrix along with appropriate variable labels in the first row. Make sure this file is tab-delimited and readable by a spreadsheet software such as Microsoft Excel or Open Office Calc. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 运行该代码前请先运行Exercise_04_A</span></span><br><span class="line"></span><br><span class="line">matC = NaN(<span class="number">32</span>,<span class="number">3</span>);   <span class="comment">% 第一、二列为matA的行、列坐标，第三列为该坐标上的元素是否大于0.5</span></span><br><span class="line">countRowi = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rowi = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> coli = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">2</span>)</span><br><span class="line">        matC(countRowi,<span class="number">1</span>) = rowi;</span><br><span class="line">        matC(countRowi,<span class="number">2</span>) = coli;</span><br><span class="line">        <span class="keyword">if</span> matA(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        countRowi = countRowi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 将matC写入txt文件</span></span><br><span class="line">fileC = fopen(<span class="string">&#x27;data_output_04C.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% variable labels</span></span><br><span class="line">variable_labels = &#123;<span class="string">&#x27;row&#x27;</span>;<span class="string">&#x27;column&#x27;</span>;<span class="string">&#x27;result&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">% 写入第一行变量名</span></span><br><span class="line"><span class="keyword">for</span> vari=<span class="number">1</span>:<span class="built_in">length</span>(variable_labels)</span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;%s\t&#x27;</span>,variable_labels&#123;vari&#125;);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 换行</span></span><br><span class="line">fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> datarowi=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> columni=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">2</span>)</span><br><span class="line">        fprintf(fileC,<span class="string">&#x27;%g\t&#x27;</span>,matC(datarowi,columni));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fclose(fileC);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analyzing Neural Time Series Data 学习记录 Part 2</title>
      <link href="/post/c9dcd3d2.html"/>
      <url>/post/c9dcd3d2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-7-数据预处理"><a href="#Chapter-7-数据预处理" class="headerlink" title="Chapter 7 数据预处理"></a>Chapter 7 数据预处理</h1><h2 id="The-Balance-between-Signal-and-Noise-信号与噪声的取舍平衡"><a href="#The-Balance-between-Signal-and-Noise-信号与噪声的取舍平衡" class="headerlink" title="The Balance between Signal and Noise | 信号与噪声的取舍平衡"></a>The Balance between Signal and Noise | 信号与噪声的取舍平衡</h2><p>保留更多的信号通常也意味着保留更多的噪声。</p><p>某些数据是信号还是噪声取决于实验的目的。</p><hr><h2 id="Creating-Epochs"><a href="#Creating-Epochs" class="headerlink" title="Creating Epochs"></a>Creating Epochs</h2><p>提取epoch的过程可以认为是将一段完整的数据划分成不同的小段</p><h4 id="1-如何选择“time-0”的时刻"><a href="#1-如何选择“time-0”的时刻" class="headerlink" title="1. 如何选择“time=0”的时刻"></a>1. 如何选择“time=0”的时刻</h4><ul><li>对于大多数实验，选择刺激开始的时刻作为time=0</li><li>对于其他情况，如有多个刺激时，可选择第一个刺激或最关键的刺激开始的时刻作为time=0</li><li>time-lock（time=0时刻的选择）是可以根据需要调节变化的</li></ul><h4 id="2-time-0前后需要包含多长时间"><a href="#2-time-0前后需要包含多长时间" class="headerlink" title="2. time=0前后需要包含多长时间"></a>2. time=0前后需要包含多长时间</h4><p>对于<strong>ERPs</strong>分析，划分的小段只需要包含你<strong>想要分析的时间段加上baseline</strong>，例如相对于0时刻的-200ms到800ms。</p><p>对于<strong>时频分析</strong>，需要划分<strong>更长</strong>的时间段，以避免<strong>边缘伪影（edge artifacts）</strong>，即需要<strong>预留足够长的缓冲区，使边缘伪影消退</strong>。此外，提取的频带越小，需要预留的缓冲区也应该越长。在时频功率谱中，边缘伪影很容易识别，因此可以先试分析一组数据再确定需要预留的缓冲区长度。通常情况下，将缓冲区长度设置为所分析的最低频率所对应的三个周期就足够了（例如，对2Hz的频率，设置缓冲区为1500ms）。</p><p>如果划分的epoch不够长，可以使用“reflection”的方法，即将这一段数据关于开始和结尾时刻首尾对称一下，再拼接到数据前和数据后，这样就可以得到三倍长的epoch。</p><p><img src="https://s2.loli.net/2024/08/12/pR8OtBZfriq4GJx.png" alt="image-20240812153014767"></p><hr><h2 id="Matching-Trial-Count-across-Conditions-Trial数量的设置与平衡"><a href="#Matching-Trial-Count-across-Conditions-Trial数量的设置与平衡" class="headerlink" title="Matching Trial Count across Conditions | Trial数量的设置与平衡"></a>Matching Trial Count across Conditions | Trial数量的设置与平衡</h2><h4 id="1-不同的实验条件尽量设置相同的trial数："><a href="#1-不同的实验条件尽量设置相同的trial数：" class="headerlink" title="1. 不同的实验条件尽量设置相同的trial数："></a><strong>1. 不同的实验条件尽量设置相同的trial数：</strong></h4><p>理想情况下，所有条件（例如实验设计中的不同实验条件或组别）应该有相同数量的试验。这样可以确保分析结果的公平性和可比性。</p><h4 id="2-trial数量对不同分析的影响："><a href="#2-trial数量对不同分析的影响：" class="headerlink" title="2. trial数量对不同分析的影响："></a><strong>2. trial数量对不同分析的影响</strong>：</h4><ul><li><strong>基于相位的分析</strong>：相位分析对试验数量特别敏感。如果trial数量较少，结果中会出现正偏差（positive bias），即trial数量少的实验条件可能显示出更大的结果。这是因为相位分析对于小样本量更容易受到随机波动的影响，导致条件间结果的偏差。</li><li><strong>基于功率的分析</strong>：功率分析也可能出现一些正偏差。因为功率值通常是正值，数据中的噪声更倾向于增加功率值，所以较少的试验数量可能导致功率结果偏高。</li><li><strong>基于ERP的分析</strong>：ERP分析在试验数量较少时没有特别的正偏差或负偏差，因为时间域的电压值可以为正也可以为负。然而，较少的试验数量会降低信噪比，这意味着ERP结果更容易受到异常值或非代表性数据的影响。</li></ul><h4 id="3-应对低trial数量的方法："><a href="#3-应对低trial数量的方法：" class="headerlink" title="3. 应对低trial数量的方法："></a><strong>3. 应对低trial数量的方法</strong>：</h4><p>对于ERP分析，如果试验数量较少，与其依赖峰值时间（peak times）的分析，不如取一段时间范围内的平均幅值（mean amplitude）。这种方法对噪声更为稳健，不容易受到个别异常值的影响。</p><h4 id="4-应对不同实验条件的trial数量不一致的方法："><a href="#4-应对不同实验条件的trial数量不一致的方法：" class="headerlink" title="4. 应对不同实验条件的trial数量不一致的方法："></a><strong>4. 应对不同实验条件的trial数量不一致的方法</strong>：</h4><p>如果出现不同的实验条件下的trial数目不一致，假设最小的trial数为N，那么可以通过以下方法来平衡trial数：</p><ul><li>（不建议采用）直接选前N个trial</li><li>随机选N个trial</li><li>根据一些相关的行为或实验变量，如反应时间等，有目的地选N个trial</li></ul><hr><h2 id="Trial-Rejection"><a href="#Trial-Rejection" class="headerlink" title="Trial Rejection"></a>Trial Rejection</h2><hr><h1 id="Chapter-9-Overview-of-Time-Domain-EEG-Analyses"><a href="#Chapter-9-Overview-of-Time-Domain-EEG-Analyses" class="headerlink" title="Chapter 9 Overview of Time-Domain EEG Analyses"></a>Chapter 9 Overview of Time-Domain EEG Analyses</h1><h2 id="Event-Related-Potentials-ERPs"><a href="#Event-Related-Potentials-ERPs" class="headerlink" title="Event-Related Potentials (ERPs)"></a>Event-Related Potentials (ERPs)</h2><p>To create ERPs, simply align the time-domain EEG to the time=0 event (this was probably already done during preprocessing) and <strong>average across trials</strong> at each time point.</p><hr><h2 id="Butterfly-Plots"><a href="#Butterfly-Plots" class="headerlink" title="Butterfly Plots"></a>Butterfly Plots</h2><p>A butterfly ploy shows <strong>the ERP from all electrodes</strong> overlaid in the same figure.</p><hr><h2 id="Global-Field-Power-Topographical-Variance-Plots"><a href="#Global-Field-Power-Topographical-Variance-Plots" class="headerlink" title="Global Field Power / Topographical Variance Plots"></a>Global Field Power / Topographical Variance Plots</h2><p>The global field power is <strong>the standard deviation</strong> of activity over <strong>all electrodes</strong>.</p><hr><h2 id="The-Flicker-Effect"><a href="#The-Flicker-Effect" class="headerlink" title="The Flicker Effect"></a>The Flicker Effect</h2><p>The flicker effect in EEG research refers to entrainment of brain activity to a rhythmic extrinsic driving factor. This effect is also referred to as steady-state evoked potential, frequency tagging, SSVEP (steady-state visual evoked potential), SSAEP (auditory evoked potential), or something similar. </p><p>The flicker effect is arguably an underutilized tool in cognitive electrophysiology. The main benefit of the flicker effect is that it allows you to <strong>“ tag ” the processing of a specific stimulus</strong>.</p><p><strong>(from ChatGPT)</strong></p><p>假设你正在进行一项视觉注意力的研究，目的是研究大脑如何同时处理多个视觉刺激。你在屏幕上呈现两个物体：一个物体以12 Hz的频率闪烁（即每秒闪烁12次），另一个物体以15 Hz的频率闪烁。你让参与者专注于两个物体之一，然后使用EEG记录他们的大脑活动。</p><p>在这种情况下，闪烁效应会导致大脑中处理视觉信息的区域（通常是视觉皮层）出现与这两个频率相对应的节律性活动。12 Hz的物体会在大脑中产生12 Hz的节律性活动，15 Hz的物体会产生15 Hz的节律性活动。通过分析EEG数据中的频率成分，你可以识别出大脑中对应这两个不同频率的活动区域。</p><p>即使EEG无法像功能性磁共振成像（fMRI）那样精确地显示大脑中具体的活动区域，你仍然可以通过这些频率标记来“分离”出大脑中对12 Hz和15 Hz刺激分别作出反应的神经元群体。换句话说，虽然EEG的空间分辨率较低，但通过闪烁效应，你可以“假设”出对不同刺激反应的特定神经区域。</p><p><strong>具体的例子说明</strong>：</p><ul><li><p><strong>12 Hz闪烁的物体</strong>：如果参与者主要关注这个物体，你会看到EEG数据中12 Hz频率的功率增加，这表明视觉皮层中的某个区域在处理这个物体。</p></li><li><p><strong>15 Hz闪烁的物体</strong>：如果参与者关注这个物体，EEG数据中15 Hz频率的功率会增加，显示另一个区域在处理这个物体。</p></li></ul><p>通过这种方法，即使两个物体在大脑中产生的活动区域相距较近，由于频率不同，你依然能够区分开来。这就相当于“模拟”出了一种高空间分辨率，使得你可以推断大脑中不同区域对不同刺激的反应。</p><hr><h2 id="Topographical-Maps"><a href="#Topographical-Maps" class="headerlink" title="Topographical Maps"></a>Topographical Maps</h2><p>Creating a topographical map is conceptually similar to interpolating an electrode, except that instead of estimating the activity at one point in space corresponding to a missing electrode, activity is estimated at many point in space between electrodes.</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">topoplot()</span><br></pre></td></tr></table></figure><hr><h2 id="Microstates"><a href="#Microstates" class="headerlink" title="Microstates"></a>Microstates</h2><p>In EEG as well as ERP map series, for brief, subsecond time periods, map landscapes typically remain quasi-stable, then change very quickly into different landscapes.</p><p>Durations tend to be around the alpha range (70-130 ms)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Analyzing Neural Time Series Data 学习记录 Part 1</title>
      <link href="/post/c9dcc4d9.html"/>
      <url>/post/c9dcc4d9.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-D-topographical-locations-of-EEG-electrodes"><a href="#2-D-topographical-locations-of-EEG-electrodes" class="headerlink" title="2-D topographical locations of EEG electrodes"></a>2-D topographical locations of EEG electrodes</h2><p><img src="https://s2.loli.net/2024/08/14/A4dNGTsBf8xHj5t.png" alt="image-20240814152033522" style="zoom:60%;" /> </p><hr><h2 id="Brain-rhythm-frequency-bands"><a href="#Brain-rhythm-frequency-bands" class="headerlink" title="Brain rhythm frequency bands"></a>Brain rhythm frequency bands</h2><blockquote><p>delta (2-4 HZ)</p><p>theta (4-8 Hz)</p><p>alpha (8-12 Hz)</p><p>beta (15-30 Hz)</p><p>lower gamma (30-80 Hz)</p><p>upper gamma (80-150 Hz)</p><p>subdelta and omega (up to 600 HZ)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL之哈希表</title>
      <link href="/post/751f48bb.html"/>
      <url>/post/751f48bb.html</url>
      
        <content type="html"><![CDATA[<p>C++ STL中，哈希表对应的容器是unordered_map（since C++ 11）。</p><p>STL中，<strong>map</strong> 对应的数据结构是 <strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 <strong>O(logN)</strong>。而 <strong>unordered_map</strong> 对应 <strong>哈希表</strong>，哈希表的特点就是查找效率高，时间复杂度为常数级别 <strong>O(1)</strong>， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 unordered_map 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 map 容器。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p>unordered_map 是一种关联容器，用于存储由关键值 (Key Value，以下称为Key 值) 和映射值 (Mapped Value，以下称为映射值) 组成的元素，并且允许根据其 Key 值快速检索各个元素。</p></li><li><p>在 unordered_map 容器中，Key 值通常用来唯一标识元素，映射值是与该 Key 值关联内容的对象。Key 值与映射值的类型可能不同。</p></li><li><p>在 unordered_map 内部，元素没有按照其 Key 值与映射值的任何顺序进行排序 ，而是根据它们的 Hash 值组织成桶，允许它们通过其 Key 值直接快速访问单个元素（通常具有常数等级的平均时间复杂度）。</p></li><li><p>unordered_map 容器与 map 容器相比，通过 Key 值访问各个元素的速度更快，然而通过其元素子集进行范围迭代的效率通常较低。</p></li><li><p>unordered_map 实现了直接访问操作符 (operator[])，它允许使用 Key 值作为输入参数，直接访问映射值。</p></li><li><p>容器中的迭代器至少是前向迭代器。</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>引入头文件 <strong><unordered_map></strong> </p></li><li><p>unordered_map<key,value> m;</p></li><li><p>m.size();    //元素数量</p></li><li><p>m.insert(x);</p></li><li><p>m.find(key);</p><p>m.count(key);</p></li><li><p>m.erese(key);</p></li><li><p>m[key] → value</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li><p>基本使用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="string">&#x27;a&#x27;</span>] = <span class="number">9</span>;</span><br><span class="line">m[<span class="string">&#x27;?&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">m[<span class="string">&#x27;z&#x27;</span>] = <span class="number">99</span>;</span><br><span class="line">m[<span class="string">&#x27;A&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">m[<span class="string">&#x27;Z&#x27;</span>] = <span class="number">-2</span>;</span><br><span class="line">m[<span class="string">&#x27; &#x27;</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出元素个数</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找&#x27; &#x27;元素是否存在，若存在，输出其对应的值；</span></span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">count</span>(<span class="string">&#x27; &#x27;</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; m[<span class="string">&#x27; &#x27;</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出内部所有元素，体现无序性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">begins</span>(); it != m.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">Z -2</span><br><span class="line">  0</span><br><span class="line">A 50</span><br><span class="line">? 5</span><br><span class="line">z 99</span><br><span class="line">a 9</span><br></pre></td></tr></table></figure></li><li><p>Leetcode <a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Key is the number and value is its index in the vector</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hash;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> &lt;<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> numberToFind = target - number[i];</span><br><span class="line">            <span class="comment">//if numberToFind is found in map, return them</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(numberToFind) != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(hash[numberToFind);</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">                hash[numbers[i]] = i;                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;                              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 散落的知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建记录</title>
      <link href="/post/7cfd23b7.html"/>
      <url>/post/7cfd23b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="2023-2"><a href="#2023-2" class="headerlink" title="2023.2"></a>2023.2</h2><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>生成markdown文件，在命令行输入:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>在blog根目录下的source文件夹中的post文件夹会多一个 <strong>博客名字.md</strong> 的markdown文件，打开即可进行编辑。</p><h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>markdown语法参考链接 <a href="https://www.appinn.com/markdown/">Markdown语法说明（简体中文版）</a></p><h3 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h3><p>在根目录下git命令行输入三连指令，即可完成新页面的发布</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>如果在发布前想预览生成网站的效果，可输入</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><hr><h2 id="2024-7-25"><a href="#2024-7-25" class="headerlink" title="2024.7.25"></a>2024.7.25</h2><p>近日心血来潮地想起自己两年前心血来潮搭的网站，想到自己已经为这个域名掏了三年的钱包，还是要好好利用起来，于是再次开始维护。</p><h3 id="主页顶部图片更改"><a href="#主页顶部图片更改" class="headerlink" title="主页顶部图片更改"></a>主页顶部图片更改</h3><p>维护时首先想到的就是把主页顶部图片换了，顶部图片的更换非常简单，我目前使用的是butterfly主题，只需要在<code>_config.butterfly.yml</code>中修改<code>index_img</code>后的图片链接即可：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The banner image of home page （主页封面图片）</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/img/The_Valley_of_the_Wind.jpg</span></span><br></pre></td></tr></table></figure><h3 id="文章页背景更换"><a href="#文章页背景更换" class="headerlink" title="文章页背景更换"></a>文章页背景更换</h3><p>之前不知什么时候给博客更换了一个花里胡哨的背景，使用一段时间后还是觉得白底黑字看起来最舒服，于是决定修改当前背景。背景更换需打开<code>Blog\themes\butterfly\source\css</code>目录下的<code>custom.css</code>，修改其中的<code>#web_bg</code></p><p>背景设置为渐变色</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#web_bg &#123;</span></span><br><span class="line"><span class="attr">background-image:</span> <span class="string">linear-gradient(to</span> <span class="string">top,</span> <span class="comment">#fef9d7 0%, #d299c2 100%);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>背景设置为纯色</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#web_bg &#123;</span></span><br><span class="line"><span class="attr">background-color:</span> <span class="comment">#ffffff;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="部署时spawn-failed报错问题的解决"><a href="#部署时spawn-failed报错问题的解决" class="headerlink" title="部署时spawn failed报错问题的解决"></a>部署时spawn failed报错问题的解决</h3><p>在完成一些参数的修改后，使用<code>hexo d</code>部署时却出现了spawn failed的报错。发现报错后首先尝试了目前主流的两种解决方案：</p><h4 id="1-重置git的deploy文件夹"><a href="#1-重置git的deploy文件夹" class="headerlink" title="1. 重置git的deploy文件夹"></a>1. 重置git的deploy文件夹</h4><p>删除blog文件夹中的<code>.deploy_git</code>文件夹，然后在终端cd进这个文件夹后输入<code>git config --global core.autocrlf false</code></p><h4 id="2-修改git-repo配置地址"><a href="#2-修改git-repo配置地址" class="headerlink" title="2. 修改git repo配置地址"></a>2. 修改git repo配置地址</h4><p>打开<code>_config.yml</code>配置文件，修改以下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"></span><br><span class="line"><span class="attr">repo:</span> <span class="string">https://github.com/yourname/yourname.github.io.git</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>其中的repo修改为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br></pre></td></tr></table></figure><h4 id="3-重置GitHub-SSH密钥"><a href="#3-重置GitHub-SSH密钥" class="headerlink" title="3. 重置GitHub SSH密钥"></a>3. 重置GitHub SSH密钥</h4><p>很遗憾，上面的两种方法最终都没能解决我的问题，但在查看<a href="https://blog.zhheo.com/p/128998ac.html">张洪Heo</a>的博客文章后我意识到可能是<strong>GitHub SSH密钥设置</strong>出现了问题。果然，在git命令行中尝试使用SSH连接时出现了错误。</p><p>git命令行输入：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey)</span><br></pre></td></tr></table></figure><p>登录许久未使用的用于部署网站的GitHub账号，发现<strong>原有的SSH密钥已被删除</strong>，原来作为安全预防措施，GitHub会自动删除一年内未使用过的 SSH 密钥。于是重新走了一遍设置GitHub密钥的流程（具体可参考“<a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a>”），问题终于成功解决。</p><hr><h2 id="2024-8-12"><a href="#2024-8-12" class="headerlink" title="2024.8.12"></a><strong>2024.8.12</strong></h2><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>在markdown中插入图片的语法为</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">src</span>)</span><br></pre></td></tr></table></figure><p>其中<code>src</code>既可以是本地图片的绝对/相对路径，比如<code>../images/test.png</code>，也可以是URL。<code>alt</code>是图片的注释，可以为空。</p><p>考虑到本地图片在网页中的加载速度较慢，且插入至markdown中的步骤比较繁琐，我采用了SMMS图床＋Typora自动上传的方法，这样只需要直接将图片粘贴到Typora中，图片就可以自动上传到图床。具体的配置步骤见<a href="https://blog.csdn.net/m0_56416743/article/details/132021539">Typora1.6.7+图床SMMS自动上传教程(PicGo-Core(command line)方式</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP问题</title>
      <link href="/post/41ef174f.html"/>
      <url>/post/41ef174f.html</url>
      
        <content type="html"><![CDATA[<h1 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h1><ul><li><strong>NP问题</strong> 的全称是：Non deterministic Ploynomial问题，即非确定性多项式问题。</li><li><strong>多项式时间（Polynomial time）</strong> 在计算复杂度理论中，指的是一个问题的计算时间m(n)不大于问题大小n的多项式倍数。</li><li><p><strong>什么是非确定性问题？</strong> </p><p>  有些计算问题是确定性的，比如加减乘除之类，你只要按照公式推导，按部就班一步步来，就可以得到结果。但是，有些问题是无法按部就班直接地计算出来。比如，找大质数的问题。有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的。再比如，大的合数分解质因数的问题，有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式。</p><p>  这种问题的答案，是无法直接计算得到的，只能通过间接的“猜算”来得到结果。这也就是<em>非确定性问题</em>。而这些问题的通常有个算法，它不能直接告诉你答案是什么，但可以告诉你，某个可能的结果是正确的答案还是错误的。这个可以告诉你“猜算”的答案正确与否的算法，假如可以在多项式时间内算出来，就叫做<em>多项式非确定性问题</em>。</p></li><li><strong>NP问题</strong> 就是非确定性的多项式问题，也就是说，可以在多项式时间内验证一个解是否正确的问题是NP问题。</li><li><p><strong>P问题</strong> 是能在多项式时间内求出其解的问题，所有的P问题都是NP问题，但是是否P=NP，目前还没有被证明。</p><p>  （不是所有的NP问题都是难解的问题，比如数组排序的问题就是P类问题，但是P属于NP问题，所它也是NP问题，但是他并不难解。）</p></li><li><p><strong>NP困难问题：</strong> 对于一个判定问题A,如果所有的NP问题都可以多项式时间规约到A，那么这个问题就是NP困难问题。</p></li><li><p><strong>NPC问题：</strong> 对于一个NP问题A，如果所有的NP问题都可以多项式时间规约到A，那么这个问题就是NP困难问题。</p></li><li><p><strong>NPC</strong>，也称NP完全问题，它是NP问题的一个子类，比如哈密尔顿回路问题就是NPC问题。它是这样描述的，给定N个顶点，以及任意两个顶点之间的距离，求出一条回路，使其经过每个顶点，且回路的总距离最短。这个问题可以通过枚举求出解，但是他的时间复杂度是(N-1)!,随着N的增大，要计算解是不可能的。</p><p>  NPC有一种性质，那就是如果能证明NPC问题可以在多项式时间内求出其解，则所有的NP都可以在多项式时间内求解了，即P=NP成立。所以，我们一般认为NPC问题是难解的问题，因为他不太可能存在一个多项式时间的算法（如果存在则所有的NP问题都存在多项式时间算法，这太不可思议了，但是也不是不可能）。</p></li><li><p><strong>NP完全问题的证明:</strong> 要证明一个判定问题是NP完全的,只要在NP完全类中找到一个问题A,将这个问题归约到待证明问题即可.要证明问题是NP完全是很困难的,因为很多问题之间的转化过程是很难想到的.第一个被证明的NP完全问题是可满足性问题,它是判定一个合取范式的布尔公式F是否存在真值指派的问题.在很多NP完全问题的证明中,我们都可以用这个问题来归约,这里不再详述。</p></li></ul><hr><p>转自<a href="https://blog.csdn.net/zxj1988/article/details/6275458">CSDN博主zxj1988的文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 散落的知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
