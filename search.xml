<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Part 4 Connectivity | 功能连接分析</title>
      <link href="/post/c9dcd8c5.html"/>
      <url>/post/c9dcd8c5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-25-Introduction-to-the-Various-Connectivity-Analyses"><a href="#Chapter-25-Introduction-to-the-Various-Connectivity-Analyses" class="headerlink" title="Chapter 25 Introduction to the Various Connectivity Analyses"></a>Chapter 25 Introduction to the Various Connectivity Analyses</h1><ul><li>Connectivity：指在同一时刻下考虑多个信号的分析。</li><li>需区分的概念：<ul><li><strong>functional connectivity：</strong>linear or nonlinear covariation between fluctuations in activity recorded from distinct neural networks. 更接近于<strong>相关性（correlation）</strong></li><li><strong>effective connectivity：</strong>a causal influence of activity in one neural network over activity in another neural network. 更接近于<strong>因果关系（causation）</strong></li></ul></li><li>两个电极之间的连接性（connectivity）可以反映不同大脑区域之间的真实连接，也可能是由于这两个电极测量了来自同一脑源的活动。</li></ul><hr><h1 id="Chapter-26-Phase-Based-Connectivity"><a href="#Chapter-26-Phase-Based-Connectivity" class="headerlink" title="Chapter 26 Phase-Based Connectivity"></a>Chapter 26 Phase-Based Connectivity</h1><h2 id="ISPC-Intersite-phase-clustering"><a href="#ISPC-Intersite-phase-clustering" class="headerlink" title="ISPC (Intersite phase clustering)"></a>ISPC (Intersite phase clustering)</h2><p>ISPC是一种用以描述基于相位的功能连接的方法，与ITPC相似，但计算的是两电极之间随<strong>时间或试次</strong>变化的<strong>相位角差</strong>的平均值</p><script type="math/tex; mode=display">ISPC_f=|n^{-1}\sum^n_{t=1}e^{i(\phi_{xt}-\phi_{yt})}|</script><p>其中 <strong>n</strong> 是时间点数目或试次数目，<strong>$\phi_x$</strong> 和 <strong>$\phi_{y}$</strong> 是电极 x 和 y 在频率f下的相角，t是时间点或试次。</p><ul><li>ISPC反映的不是两电极相位差的大小，而是<strong>相位差随时间或试次的一致性</strong></li><li>ISPC是无向的（A→B的ISPC和B→A的相同）</li></ul><h2 id="ISPC-time-and-ISPC-trial"><a href="#ISPC-time-and-ISPC-trial" class="headerlink" title="ISPC-time and ISPC-trial"></a>ISPC-time and ISPC-trial</h2><p>通过上面的公式，我们可以得到的是在<strong>一个时间窗口</strong>内<strong>一个试次</strong>的ISPC，如果有多个试次，而且我们想要得到ISPC随时间/试次的变化，可以采用如下方法：</p><ul><li><p><strong><em>ISPC-time</em></strong>：设置一个滑动的小时间窗，计算单个试次在每个时间窗下的ISPC（类似于short-time FFT），得到多个试次下的ISPC随时间的变化，最后再进行试次平均，得到ISPC<strong>在不同时刻下</strong>的值。小时间窗的长度选取规则类似于wavelet中the number of cycles的选取。</p></li><li><p><strong><em>ISPC-trials</em></strong>：关注某一<strong>时间点</strong>下<strong>不同试次</strong>的相位差大小。ISPC-trial所反映是在不同的试次下，两电极间的相位差是否能保持一致，其值越大，说明相位差在不同试次下越能保持一致。</p><ul><li><p>对试次的数目比较敏感，试次数目需要足够多，才能获得稳定的结果</p></li><li><p>如果在不同实验条件下的试次不同，可以考虑使用 <strong>weighted ISPC-trials (wISPC-trials)</strong>，其原理与 wITPC 相近。</p></li></ul></li><li><p>计算时的区别：</p><ul><li><p><strong><em>ISPC-time</em></strong>：先在滑动时间窗内时间平均，最后试次平均</p></li><li><p><strong><em>ISPC-trial</em></strong>：在不同时间点下进行试次平均</p><p><img src="https://s2.loli.net/2024/09/10/CbP85UnuzvMhg2Z.png" alt="image-20240910225214537" style="zoom:50%;" /></p></li></ul></li><li><p><strong>Matlab代码实现</strong>：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 对于频率，通常采用对数分布</span></span><br><span class="line">freqs2use  = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">4</span>),<span class="built_in">log10</span>(<span class="number">30</span>),<span class="number">15</span>); <span class="comment">% 4-30 Hz in 15 steps</span></span><br><span class="line"><span class="comment">% 非频率值，可以采用线性分布，timewindow的宽度是下面取值的两倍</span></span><br><span class="line">timewindow = <span class="built_in">linspace</span>(<span class="number">1.5</span>,<span class="number">3</span>,<span class="built_in">length</span>(freqs2use)); <span class="comment">% number of cycles on either end of the center point (1.5 means a total of 3 cycles))</span></span><br></pre></td></tr></table></figure><p><strong>ISPC-time (ispc)</strong> 和 <strong>ISPC-trial (ps)</strong> 的计算：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:<span class="built_in">length</span>(freqs2use)</span><br><span class="line">    <span class="comment">% phase angle differences（维度为time×trials）</span></span><br><span class="line">    phase_diffs = phase_sig1-phase_sig2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% compute ISPC over trials（trial平均，时间没有平均，所以ps的是&quot;频率×时间&quot;的矩阵）</span></span><br><span class="line">    ps(fi,:) = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase_diffs(times2saveidx,:)),<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 计算每一个时间点（timewindow中点）下的ISPC</span></span><br><span class="line">    <span class="keyword">for</span> ti=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% compute phase synchronization（ISPC-time，每个时间窗可计算出一个值，1×trial）</span></span><br><span class="line">        phasesynch = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*phase_diffs(times2saveidx(ti)-time_window_idx:times2saveidx(ti)+time_window_idx,:)),<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% average over trials（trial平均）</span></span><br><span class="line">        ispc(fi,ti) = <span class="built_in">mean</span>(phasesynch);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> <span class="comment">% end frequency loop</span></span><br></pre></td></tr></table></figure><p>最后可以让每个时间点<strong>减去baseline</strong>时间内的ISPC平均值，突出任务相关影响：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% ISPC-time</span></span><br><span class="line">contourf(times2save,freqs2use,ispc-<span class="built_in">repmat</span>(<span class="built_in">mean</span>(ispc(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">size</span>(ispc,<span class="number">2</span>)),<span class="number">20</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% ISPC-trial</span></span><br><span class="line">contourf(times2save,freqs2use,<span class="built_in">bsxfun</span>(@minus,ps,<span class="built_in">mean</span>(ps(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>)),<span class="number">20</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Spectral-Coherence-Magnitude-Squared-Coherence-波谱相干"><a href="#Spectral-Coherence-Magnitude-Squared-Coherence-波谱相干" class="headerlink" title="Spectral Coherence (Magnitude-Squared Coherence) | 波谱相干"></a><strong>Spectral Coherence (Magnitude-Squared Coherence)</strong> | 波谱相干</h2><p>波谱相干可以理解为是把<strong>信号功率作为权重</strong>的<strong>加权ISPC</strong></p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>常见的波谱相干公式：</p><script type="math/tex; mode=display">Coher_{xy}=\left| \frac{S_{xy}}{S_{xx}S_{yy}}\right|</script><p>$S_{xy}$ 是电极x和y处的交叉谱密度，$S_{xx}$ 和 $S_{yy}$ 是电极x和y处的自谱密度。上式中的分子有时会平方，从而和分母的量级相配合。</p><p>为便于理解，可以将波谱相干公式写成下面的形式：</p><script type="math/tex; mode=display">C_{xy}=\left| n^{-1}\sum^n_{t=1}\lvert m_{tx}m_{ty}\rvert e^{i\phi_{txy}}\right|^{2}</script><p>$m_x$和$m_y$是解析信号（没有负频率分量的复值函数）X和Y的功率大小（magnitudes），$\phi_{xy}$是电极X和Y之间的相位角差，t指trial或时间点。</p><p>可以发现使用这一公式计算出的$C_{xy}$值会随着功率大小改变，而功率又会随频率、时间、任务等改变，所以可以将这一公式进行归一化，得到如下波谱相干公式：</p><script type="math/tex; mode=display">Coher_{xy}=\frac{C_{xy}}{\left(n^{-1}\sum^n_{t=1}|m_{tx}|^2\right)\left(n^{-1}\sum^n_{t=1}|m_{ty}|^2\right)}</script><p>由这种方法得到的波谱相干性大小将介于0和1之间，1代表完全相干，0代表完全独立。</p><h3 id="Matlab代码实现"><a href="#Matlab代码实现" class="headerlink" title="Matlab代码实现"></a>Matlab代码实现</h3><ul><li>计算功率强度时，使用信号乘以其共轭的方法 <code>sig1.*conj(sig1)</code>，耗时比直接平方<code>(sig1).^2</code>更短</li><li>计算交叉谱密度$S_{xy}$时，使用信号1乘以信号2的共轭的方法<code>sig1.*conj(sig2)</code>，耗时比欧拉公式<code>abs(sig1).*abs(sig2).*exp(1i*(angle(sig1)-angle(sig2)))</code>更短</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercises Part 4 | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd3e4.html"/>
      <url>/post/c9dcd3e4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Exercises-22-Surface-Laplacian"><a href="#Exercises-22-Surface-Laplacian" class="headerlink" title="Exercises 22 | Surface Laplacian"></a>Exercises 22 | Surface Laplacian</h1><ol><li><p>Based on the topographical maps of ERPs in figure 22.6 (plate 12) , select one electrode whose activity you think might look similar before and after computing the surface Laplacian, and one electrode whose activity you think might look different before and after the surface Laplacian. </p><p>(1) look similar before and after computing the surface Laplacian: <strong>FC1</strong></p><p>(2) look different before and after the surface Laplacian: <strong>PO8</strong></p><p><img src="https://s2.loli.net/2024/09/06/91IQ6UqVTAFykvG.png" alt="Figure22.6"></p></li><li><p>Perform a time-frequency decomposition of the data from those two electrodes both before and after computing the surface Laplacian (that is, compute the surface Laplacian on the raw data before applying a time-frequency decomposition). Compute both power (decibels normalized using a baseline period of your choice) and ITPC. </p></li><li><p>Plot the results using the same color scaling for before and after the surface Laplacian. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 获得Surface Laplacian处理前后的数据</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"><span class="comment">% extract XYZ coordinates from EEG structure</span></span><br><span class="line">X = [EEG.chanlocs.X];</span><br><span class="line">Y = [EEG.chanlocs.Y];</span><br><span class="line">Z = [EEG.chanlocs.Z];</span><br><span class="line"><span class="comment">% compute surface laplacian</span></span><br><span class="line">lap_data = laplacian_perrinX(EEG.data,X,Y,Z);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算Power</span></span><br><span class="line">electrode = [<span class="string">&quot;FC1&quot;</span>, <span class="string">&quot;PO8&quot;</span> ,<span class="string">&quot;FC4&quot;</span>];</span><br><span class="line">electrodeidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(electrode));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(electrode) </span><br><span class="line">    electrodeidx(<span class="built_in">i</span>) = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,electrode(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">frequencies = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">2</span>),<span class="built_in">log10</span>(<span class="number">40</span>),<span class="number">30</span>);</span><br><span class="line"><span class="comment">%% calculate power</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line"></span><br><span class="line">freqspread = <span class="built_in">linspace</span>(<span class="number">0.8</span>,<span class="number">6</span>,<span class="built_in">length</span>(frequencies)); <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.1</span>;</span><br><span class="line">nyquist = <span class="built_in">repmat</span>(EEG.srate/<span class="number">2</span>, <span class="built_in">size</span>(frequencies));</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">ones</span>(<span class="built_in">length</span>(frequencies),<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequencies-freqspread)&#x27; (frequencies-freqspread)&#x27; (frequencies+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequencies+freqspread)&#x27; nyquist&#x27; ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(electrode),<span class="built_in">length</span>(frequencies),<span class="number">3</span>*EEG.pnts,EEG.trials);</span><br><span class="line">filter_result_lap = <span class="built_in">zeros</span>(<span class="built_in">length</span>(electrode),<span class="built_in">length</span>(frequencies),<span class="number">3</span>*EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    data2filter = [<span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:))); <span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:)); <span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:)))];</span><br><span class="line">    data2filter_lap= [<span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(lap_data(electrodeidx(electrodei),:,:))); <span class="built_in">squeeze</span>(lap_data(electrodeidx(electrodei),:,:)); <span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(lap_data(electrodeidx(electrodei),:,:)))];</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">        filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        filter_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">        filter_result_lap(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter_lap));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">filter_result = filter_result(:,:,<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span>:<span class="keyword">end</span>*<span class="number">2</span>/<span class="number">3</span>,:);</span><br><span class="line">filter_result_lap = filter_result_lap(:,:,<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span>:<span class="keyword">end</span>*<span class="number">2</span>/<span class="number">3</span>,:);</span><br><span class="line">power_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">power_result_lap = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result_lap).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(power_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">baseline_power_lap = <span class="built_in">mean</span>(power_result_lap(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">power_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,power_result,baseline_power));</span><br><span class="line">power_dbconverted_lap = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,power_result_lap,baseline_power_lap));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% calculate ITPC</span></span><br><span class="line">ITPC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">angle</span>(filter_result)),<span class="number">4</span>));</span><br><span class="line">ITPC_lap = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">angle</span>(filter_result_lap)),<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">time2plot = [<span class="number">-300</span>, <span class="number">1000</span>];</span><br><span class="line">time2plotidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(time2plot));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    [~,time2plotidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-time2plot(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    <span class="built_in">figure</span>(electrodei)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(power_dbconverted(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;Before Laplacian&#x27;</span>, [<span class="string">&#x27;Power from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(ITPC(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0</span> <span class="number">0.3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;Before Laplacian&#x27;</span>, [<span class="string">&#x27;ITPC from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(power_dbconverted_lap(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;After Laplacian&#x27;</span>, [<span class="string">&#x27;Power from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(ITPC_lap(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0</span> <span class="number">0.3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;After Laplacian&#x27;</span>, [<span class="string">&#x27;ITPC from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/06/c5YvOF8VH3RBhEt.png" alt="Ex_22(1)" style="zoom: 50%;" /></p><p><img src="https://s2.loli.net/2024/09/06/8vFAIJibtjwNEq9.png" alt="Ex_22(2)" style="zoom:50%;" /></p><ol><li>Are there any salient differences in the time-frequency power or ITPC results before versus after application of the surface Laplacian, and do the differences depend on the frequency? How would you interpret similarities and differences at different frequency bands? </li></ol><ul><li>There are differences and the differences depend on the frequency, like the power from PC1 at 10 Hz and from PO8 at 15 Hz.</li></ul><hr><h1 id="Exercises-23-Principal-Components-Analysis-PCA"><a href="#Exercises-23-Principal-Components-Analysis-PCA" class="headerlink" title="Exercises 23 | Principal Components Analysis (PCA)"></a>Exercises 23 | Principal Components Analysis (PCA)</h1><ol><li><p>Perform PCA on broadband data using two time windows, one before and one after trial onset (e.g., – 500 to 0 ms and 100 to 600 ms). </p></li><li><p>Plot topographical maps and time courses of the first four components. To construct the PCA time courses, multiply the PCA weights defined by the pre- and posttrial time windows with the electrode time courses from the entire trial. Do you notice any differences in the topographical maps or time courses from before versus after stimulus onset? How would you interpret differences and/or similarities? </p></li><li><p>Repeat this exercise but after bandpass filtering in two different frequency bands. Make sure there are no edge artifacts in the pretrial time window (consider using reflection, if necessary, as described in figure 7.3). Justify your decision of frequency bands and time window width(s). Comment on any qualitative similarities and differences you observe between frequency bands and time windows and similarities and differences between the frequencyband-specific and broadband signal from the results obtained in the previous exercise. </p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part 4 Spatial Filters | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd8c4.html"/>
      <url>/post/c9dcd8c4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-22-Surface-Laplacian"><a href="#Chapter-22-Surface-Laplacian" class="headerlink" title="Chapter 22 Surface Laplacian"></a>Chapter 22 Surface Laplacian</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>采用Surface Laplacian可以突出局部的空间特征，削弱空间上广泛分布的活动</li><li>“Surface Laplacian” 和 “Current Scalp Dencity” 的区别<ul><li>Surface Laplacian 只是一种空间滤波的方法</li><li>Current Scalp Dencity 强调滤波后的结果</li></ul></li><li>Surface Laplacian只能用于<strong>EEG</strong>（不能用于MEG），且通常用于<strong>电极数目大于64</strong>的EEG数据</li><li>The Laplacian is more sensitive to <strong>radial dipoles</strong> than it is to tangential dipoles.</li><li><p>Activity seen in the surface Laplacian is dominated (although not necessarily entirely driven) by radial dipoles in regions of the cortex close to the skull (such as  <strong>gyral crowns</strong>). </p></li><li><p>The Laplacian must be applied to time-domain data, not to time-frequency data.</p></li></ul><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>The <strong>weights</strong> that are applied to the data such that the activity at each electrode becomes a weighted sum of activity of all other electrodes.</p><script type="math/tex; mode=display">G_{ij}=(4\pi)^{-1}\sum^{order}_{n=1}\frac{(2n+1)P_n(cosdist_{ij})}{(n(n+1))^m}</script><script type="math/tex; mode=display">H_{ij}=(4\pi)^{-1}\sum^{order}_{n=1}\frac{-2(n+1)P_n(cosdist_{ij})}{(n(n+1))^{m-1}}</script><p>The <strong>cosine distance</strong> among all pairs of electrodes</p><script type="math/tex; mode=display">cosdist_{ij}=1-\frac{(X_i-X_j)^2+(Y_i-Y_j)^2+(Z_i-Z_j)^2}{2}</script><p>The <strong>Laplacian for electrode <em>i</em></strong> at one time point</p><script type="math/tex; mode=display">lap_i=\sum^{nelec}_{j=1}C_iH_{ij}</script><p>The C matrix is where <strong>the data</strong> are finally introduced</p><script type="math/tex; mode=display">C_i=d_i-\frac{\sum^{nelec}_{j=1}d_j}{\sum^{nelec}_{j=1}Gs_j^{-1}}Gs^{-1}</script><script type="math/tex; mode=display">d_i=data_j^{-1}Gs</script><script type="math/tex; mode=display">Gs=G+\lambda</script><h2 id="Surface-Laplacian-for-Connectivity-Analyses"><a href="#Surface-Laplacian-for-Connectivity-Analyses" class="headerlink" title="Surface Laplacian for Connectivity Analyses"></a>Surface Laplacian for Connectivity Analyses</h2><ul><li>经过Surface Laplacian的处理后，电极间信号的相关性与电极距离的联系减弱，但间隔比较近的电极仍然会相互影响，因此应该避免对<strong>间隔5cm以内</strong>的电极采用空间相关性的规律解释。</li></ul><p><img src="https://s2.loli.net/2024/09/02/meIPWzUrMxJtYs6.png" alt="image-20240902170921494" style="zoom:67%;" /></p><hr><h1 id="Chapter-23-Principal-Components-Analyses-PCA"><a href="#Chapter-23-Principal-Components-Analyses-PCA" class="headerlink" title="Chapter 23 Principal Components Analyses (PCA)"></a>Chapter 23 Principal Components Analyses (PCA)</h1><p><a href="https://www.bilibili.com/video/BV1E5411E71z/?spm_id_from=333.337.search-card.all.click&amp;vd_source=e7f03c857e620b80dcde0db3e7f51d26">用最直观的方式告诉你：什么是主成分分析PCA</a></p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li>与 Surface Laplacian 相反，PCA反映的不是电极的局部特征，而是弱化局部特征后的总体特征</li></ul><p><img src="https://s2.loli.net/2024/09/04/CbsgdyX2rcZk3WV.png" alt="image-20240904111437587" style="zoom: 67%;" /></p><h2 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h2><h3 id="计算协方差"><a href="#计算协方差" class="headerlink" title="计算协方差"></a>计算协方差</h3><p>协方差的矩阵计算公式:</p><script type="math/tex; mode=display">covariance = (n-1)^{-1}(X-\bar{X})(X-\bar{X})^T</script><p>如果把<strong>电极</strong>作为<strong>变量</strong>，电极数目为变量的维度，每一个<strong>时间点</strong>下各个电极的数据看作一次<strong>观测</strong>得到的结果，组成一个列向量，那么经过多个时间点的观测后，我们可以得到一个 <strong>$electrodes(m) \times time\ points(n)$</strong> 的矩阵$X$：</p><script type="math/tex; mode=display">X=\begin{bmatrix} d_{e_1t_1} & d_{e_1t_2} & \cdots & d_{e_1t_n}\\ d_{e_2t_1} & d_{e_2t_2} & \cdots & d_{e_2t_n}\\ \vdots & \vdots & \ddots & \vdots\\ d_{e_mt_1} & d_{e_mt_2} & \cdots & d_{e_mt_n}\end{bmatrix}</script><p>协方差公式中的$\bar{X}$是各列向量的平均值，即关于时间点的平均值，<strong>n</strong>是时间点的数目。协方差矩阵的对角线元素则为对应维度的方差</p><p>对于多个试次的数据，可以采用<strong>三种方式</strong>计算协方差：</p><ul><li>先计算<strong>ERP</strong>，再以ERP作为各数据值得到矩阵$X$。该计算方法得到的是<strong>phase-locked</strong> (evoked) covariance</li><li>将各试次作为不同的观测点，得到的$X$矩阵有$time\ points \times trials$列，进一步以此矩阵计算协方差。得到的是<strong>total</strong> (phase-locked and non-phase-locked) covariance</li><li>（常用）先对每一个试次计算协方差，最后平均。该方法可以提高信噪比，得到的是<strong>total</strong> (phase-locked and non-phase-locked) covariance</li></ul><h3 id="计算协方差矩阵的特征值和特征向量"><a href="#计算协方差矩阵的特征值和特征向量" class="headerlink" title="计算协方差矩阵的特征值和特征向量"></a>计算协方差矩阵的特征值和特征向量</h3><p>采用matlab中的<code>eig</code>或<code>svd</code>函数计算协方差矩阵的特征值和特征向量。注意，Matlab函数<code>eig</code>以<strong>升序</strong>返回特征值和特征向量，但是让结果按<strong>降序</strong>排序会更直观。</p><ul><li>特征向量是旋转后的坐标轴方向</li><li>特征值是旋转后坐标轴的长度，经归一化可后作为对应主成分的<strong>百分比方差</strong>，即对<strong>每个特征值除以所有特征值的和，再乘以100</strong></li></ul><p>特征向量矩阵中的每一列都是一个<strong>主成分</strong>，每一行存储每个电极的<strong>权重（weight）</strong>，通常权重的正负符号不重要</p><h3 id="结果的呈现与解释说明"><a href="#结果的呈现与解释说明" class="headerlink" title="结果的呈现与解释说明"></a>结果的呈现与解释说明</h3><ul><li><strong>PCA map：</strong>特征向量矩阵每一列可由<code>topoplot</code>绘制成一张<strong>PCA map</strong>图</li><li><strong>time course：</strong>将每个时间点下的各电极<strong>权重（特征向量中的一行）</strong>与电极对应的时间序列<strong>数据（$X_i-\bar{X_i}$）</strong>相乘，再相加，得到一个时间点下的<strong>time course</strong>。每一个主成分（每一列）对应一个权重，也就对应一组time course（即<strong>各电极的加权和</strong>）。得到主成分时间序列数据（time course）后，可以对这些数据采用与其他时间序列数据相同的方法进行分析，比如计算ERP或时频功率等。</li><li>可以根据特征值的大小对主成分进行取舍</li><li>可以计算所有特征值比阈值低的成分对应的方差，以估计全局脑电图响应的“噪声”</li><li>特征值下降的快慢可以理解为系统的复杂度的大小，下降得越快，被舍弃的成分越多，系统的复杂度越小</li></ul><h2 id="Independent-Components-Analysis（ICA）"><a href="#Independent-Components-Analysis（ICA）" class="headerlink" title="Independent Components Analysis（ICA）"></a>Independent Components Analysis（ICA）</h2><h3 id="PCA和ICA的区别"><a href="#PCA和ICA的区别" class="headerlink" title="PCA和ICA的区别"></a>PCA和ICA的区别</h3><ul><li>PCA的作用：去相关性、降维</li><li>ICA的作用：分离独立源</li></ul><hr><h1 id="Chapter-24-Single-Dipole-and-Distributed-Source-Imaging"><a href="#Chapter-24-Single-Dipole-and-Distributed-Source-Imaging" class="headerlink" title="Chapter 24 Single-Dipole and Distributed-Source Imaging"></a>Chapter 24 Single-Dipole and Distributed-Source Imaging</h1><h2 id="Forward-Solution-amp-Inverse-Problem"><a href="#Forward-Solution-amp-Inverse-Problem" class="headerlink" title="Forward Solution &amp; Inverse Problem"></a>Forward Solution &amp; Inverse Problem</h2><p><img src="https://s2.loli.net/2024/09/05/sSDWbXt2zO4d9Pv.png" alt="image-20240905155005900" style="zoom:50%;" /></p><h2 id="Inverse-Problem"><a href="#Inverse-Problem" class="headerlink" title="Inverse Problem"></a>Inverse Problem</h2><ul><li><strong>Dipole Fitting：</strong>需要确定偶极子（dipole）的位置、方向、大小</li><li><strong>Distributed-Source Imaging：</strong>已经确定了偶极子的位置和方向，只需要确定大小</li><li>you should be cautious when hearing claims of functional-anatomical dissociations of <strong>less than a few centimeters</strong> based on results of source reconstruction. Such high spatial accuracy is possible but not common. </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercises Part 3 | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd3e3.html"/>
      <url>/post/c9dcd3e3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Exercises-10-Convolution"><a href="#Exercises-10-Convolution" class="headerlink" title="Exercises 10 | Convolution"></a>Exercises 10 | Convolution</h1><h2 id="10-6-1"><a href="#10-6-1" class="headerlink" title="10.6.1"></a>10.6.1</h2><ol><li>Create two kernels for convolution: one that looks like a U and one that looks like a decay function. There is no need to be too sophisticated in generating, for example, a Gaussian and an exponential; numerical approximations are fine.</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 10</span></span><br><span class="line"><span class="comment">% 1. Create two kernels </span></span><br><span class="line">kernel_U = [<span class="number">1</span> <span class="number">0.8</span> <span class="number">0.3</span> <span class="number">0.1</span> <span class="number">0</span> <span class="number">0.1</span> <span class="number">0.3</span> <span class="number">0.8</span> <span class="number">1</span>];</span><br><span class="line">kernel_decay = [<span class="number">1</span> <span class="number">0.9</span> <span class="number">0.8</span> <span class="number">0.7</span> <span class="number">0.5</span> <span class="number">0.3</span> <span class="number">0.2</span> <span class="number">0.1</span> <span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="10-6-2"><a href="#10-6-2" class="headerlink" title="10.6.2"></a>10.6.2</h2><ol><li>Convolve these two kernels with 50 time points of EEG data from one electrode. Make a plot showing the kernels, the EEG data, and the result of the convolution between the data and each kernel. Use time-domain convolution as explained in this chapter and as illustrated in the online Matlab code. Based on visual inspection, what is the effect of convolving the EEG data with these two kernels?</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2</span></span><br><span class="line"><span class="comment">% Snippet of EEG data</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">impEEG = EEG.data(<span class="number">47</span>,<span class="number">100</span>:<span class="number">149</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用自编函数计算impEEG与kernel_U的convolution</span></span><br><span class="line"><span class="comment">% data that we&#x27;ll use for convolution (must be zero-padded).</span></span><br><span class="line">dat4conv = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) impEEG <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) ];</span><br><span class="line"></span><br><span class="line"><span class="comment">% used for cutting the result of convolution</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize convolution output</span></span><br><span class="line">convolution_result_U = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(impEEG)+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% run convolution (note that kernel is flipped backwards) ti以外的范围会被舍弃，没必要计算</span></span><br><span class="line"><span class="keyword">for</span> ti=half_of_kernel_size+<span class="number">1</span>:<span class="built_in">length</span>(convolution_result_U)-half_of_kernel_size         </span><br><span class="line">    convolution_result_U(ti) = sum(dat4conv(ti:ti+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>).*kernel_U(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_U = convolution_result_U(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用Matlab自带函数conv()计算impEEG与kernel_decay的convolution</span></span><br><span class="line">convolution_result_decay = conv(impEEG,kernel_decay,<span class="string">&#x27;same&#x27;</span>);    <span class="comment">%% &#x27;same&#x27;:conv的结果与impfun的长度相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot kernels</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">311</span>)</span><br><span class="line"><span class="built_in">plot</span>(kernel_U,<span class="string">&#x27;bo-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(kernel_decay,<span class="string">&#x27;ro-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;decay&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.84</span> <span class="number">0.13512</span> <span class="number">0.064683</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Points&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Convolution kernels&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot Snippet of EEG data</span></span><br><span class="line">subplot(<span class="number">312</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Snippet of EEG data (EEG.data(47,100:149,10))&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot EEG data before and after convolution</span></span><br><span class="line">subplot(<span class="number">313</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;k-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_U./sum(kernel_U),<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_decay./sum(kernel_decay),<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;U-convolved&#x27;</span>,<span class="string">&#x27;decay-convolved&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.65</span> <span class="number">0.245</span> <span class="number">0.2</span> <span class="number">0.09</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;EEG data before and after convolution&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/17/Id6gBtjlfc2LV1M.png" alt="Ex_10" style="zoom:67%;" /></p><hr><h1 id="Exercises-11-Fourier-Transform"><a href="#Exercises-11-Fourier-Transform" class="headerlink" title="Exercises 11 | Fourier Transform"></a>Exercises 11 | Fourier Transform</h1><h2 id="11-12-1"><a href="#11-12-1" class="headerlink" title="11.12.1"></a>11.12.1</h2><p>Reproduce the top three panels of figure 11.12 three times. </p><ul><li><p>First, perform time-domain convolution using <strong>the “ manual ” convolution method</strong> shown in chapter 10. </p></li><li><p>Second, perform frequency-domain convolution using <strong>the discrete time Fourier transform</strong> presented at the beginning of this chapter. </p></li><li>Finally, perform frequency-domain convolution using <strong>the Matlab functions fft and ifft</strong> (do not use the function conv). (You can optionally reproduce the bottom panel of figure 11.12 for the frequency domain analyses; keep in mind that the power scaling is for display purposes only.) </li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 1. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">    conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"><span class="comment">% Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    <span class="comment">% create sine wave</span></span><br><span class="line">    sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">    fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line"></span><br><span class="line"><span class="comment">% inverse Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line">conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,eegdat4convol);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_manual,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_Fourier,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_fft,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;&quot;manual&quot; convolution method&#x27;</span>,<span class="string">&#x27;discrete time Fourier transform&#x27;</span>,<span class="string">&#x27;Matlab functions fft and ifft&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/dHleLSJOyTUR9xt.png" alt="Ex_11"></p><h2 id="11-12-2"><a href="#11-12-2" class="headerlink" title="11.12.2"></a>11.12.2</h2><p>From the three sets of Matlab code you have for reproducing figure 11.12 , run a computation time test. That is, time how long it takes Matlab to perform 1000 repetitions of each of the three methods for computing convolution that you generated in the previous exercise (do not plot the results each time). You can use the Matlab function pairs tic and toc to time a Matlab process. Plot the results in a bar plot, similar to figure 11.8 . </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 2. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line">t = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">        conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">1</span>) = toc;</span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="comment">% Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        <span class="comment">% create sine wave</span></span><br><span class="line">        sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">        fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% inverse Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">2</span>) = toc;</span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">    conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">3</span>) = toc;</span><br><span class="line"><span class="comment">%% plot results in a bar plot</span></span><br><span class="line">b = bar(t);</span><br><span class="line">labels = string(b(<span class="number">1</span>).YData);</span><br><span class="line">text(b(<span class="number">1</span>).XEndPoints,b(<span class="number">1</span>).YEndPoints,labels,<span class="string">&#x27;HorizontalAlignment&#x27;</span>,<span class="string">&#x27;center&#x27;</span>,<span class="string">&#x27;VerticalAlignment&#x27;</span>,<span class="string">&#x27;top&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>])</span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,&#123;<span class="string">&#x27;manual convolution&#x27;</span>;<span class="string">&#x27;DTFT&amp;IDTFT&#x27;</span>;<span class="string">&#x27;FFT&amp;IFFt&#x27;</span>&#125;)</span><br><span class="line">set(gca, <span class="string">&#x27;YScale&#x27;</span>, <span class="string">&#x27;log&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;time(s)&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/391pAN7iXbJEkdl.png" alt="Ex_11(2)" style="zoom: 50%;" /></p><h2 id="11-12-3"><a href="#11-12-3" class="headerlink" title="11.12.3"></a>11.12.3</h2><p>Generate a time series by creating and summing sine waves, as in figure 11.2B . Use between two and four sine waves, so that the individual sine waves are still somewhat visible in the sum. Perform a Fourier analysis (you can use the fft function) on the resulting time series and plot the power structure. Confirm that your code is correct by comparing the frequencies with nonzero power to the frequencies of the sine waves that you generated. Now try adding random noise to the signal before computing the Fourier transform. First, add a small amount of noise so that the sine waves are still visually recognizable. Next, add a large amount of noise so that the sine waves are no longer visually recognizable in the time domain data. Perform a Fourier analysis on the two noisy signals and plot the results. What is the effect of a small and a large amount of noise in the power spectrum? Are the sine waves with noise easier to detect in the time domain or in the frequency domain, or is it equally easy/difficult to detect a sine wave in the presence of noise? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Create sine waves</span></span><br><span class="line">srate = <span class="number">400</span>;</span><br><span class="line">time=<span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">N = <span class="built_in">length</span>(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create three sine waves</span></span><br><span class="line">s1 = <span class="number">20</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">3</span>*time);</span><br><span class="line">s2 = <span class="number">10</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">8</span>*time);</span><br><span class="line">s3 = <span class="number">5</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">15</span>*time);</span><br><span class="line">sum_Sine = s1+s2+s3;</span><br><span class="line"></span><br><span class="line"><span class="comment">% add random noise</span></span><br><span class="line">Sine_LitteNoise = sum_Sine + <span class="number">10</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line">Sine_LargeNoise = sum_Sine + <span class="number">40</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">linspace</span>(<span class="number">0</span>,srate/<span class="number">2</span>,<span class="built_in">floor</span>(N/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = fft(sum_Sine)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LitteNoise = fft(Sine_LitteNoise)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LargeNoise = fft(Sine_LargeNoise)./(N/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = <span class="built_in">abs</span>(FFT_Sine(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LitteNoise = <span class="built_in">abs</span>(FFT_LitteNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LargeNoise = <span class="built_in">abs</span>(FFT_LargeNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(time,sum_Sine);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Original time series&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">bar(f,FFT_Sine);</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LitteNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">bar(f,FFT_LitteNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LargeNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, large noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>)</span><br><span class="line">bar(f,FFT_LargeNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, large noise&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/I5wHdjzGkQmMDN6.png" alt="Ex_11(3)" style="zoom: 80%;" /></p><hr><h1 id="Exercises-12-Morlet-wavelets"><a href="#Exercises-12-Morlet-wavelets" class="headerlink" title="Exercises 12 | Morlet wavelets"></a>Exercises 12 | Morlet wavelets</h1><ol><li><p>Create a family of Morlet wavelets ranging in frequency from 2 Hz to 30 Hz in five steps. </p></li><li><p>Select one electrode from the scalp EEG dataset and convolve each wavelet with EEG data from all trials from that electrode. Apply the Matlab function real to the convolution result, as in <code>convol_result=real(convol_result)</code>. This will return the EEG data bandpass filtered at the peak frequency of the wavelet. You learn more about why this is in the next chapter. </p></li><li><p>Average the result of convolution over all trials and plot an ERP corresponding to each wavelet frequency. Each frequency should be in its own subplot. </p></li><li><p>Plot the broadband ERP (without any convolution). Thus, you will have six subplots in one figure. How do the wavelet-convolved ERPs compare with the broadband ERP? Are there dynamics revealed by the wavelet-convolved ERPs that are not apparent in the broadband ERP, and are there dynamics in the broadband ERP that are not apparent in the waveletconvolved ERPs? Base your answer on qualitative visual inspection of the results; statistics or other quantitative comparisons are not necessary. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercise 12</span></span><br><span class="line"><span class="comment">%% 1. Create a family of Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequencies = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">num_wavelets = <span class="built_in">length</span>(frequencies);</span><br><span class="line"></span><br><span class="line">srate = EEG.srate;</span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">wavelet_family = <span class="built_in">zeros</span>(num_wavelets,<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Loop through frequencies and make a family of wavelets.</span></span><br><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:num_wavelets</span><br><span class="line"> </span><br><span class="line">    <span class="comment">% create a sine wave at this frequency</span></span><br><span class="line">    sinewave = <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*frequencies(fi).*time); <span class="comment">% the &quot;1i&quot; makes it a complex wavelet</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create a Gaussian window</span></span><br><span class="line">    gaus_win = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi)))^<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create wavelet via element-by-element multiplication of the sinewave and gaussian window</span></span><br><span class="line">    wavelet_family(fi,:) = sinewave.*gaus_win;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 2. Get EEG data from electrode 47, convolve each wavelet with EEG data</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line">channel = <span class="number">47</span>;</span><br><span class="line">n_conv = EEG.pnts + <span class="built_in">length</span>(time) - <span class="number">1</span>;</span><br><span class="line">convol_result = <span class="built_in">zeros</span>(EEG.trials,num_wavelets,n_conv);</span><br><span class="line">half_of_kernal_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> trial_i = <span class="number">1</span>:EEG.trials</span><br><span class="line">    fft_EEG = fft(EEG.data(channel,:,trial_i),n_conv);</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:num_wavelets</span><br><span class="line">        fft_wavelet = fft(wavelet_family(fi,:),n_conv);</span><br><span class="line">        convol_result(trial_i,fi,:) = ifft(fft_EEG.*fft_wavelet,n_conv) * <span class="built_in">sqrt</span>(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi))) / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convol_result = <span class="built_in">real</span>(convol_result(:,:,half_of_kernal_size+<span class="number">1</span>:n_conv-half_of_kernal_size));</span><br><span class="line">filtered_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(convol_result,<span class="number">1</span>));<span class="comment">% 经过wavelet滤波后的ERP</span></span><br><span class="line">broadband_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(channel,:,:),<span class="number">3</span>)); <span class="comment">% 未滤波的ERP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_wavelets</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,filtered_ERP(<span class="built_in">i</span>,:));</span><br><span class="line">    set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-300</span>, <span class="number">1000</span>])</span><br><span class="line">    ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">    xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Wavelet filtered ERP at &#x27;</span> num2str(frequencies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,broadband_ERP);</span><br><span class="line">ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Unfiltered broadband ERP&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/19/3lrQXKtgZI4docT.png" alt="Ex_12"></p><hr><h1 id="Exercises-13-complex-Morlet-wavelets"><a href="#Exercises-13-complex-Morlet-wavelets" class="headerlink" title="Exercises 13 | complex Morlet wavelets"></a>Exercises 13 | complex Morlet wavelets</h1><h2 id="1-Create-a-family-of-complex-Morlet-wavelets"><a href="#1-Create-a-family-of-complex-Morlet-wavelets" class="headerlink" title="1. Create a family of complex Morlet wavelets"></a>1. Create a family of complex Morlet wavelets</h2><p>Create a family of complex Morlet wavelets ranging in frequencies from 2 Hz to 30 Hz in five steps. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 13</span></span><br><span class="line"><span class="comment">% 1. Create a family of complex Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">time = <span class="number">-2</span>:<span class="number">1</span>/EEG.srate:<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在3和10之间生成5个对数分别的数，作为不同频率下wavelet包含的周期数目</span></span><br><span class="line">numcycles = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">10</span>),<span class="built_in">length</span>(frex));</span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex), <span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% make complex Morlet wavelets</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi));</span><br><span class="line">    wavelet(fi,:) = <span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)) * <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi).*time);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 检查两侧是否衰减到0</span></span><br><span class="line">    <span class="comment">% subplot(ceil(length(frex)/3), ceil(length(frex)/2), fi);</span></span><br><span class="line">    <span class="comment">% plot(time,real(wavelet));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="2-Convolve-each-wavelet-with-EEG-data"><a href="#2-Convolve-each-wavelet-with-EEG-data" class="headerlink" title="2. Convolve each wavelet with EEG data"></a>2. Convolve each wavelet with EEG data</h2><p>Convolve each wavelet with EEG data from all electrodes and from one trial. </p><h2 id="3-Extract-power-and-phase"><a href="#3-Extract-power-and-phase" class="headerlink" title="3. Extract power and phase"></a>3. Extract power and phase</h2><p>Extract power and phase from the result of complex wavelet convolution and store in a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix). </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2. Convolve each wavelet with EEG data from all electrode and from one trial</span></span><br><span class="line">trial = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 3. a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix)</span></span><br><span class="line">convolution_result_fft = <span class="built_in">zeros</span>(n_convolution,<span class="built_in">length</span>(frex),EEG.nbchan,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% FFT of wavelet and EEG data</span></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    fft_data    = fft(<span class="built_in">squeeze</span>(EEG.data(electrodei,:,trial)),n_convolution); <span class="comment">% trial 1</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">        fft_wavelet = fft(wavelet(fi,:),n_convolution);</span><br><span class="line">        convoli = ifft(fft_wavelet.*fft_data,n_convolution) * <span class="built_in">sqrt</span>(s);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">1</span>) = <span class="built_in">abs</span>(convoli.^<span class="number">2</span>);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">2</span>) = <span class="built_in">angle</span>(convoli);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_fft = convolution_result_fft(half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size,:,:,:);</span><br></pre></td></tr></table></figure><h2 id="4-Make-topographical-plots-of-power-and-phase"><a href="#4-Make-topographical-plots-of-power-and-phase" class="headerlink" title="4. Make topographical plots of power and phase"></a>4. Make topographical plots of power and phase</h2><p>Make topographical plots of power and phase at 180 ms at all frequencies (hint: you may need to use the squeeze function to remove singleton dimensions). Arrange the plots in one figure with five columns for frequency and two rows for power/phase. Put labels in the plot so it is clear which topographical maps correspond to which frequencies. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 180 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">180</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/gypqPbMUZfo2iC5.png" alt="Ex_13(1)"></p><h2 id="5-Repeat-step-4-for-activity-at-360-ms"><a href="#5-Repeat-step-4-for-activity-at-360-ms" class="headerlink" title="5. Repeat step 4 for activity at 360 ms."></a>5. Repeat step 4 for activity at 360 ms.</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 360 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">360</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/DxTRqhzK72JtoPL.png" alt="Ex_13(2)"></p><h2 id="6-Think"><a href="#6-Think" class="headerlink" title="6. Think"></a>6. Think</h2><p>Are there any prominent topographical features in power or in phase?     - Yes.</p><p>Do these differ for different frequencies?     - Yes.</p><p>Do power and phase have similar topographical distributions?    - It doesn’t look very similar.</p><p>Is there any reason to suspect that they might have similar or different topographies?     </p><blockquote><h4 id="From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures"><a href="#From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures" class="headerlink" title="(From ChatGPT for reference, GPT is not provided with corresponding pictures)"></a><strong>(From ChatGPT for reference, GPT is not provided with corresponding pictures)</strong></h4><p>When analyzing EEG data, particularly through time-frequency decomposition, you might observe various topographical features in both power and phase distributions across the scalp. These features can provide insights into underlying neural processes. Let’s break down each question:</p><h4 id="1-Are-there-any-prominent-topographical-features-in-power-or-in-phase"><a href="#1-Are-there-any-prominent-topographical-features-in-power-or-in-phase" class="headerlink" title="(1) Are there any prominent topographical features in power or in phase?"></a><strong>(1) Are there any prominent topographical features in power or in phase?</strong></h4><ul><li><strong>Power Topography</strong>: Power topography represents the distribution of signal power across the scalp. Prominent features in power maps could indicate areas of strong neural activity, which might correspond to specific cognitive or sensory processes. For example, increased power in the occipital regions might be related to visual processing.</li><li><strong>Phase Topography</strong>: Phase topography shows the distribution of phase angles across the scalp. Prominent features in phase topography could indicate phase synchronization between regions, which might be associated with communication between different brain areas.</li></ul><h4 id="2-Do-these-differ-for-different-frequencies"><a href="#2-Do-these-differ-for-different-frequencies" class="headerlink" title="(2) Do these differ for different frequencies?"></a><strong>(2) Do these differ for different frequencies?</strong></h4><ul><li>Yes, topographical features often differ for different frequencies. Different frequencies in EEG are associated with different types of neural activity (e.g., alpha waves in the 8-12 Hz range are often related to relaxation and closed eyes, while beta waves in the 13-30 Hz range are associated with active thinking or focus). The power and phase topographies can change significantly across different frequency bands, reflecting the different functional roles of these frequencies.</li></ul><h4 id="3-Do-power-and-phase-have-similar-topographical-distributions"><a href="#3-Do-power-and-phase-have-similar-topographical-distributions" class="headerlink" title="(3) Do power and phase have similar topographical distributions?"></a><strong>(3) Do power and phase have similar topographical distributions?</strong></h4><ul><li>Power and phase distributions are often not identical. Power topography might highlight regions with strong amplitude, while phase topography might emphasize regions where the timing of oscillatory activity is synchronized across electrodes. However, there can be similarities, especially in regions where strong power is accompanied by consistent phase alignment (e.g., in tasks requiring coordinated neural activity across brain regions).</li></ul><h4 id="4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies"><a href="#4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies" class="headerlink" title="(4) Is there any reason to suspect that they might have similar or different topographies?"></a><strong>(4) Is there any reason to suspect that they might have similar or different topographies?</strong></h4><ul><li><strong>Similar Topographies</strong>: Power and phase could have similar topographies in cases where high power is associated with phase-locked activity across trials or regions. For instance, during sensory processing, a stimulus might evoke both strong power and phase synchronization in relevant brain areas.</li><li><strong>Different Topographies</strong>: Conversely, power and phase might differ in their topographical distributions due to different underlying mechanisms. High power might occur in one region without strong phase alignment, especially if the neural activity is more localized or independent across trials. Additionally, phase synchronization can occur without strong power, especially in low-amplitude oscillations that are critical for certain cognitive processes.</li></ul><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h4><ul><li><strong>Power and phase topographies can both reveal important aspects of neural activity, but they often provide different insights</strong>. Power maps tend to show where neural activity is strong, while phase maps can indicate where different regions are temporally synchronized. The topographies of power and phase may differ depending on the frequency of interest and the specific neural processes involved. Understanding these distributions and their relationships is key to interpreting EEG data in the context of neural dynamics.</li></ul></blockquote><h2 id="7-Create-a-circular-colormap"><a href="#7-Create-a-circular-colormap" class="headerlink" title="7.  Create a circular colormap"></a>7.  Create a circular colormap</h2><p>Because phase values are circular ( – <em>π</em> and + <em>π</em> are identical), most color maps are inappropriate because they suggest that – <em>π</em> and + <em>π</em> are very different values (represented, e.g., by blue and red colors). Create a circular colormap that can be used for phase values. You can do this by setting the red, green, and/or blue values to be a cosine function rather than a linear function. Recreate the phase topographical maps. Do they look any different with the new color maps? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自定义用于相位的环形colormap，使得-pi和pi对应的颜色相同</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ax6 = subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">nColors = <span class="number">128</span>; <span class="comment">% 调色板的颜色数量</span></span><br><span class="line">cmap = hsv(nColors); <span class="comment">% 使用 HSV colormap</span></span><br><span class="line">cmap = cmap([<span class="number">1</span>:<span class="keyword">end</span> <span class="number">1</span>], :); <span class="comment">% 将第一个颜色重复，使得 -pi 和 pi 一致</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加环形 colorbar</span></span><br><span class="line">cb = colorbar;</span><br><span class="line">set(cb, <span class="string">&#x27;Ticks&#x27;</span>, [-<span class="built_in">pi</span>, -<span class="built_in">pi</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="built_in">pi</span>/<span class="number">2</span>, <span class="built_in">pi</span>], <span class="string">&#x27;TickLabels&#x27;</span>, &#123;<span class="string">&#x27;-\pi&#x27;</span>, <span class="string">&#x27;-\pi/2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;\pi/2&#x27;</span>, <span class="string">&#x27;\pi&#x27;</span>&#125;);</span><br><span class="line">clim([-<span class="built_in">pi</span> <span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">axis off</span><br><span class="line">cb.Position(<span class="number">1</span>) = ax6.Position(<span class="number">1</span>);</span><br><span class="line">cb.Position(<span class="number">2</span>) = ax6.Position(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/8dGJkcTSfWMRO1A.png" alt="Ex_13(3)"></p><hr><h1 id="Exercises-14-filter-Hilbert"><a href="#Exercises-14-filter-Hilbert" class="headerlink" title="Exercises 14 | filter-Hilbert"></a>Exercises 14 | filter-Hilbert</h1><ol><li>Pick two frequencies (e.g., 5 Hz and 25 Hz) and one electrode and perform complex Morlet wavelet convolution and filter-Hilbert using those two frequencies as the peak/center frequencies for all trials. Plot the resulting power and the bandpass-filtered signal (that is, the real component of the analytic signal) from each method. Plot one single trial (you can choose the trial randomly but plot the same trial for both methods) and then plot the average of all trials. Describe some similarities and differences between the results of the two time-frequency decomposition methods. </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 14</span></span><br><span class="line"><span class="comment">%% 1. perform complex Morlet wavelet convolution and filter-Hilbert using frequencies 5 Hz and 25 Hz</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"><span class="comment">% two frequencies</span></span><br><span class="line">frex = [<span class="number">5</span>, <span class="number">25</span>]; <span class="comment">% the center frequencies</span></span><br><span class="line"><span class="comment">% pick one electrode (Fcz) and one trial</span></span><br><span class="line">electrode = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,<span class="string">&#x27;Fcz&#x27;</span>));</span><br><span class="line">trial = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">data2filter = <span class="built_in">squeeze</span>(EEG.data(electrode,:,trial));</span><br><span class="line">data2filter_average = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(electrode,:,:),<span class="number">3</span>));</span><br><span class="line"><span class="comment">%% perform complex Morlet wavelet convolution</span></span><br><span class="line"><span class="comment">% wavelet parameters</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">numcycles = [<span class="number">4</span> <span class="number">5</span>];</span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">conv_result_wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),n_convolution);</span><br><span class="line">conv_result_wavelet_2 = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),n_convolution);</span><br><span class="line">fft_data = fft(data2filter,n_convolution);</span><br><span class="line">fft_data_2 = fft(data2filter_average,n_convolution);</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi));</span><br><span class="line">    wavelet = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi).*time);</span><br><span class="line">    </span><br><span class="line">    fft_wavelet = fft(wavelet,n_convolution);</span><br><span class="line">    fft_wavelet = fft_wavelet ./ <span class="built_in">max</span>(<span class="built_in">abs</span>(fft_wavelet));</span><br><span class="line">    conv_result_wavelet(fi,:) = ifft(fft_wavelet.*fft_data,n_convolution)*(<span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)));</span><br><span class="line">    conv_result_wavelet_2(fi,:) = ifft(fft_wavelet.*fft_data_2,n_convolution)*(<span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">conv_result_wavelet = conv_result_wavelet(:,half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line">conv_result_wavelet_2 = conv_result_wavelet_2(:,half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line"><span class="comment">%% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">2</span> <span class="number">10</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = [<span class="number">.01</span> <span class="number">.15</span>];</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>) ([<span class="number">1</span> <span class="number">1</span>]-transwid)&#x27;.*(frex-freqspread)&#x27; (frex-freqspread)&#x27; (frex+freqspread)&#x27; ([<span class="number">1</span> <span class="number">1</span>]+transwid)&#x27;.*(frex+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(fi),EEG.pnts);</span><br><span class="line">filter_result_2 = <span class="built_in">zeros</span>(<span class="built_in">length</span>(fi),EEG.pnts);</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">    fft_filter = fft(filterweights);</span><br><span class="line">    filter_result(fi,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    filter_result_2(fi,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter_average));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(conv_result_wavelet(<span class="built_in">i</span>,:)).^<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(filter_result(<span class="built_in">i</span>,:)).^<span class="number">2</span>)</span><br><span class="line">    set(gca,<span class="string">&quot;XLim&quot;</span>,[<span class="number">-500</span>,<span class="number">1000</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Voltage (\muV)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Center Frequency: &#x27;</span> num2str(frex(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;wavelet&#x27;</span>,<span class="string">&#x27;filter-Hilbert&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(conv_result_wavelet_2(<span class="built_in">i</span>,:)).^<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(filter_result_2(<span class="built_in">i</span>,:)).^<span class="number">2</span>)</span><br><span class="line">    set(gca,<span class="string">&quot;XLim&quot;</span>,[<span class="number">-500</span>,<span class="number">1000</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Voltage (\muV)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Center Frequency: &#x27;</span> num2str(frex(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;wavelet&#x27;</span>,<span class="string">&#x27;filter-Hilbert&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/26/5IQZ4tyGiRP6Lck.png" alt="Ex_14(1)_onetrial"></p><p><img src="https://s2.loli.net/2024/08/26/LfFCS7RhA6BjYpX.png" alt="Ex_14(1)_onetrial"></p><ol><li>Modify the wavelet and filter settings (but keep the peak/center frequencies the same) until these two methods produce very similar results. Next, modify the wavelet and filter settings (except the peak/center frequencies) to make the results different (stay within a reasonable range of parameter settings; they do not need to look dramatically different). Which parameters did you change to make the results look more similar versus more different? How different are the results, and would you consider this a meaningful difference? What does this difference tell you about when to use specific parameter settings for wavelet convolution and the filter-Hilbert method? </li></ol><p>尝试改变的参数：</p><ul><li>wavelet：<ul><li>numcycles：wavelet包含的周期数目参数。包含的周期数目越多，wavelet频带越窄，频率分辨率越高</li></ul></li><li>filter-Hilbert：<ul><li>freqspread：带宽参数。带宽越大，频率分辨率越低</li><li>transwid：过渡区宽度参数。</li><li><code>firls()</code>的第一个参数，the order of the filter：决定filter kernel频率响应的精度。</li></ul></li></ul><hr><h1 id="Exercises-15-The-Short-Time-FFT"><a href="#Exercises-15-The-Short-Time-FFT" class="headerlink" title="Exercises 15 | The Short-Time FFT"></a>Exercises 15 | The Short-Time FFT</h1><ol><li>Compute the <strong>short-time FFT</strong> at each electrode and make topographical maps of theta band (around 6 Hz) power and alpha-band (around 10 Hz) power at 150 ms and 700 ms. </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Compute the short-time FFT at each electrode</span></span><br><span class="line"><span class="comment">% and make topographical maps of theta band (around 6 Hz) power and alpha-band (around 10 Hz) power at 150 ms and 700 ms. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">50</span>:<span class="number">1000</span>; <span class="comment">% in ms</span></span><br><span class="line">timepoint(<span class="number">1</span>) = <span class="number">150</span>;   <span class="comment">% ms</span></span><br><span class="line">timepoint(<span class="number">2</span>) = <span class="number">700</span>;   <span class="comment">% ms</span></span><br><span class="line">frequency(<span class="number">1</span>) = <span class="number">6</span>;     <span class="comment">% Hz</span></span><br><span class="line">frequency(<span class="number">2</span>) = <span class="number">10</span>;    <span class="comment">% Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert ms to idx</span></span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> frexi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [junk,times2saveidx(frexi)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(frexi)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">0.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">tf = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frex),<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    <span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">        tempdat = <span class="built_in">squeeze</span>(EEG.data(channi,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">        <span class="comment">% and hann_win)</span></span><br><span class="line">        taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">        </span><br><span class="line">        fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">        tf(channi,:,timepointi) = <span class="built_in">mean</span>(<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>,<span class="number">2</span>); <span class="comment">% average over trials</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[junk,frequencyidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency(<span class="number">1</span>)));</span><br><span class="line">[junk,frequencyidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency(<span class="number">2</span>)));</span><br><span class="line">[junk,timepointidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-timepoint(<span class="number">1</span>)));</span><br><span class="line">[junk,timepointidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-timepoint(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> timei = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> frexi = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        subplot(<span class="number">2</span>,<span class="number">2</span>,(timei<span class="number">-1</span>)*<span class="number">2</span>+frexi)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(tf(:,frequencyidx(frexi),timepointidx(timei))),EEG.chanlocs);</span><br><span class="line">        title([num2str(timepoint(timei)) <span class="string">&#x27;ms, &#x27;</span> num2str(frequency(frexi)) <span class="string">&#x27;Hz&#x27;</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/01/IZGUTadVePJ85Qt.png" alt="Ex_15(1)" style="zoom:50%;" /></p><ol><li>Select one electrode and one frequency and compute power over time at that electrode and that frequency using <strong>complex wavelet convolution</strong>, <strong>filter-Hilbert</strong>, and the <strong>short-time FFT</strong>. Plot the results of these three time-frequency decomposition methods in different subplots of one figure. Note that the scaling might be different because no baseline normalization has been applied. How visually similar are the results from these three methods? If the results from the three methods are different, how are they different, and what parameters do you think you could change in the three methods to make the results look more or less similar? </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select one electrode and one frequency and compute power over time at that electrode and that frequency</span></span><br><span class="line"><span class="comment">% using complex wavelet convolution, filter-Hilbert, and the short-time FFT.</span></span><br><span class="line"></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">channel2plot = <span class="string">&#x27;Fcz&#x27;</span>;</span><br><span class="line">electrode = strcmpi(channel2plot,&#123;EEG.chanlocs.labels&#125;);</span><br><span class="line">frequency = <span class="number">6</span>;     <span class="comment">% in Hz</span></span><br><span class="line"></span><br><span class="line">times2save = <span class="number">-200</span>:<span class="number">1000</span>/EEG.srate:<span class="number">800</span>;</span><br><span class="line"><span class="comment">% convert from ms to index</span></span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [junk,times2saveidx(<span class="built_in">i</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% complex wavelet convolution</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">numcycle = <span class="number">4</span>;</span><br><span class="line">s = numcycle/(<span class="number">2</span>*<span class="built_in">pi</span>*frequency);</span><br><span class="line">wavelet = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frequency.*time);</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT of wavelet and EEG data</span></span><br><span class="line">fft_wavelet = fft(wavelet,n_convolution);</span><br><span class="line">convol = <span class="built_in">zeros</span>(EEG.trials,n_convolution);</span><br><span class="line"><span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">    fft_data    = fft(<span class="built_in">squeeze</span>(EEG.data(electrode,:,triali)),n_convolution);</span><br><span class="line">    convol(triali,:) = ifft(fft_wavelet.*fft_data,n_convolution);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">convolution_result_fft = <span class="built_in">mean</span>((<span class="built_in">abs</span>(convol).^<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_fft = convolution_result_fft(half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% filter-Hilbert</span></span><br><span class="line">freqspread = <span class="number">3</span>; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.01</span>;</span><br><span class="line">nyquist = EEG.srate/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="number">0</span> (<span class="number">1</span>-transwid)&#x27;.*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (<span class="number">1</span>+transwid)&#x27;.*(frequency+freqspread)&#x27; nyquist ]./nyquist;</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line"></span><br><span class="line">filterweights = firls(<span class="number">200</span>,ffrequencies,idealresponse);</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(EEG.trials,EEG.pnts);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">    filter_result(triali,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,EEG.data(electrode,:,triali)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">filter_result = <span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result.^<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line"><span class="comment">%% the short-time FFT</span></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">    tempdat = <span class="built_in">squeeze</span>(EEG.data(electrode,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">    <span class="comment">% and hann_win)</span></span><br><span class="line">    taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">    </span><br><span class="line">    fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">    tf(:,timepointi) = <span class="built_in">mean</span>(<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>,<span class="number">2</span>); <span class="comment">% average over trials</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[junk,frequencyidx]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency));</span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(times2save,tf(frequencyidx,:)./(<span class="built_in">max</span>(tf(frequencyidx,:))),<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(times2save,convolution_result_fft(times2saveidx)./(<span class="built_in">max</span>(convolution_result_fft(times2saveidx))),<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.8</span> <span class="number">0</span>],<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(times2save,filter_result(times2saveidx)./(<span class="built_in">max</span>(filter_result(times2saveidx))),<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Short-Time FFT&#x27;</span>,<span class="string">&#x27;complex wavelet&#x27;</span>,<span class="string">&#x27;Hilbert-filter&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0.2</span>,<span class="number">1.3</span>]) </span><br><span class="line">colormap parula</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/01/fyXaesRPZCNb8lh.png" alt="Ex_15(2)" style="zoom:67%;" /></p><hr><h1 id="Exercises-16-Multitaper"><a href="#Exercises-16-Multitaper" class="headerlink" title="Exercises 16 | Multitaper"></a>Exercises 16 | Multitaper</h1><ol><li><p>Pick one electrode and compute a time-frequency map of power using both the multitaper method and the short-time FFT. Store all of the power values for all of the trials.</p></li><li><p>Next, compute a time-frequency map of signal-to-noise ratio. The signal-to-noise ratio of power is discussed more in chapter 18, but it can be estimated as the average power at each time-frequency point across trials, divided by the standard deviation of power at each time-frequency point across trials. </p></li><li>Make time-frequency plots of power and signal-to-noise ratio from the two methods. Make another plot in which you subtract the signal-to-noise plots between the two methods. Are there any noticeable differences between the signal-to-noise results when the multitaper method versus the short-time FFT is used? </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick one electrode and compute a time-frequency map of power using both the multitaper method and the short-time FFT.</span></span><br><span class="line">load sampleEEGdata</span><br><span class="line"></span><br><span class="line">channel2plot = <span class="string">&#x27;p7&#x27;</span>;</span><br><span class="line">channel2plotidx = strcmpi(channel2plot,&#123;EEG.chanlocs.labels&#125;);</span><br><span class="line"></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">50</span>:<span class="number">1000</span>; <span class="comment">% in ms</span></span><br><span class="line"><span class="comment">% convert from ms to index</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [~,times2saveidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">baseline_range  = [<span class="number">-200</span> <span class="number">-00</span>];</span><br><span class="line"><span class="comment">% find baselinetimepoints</span></span><br><span class="line">baseidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(baseline_range));</span><br><span class="line">[~,baseidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-baseline_range(<span class="number">1</span>)));</span><br><span class="line">[~,baseidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-baseline_range(<span class="number">2</span>)));</span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% multitaper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 参数设置</span></span><br><span class="line">N = timewinidx; <span class="comment">% 样本点数</span></span><br><span class="line">W = <span class="number">4</span>;    <span class="comment">% 频带宽度</span></span><br><span class="line">Fs = EEG.srate; <span class="comment">% 采样率</span></span><br><span class="line">NW = N * (W / (Fs/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成tapers</span></span><br><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择特征值大于0.9的tapers</span></span><br><span class="line">tapersToUse = tapers(:, eigenvalues &gt; <span class="number">0.9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize output matrix</span></span><br><span class="line">multitaper_tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials,<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop through time bins</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)  <span class="comment">% 对应一个时间点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% initialize power vector (over tapers)</span></span><br><span class="line">    <span class="comment">% 一个时间点处各频率的功率值，对应tf图上与时间轴垂直的一条线段</span></span><br><span class="line">    taperpow = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% loop through tapers</span></span><br><span class="line">    <span class="keyword">for</span> tapi = <span class="number">1</span>:<span class="built_in">size</span>(tapersToUse,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">        tempdat = <span class="built_in">squeeze</span>(EEG.data(channel2plotidx,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">        data      = <span class="built_in">bsxfun</span>(@times,tempdat,tapersToUse(:,tapi));</span><br><span class="line"></span><br><span class="line">        <span class="comment">% timewindow截取、taper两端减弱后的数据进行Fourier变换，提取特定频率的功率值</span></span><br><span class="line">        pow       = fft(data,timewinidx)/timewinidx;</span><br><span class="line">        pow       = pow(<span class="number">1</span>:<span class="built_in">length</span>(frex),:);</span><br><span class="line">        taperpow  = taperpow + pow.*<span class="built_in">conj</span>(pow);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% finally, get power from closest frequency</span></span><br><span class="line">    multitaper_tf(:,:,timepointi) = taperpow/tapi;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% the short-time FFT</span></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">fft_tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials,<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">    tempdat = <span class="built_in">squeeze</span>(EEG.data(channel2plotidx,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">    <span class="comment">% and hann_win)</span></span><br><span class="line">    taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">    </span><br><span class="line">    fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">    fft_tf(:,:,timepointi) =<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>; <span class="comment">% average over trials</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% compute a time-frequency map of signal-to-noise ratio.</span></span><br><span class="line">multitaper_mean = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(multitaper_tf,<span class="number">2</span>));</span><br><span class="line">fft_mean = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(fft_tf,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">multitaper_std = <span class="built_in">squeeze</span>(std(multitaper_tf,[],<span class="number">2</span>));</span><br><span class="line">fft_std = <span class="built_in">squeeze</span>(std(fft_tf,[],<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">snr_multitaper = multitaper_mean ./ multitaper_std;</span><br><span class="line">snr_fft = fft_mean ./ fft_std;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="comment">% db-correct</span></span><br><span class="line">db_multitaper_tf = <span class="number">10</span>*<span class="built_in">log10</span>( multitaper_mean ./ <span class="built_in">repmat</span>(<span class="built_in">mean</span>(multitaper_mean(:,baseidx(<span class="number">1</span>):baseidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">length</span>(times2save)) );</span><br><span class="line"><span class="comment">% db-correct</span></span><br><span class="line">db_fft_tf = <span class="number">10</span>*<span class="built_in">log10</span>( fft_mean ./ <span class="built_in">repmat</span>(<span class="built_in">mean</span>(fft_mean(:,baseidx(<span class="number">1</span>):baseidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">length</span>(times2save)) );</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">colormap jet</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">contourf(times2save,frex,db_multitaper_tf,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;Power of Multitaper&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">contourf(times2save,frex,db_fft_tf,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;Power of FFT&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">contourf(times2save,frex,snr_multitaper,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0.4</span> <span class="number">1.6</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;SNR of Multitaper&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">contourf(times2save,frex,snr_fft,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0.4</span> <span class="number">1.6</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;SNR of FFT&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">colormap jet</span><br><span class="line">contourf(times2save,frex,snr_multitaper-snr_fft,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">colorbar</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-0.2</span> <span class="number">1.2</span>])</span><br><span class="line">title(<span class="string">&#x27;SNR_&#123;Multipaper&#125; minus SNR_&#123;FFT&#125;&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/02/K3nNI58gTucP7Xj.png" alt="Ex_16(1)" style="zoom: 50%;" /></p><p><img src="https://s2.loli.net/2024/09/02/acKXeDqzrPkFV16.png" alt="Ex_16(2)" style="zoom:50%;" /></p><ol><li>Select two frequencies, one relatively low and one relatively high (e.g., 8 Hz and 60 Hz), and compare the power time series and signal-to-noise time series in these frequency bands from the two methods in a separate figure, using line plots. Comment on the differences if there are any. </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select two frequencies, one relatively low and one relatively high (e.g., 8 Hz and 60 Hz), </span></span><br><span class="line"><span class="comment">% and compare the power time series and signal-to-noise time series in these frequency bands </span></span><br><span class="line"><span class="comment">% from the two methods in a separate figure, using line plots.</span></span><br><span class="line">frequncies = [<span class="number">8</span>, <span class="number">60</span>];</span><br><span class="line">frequnciesidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(frequncies));</span><br><span class="line">[~,frequnciesidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequncies(<span class="number">1</span>)));</span><br><span class="line">[~,frequnciesidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequncies(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frequncies)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save,db_multitaper_tf(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    title([<span class="string">&#x27;Frequency: &#x27;</span> num2str(frequncies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz, Power&#x27;</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Power (dB)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save,db_fft_tf(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;Multitaper&#x27;</span>,<span class="string">&#x27;FFT&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save,snr_multitaper(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    title([<span class="string">&#x27;Frequency: &#x27;</span> num2str(frequncies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz, SNR&#x27;</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;SNR&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save,snr_fft(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;Multitaper&#x27;</span>,<span class="string">&#x27;FFT&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/03/WkcpXonqmF8lbr5.png" alt="Ex_16(3)" style="zoom: 50%;" /></p><ul><li>Multitaper常用于低信噪比的情况，如高频活动或功率的单试次估计。通过使用多个taper，multitaper方法在频率轴上引入了一定的<strong>平滑效应</strong>。这种平滑可以减少频率分辨率的精细度，使得<strong>频谱变得更加连续和平滑</strong>。</li></ul><hr><h1 id="Exercises-18-Baseline-Normalization"><a href="#Exercises-18-Baseline-Normalization" class="headerlink" title="Exercises 18 | Baseline Normalization"></a>Exercises 18 | Baseline Normalization</h1><ol><li><p>Select three frequency bands and compute time-varying power at each electrode in these three bands, using either complex wavelet convolution or filter-Hilbert. Compute and store both the baseline-corrected power and the raw non-baseline-corrected power. You can choose which time period and baseline normalization method to use. </p></li><li><p>Select five time points and create topographical maps of power with and without baseline normalization at each selected time-frequency point. You should have time in columns and with/without baseline normalization in rows. Use separate figures for each frequency. The color scaling should be the same for all plots over time within a frequency, but the color scaling should be different for with versus without baseline normalization and should also be different for each frequency. </p></li><li>Are there qualitative differences in the topographical distributions of power with compared to without baseline normalization? Are the differences more prominent in some frequency bands or at some time points? What might be causing these differences? </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select three frequency bands and compute time-varying power at each electrode in these three bands, using either complex wavelet convolution or filter-Hilbert.</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequency = [<span class="number">6</span> <span class="number">15</span> <span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">4</span> <span class="number">4</span> <span class="number">4</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.1</span>;</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequency+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">raw_result = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frequency),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(EEG.data(electrodei,:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">        filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        raw_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">raw_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(raw_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(raw_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">baseline_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,raw_result,baseline_power));</span><br><span class="line"></span><br><span class="line">timepoints = <span class="number">0</span>:<span class="number">100</span>:<span class="number">400</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timepoints)</span><br><span class="line">    [~,timepointsidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timepoints(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">    <span class="built_in">figure</span></span><br><span class="line">    sgtitle([<span class="string">&#x27;frequncy: &#x27;</span> num2str(frequency(fi)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    max_raw = <span class="built_in">ceil</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">abs</span>(raw_result(:,fi,timepointsidx)))));</span><br><span class="line">    max_baseline = <span class="built_in">ceil</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">abs</span>(baseline_dbconverted(:,fi,timepointsidx)))));</span><br><span class="line">    <span class="keyword">for</span> ti = <span class="number">1</span>:<span class="built_in">length</span>(timepoints)</span><br><span class="line">        subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,ti)</span><br><span class="line">        topoplot(raw_result(:,fi,timepointsidx(ti)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        title([<span class="string">&#x27;Raw Power, &#x27;</span> num2str(timepoints(ti)) <span class="string">&#x27;ms&#x27;</span>])   </span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[-max_raw,max_raw])</span><br><span class="line"></span><br><span class="line">        subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>+ti);</span><br><span class="line">        topoplot(baseline_dbconverted(:,fi,timepointsidx(ti)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        title([<span class="string">&#x27;DB Power, &#x27;</span> num2str(timepoints(ti)) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[-max_baseline,max_baseline])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    subplot(subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>))</span><br><span class="line">    axis off</span><br><span class="line">    colorbar(<span class="string">&#x27;Ticks&#x27;</span>,[<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],<span class="string">&#x27;TickLabels&#x27;</span>,[-max_raw, -max_raw/<span class="number">2</span>, <span class="number">0</span>, max_raw/<span class="number">2</span>, max_raw]);</span><br><span class="line">    </span><br><span class="line">    subplot(subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,<span class="number">2</span>*(<span class="built_in">length</span>(timepoints)+<span class="number">1</span>)))</span><br><span class="line">    axis off</span><br><span class="line">    colorbar(<span class="string">&#x27;Ticks&#x27;</span>,[<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],<span class="string">&#x27;TickLabels&#x27;</span>,[-max_baseline, -max_baseline/<span class="number">2</span>, <span class="number">0</span>, max_baseline/<span class="number">2</span>, max_baseline]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/03/3z12yptIrshBUcF.png" alt="Ex_18_6Hz" style="zoom: 45%;" /></p><p><img src="https://s2.loli.net/2024/09/03/sHWeBm4nFMlz9cR.png" alt="Ex_18_15Hz" style="zoom:45%;" /></p><p><img src="https://s2.loli.net/2024/09/03/8hnCD9qUrumiJgc.png" alt="Ex_18_60Hz" style="zoom:45%;" /></p><hr><h1 id="Exercises-19-ITPC-Intertrial-Phase-Clustering"><a href="#Exercises-19-ITPC-Intertrial-Phase-Clustering" class="headerlink" title="Exercises 19 | ITPC (Intertrial Phase Clustering)"></a>Exercises 19 | ITPC (Intertrial Phase Clustering)</h1><ol><li>Pick three electrodes. Compute time-frequency plots of ITPC and decibel-corrected power for these electrodes, using either complex Morlet wavelet convolution or the filter-Hilbert method. Plot the results side by side for each electrode (power and ITPC in subplots; one figure for each electrode). Are the patterns of results from ITPC and power generally similar or generally different? Do the results look more similar at some electrodes and less similar at other electrodes? </li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick three electrodes. Compute time-frequency plots of ITPC and decibel-corrected power for these electrodes, using either complex Morlet wavelet convolution or the filter-Hilbert method. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">electrode = [<span class="string">&quot;fz&quot;</span>, <span class="string">&quot;p8&quot;</span>, <span class="string">&quot;oz&quot;</span>];</span><br><span class="line">electrodeidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(electrode));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(electrode) </span><br><span class="line">    electrodeidx(<span class="built_in">i</span>) = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,electrode(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">frequencies = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">30</span>),<span class="number">30</span>);</span><br><span class="line"><span class="comment">%% calculate power</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line"></span><br><span class="line">freqspread = <span class="built_in">linspace</span>(<span class="number">1</span>,<span class="number">6</span>,<span class="built_in">length</span>(frequencies)); <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.1</span>;</span><br><span class="line">nyquist = <span class="built_in">repmat</span>(EEG.srate/<span class="number">2</span>, <span class="built_in">size</span>(frequencies));</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">ones</span>(<span class="built_in">length</span>(frequencies),<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequencies-freqspread)&#x27; (frequencies-freqspread)&#x27; (frequencies+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequencies+freqspread)&#x27; nyquist&#x27; ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(electrode),<span class="built_in">length</span>(frequencies),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">        filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        filter_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">power_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(power_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">power_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,power_result,baseline_power));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% calculate ITPC</span></span><br><span class="line">ITPC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">angle</span>(filter_result)),<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">time2plot = [<span class="number">-300</span>, <span class="number">1000</span>];</span><br><span class="line">time2plotidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(time2plot));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    [~,time2plotidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-time2plot(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,electrodei)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(power_dbconverted(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">    title([<span class="string">&#x27;Power from &#x27;</span> num2str(electrode(electrodei))])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>+electrodei)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(ITPC(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    title([<span class="string">&#x27;ITPC from &#x27;</span> num2str(electrode(electrodei))])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/03/PQAfsYTyS8UwIZ5.png" alt="Ex_19(1)" style="zoom: 67%;" /></p><ol><li>For each of these three electrodes, compute wITPCz using reaction time as the trial-varying modulator. Perform this analysis for all time-frequency points to generate time-frequency maps of the relationship between phase and reaction time. Do the time-frequency maps of wITPCz look different from the time-frequency maps of ITPC? Do you see any striking patterns in the ITPCz results, and do the results differ across the different electrodes (don ’ t worry about statistics, base your judgment on qualitative patterns)? How would you interpret the results if they were statistically significant? </li></ol><hr><h1 id="Exercises-20-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency"><a href="#Exercises-20-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency" class="headerlink" title="Exercises 20 | Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency"></a>Exercises 20 | Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency</h1><p>Pick two frequencies and compute total and non-phase-locked power from each electrode over time at these two frequencies. Pick two time windows, one early and one late, of several hundreds of milliseconds each (e.g., 100 – 300 ms and 500 – 800 ms) and show topographical maps of total power, non-phase-locked power, and phase-locked power from the average of all time points within these windows. Are there striking topographical differences among these results? If so, are the differences bigger or smaller in the early or the late time window? Why might this be the case? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick two frequencies and compute total and non-phase-locked power from each electrode over time at these two frequencies. </span></span><br><span class="line"><span class="comment">% compute total power</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequency = [<span class="number">5</span> <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">1.5</span> <span class="number">4</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.15</span>;</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequency+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">raw_result = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frequency),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(EEG.data(electrodei,:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">        filterweights = firls(<span class="number">200</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        raw_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">raw_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(raw_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(raw_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">baseline_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,raw_result,baseline_power));</span><br><span class="line">timewindow = [<span class="number">100</span>,<span class="number">300</span>; <span class="number">600</span>, <span class="number">900</span>];</span><br><span class="line">timewindowidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timewindowidx)</span><br><span class="line">    [~,timewindowidx(<span class="built_in">i</span>,<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">1</span>)));</span><br><span class="line">    [~,timewindowidx(<span class="built_in">i</span>,<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">2</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">total = <span class="built_in">zeros</span>(<span class="built_in">length</span>(timewindow),EEG.nbchan,<span class="built_in">length</span>(frequency));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timewindow)</span><br><span class="line">    total(<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(baseline_dbconverted(:,:,timewindowidx(<span class="built_in">i</span>,<span class="number">1</span>):timewindowidx(<span class="built_in">i</span>,<span class="number">2</span>)),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% compute non-phase-locked power</span></span><br><span class="line"><span class="comment">% compute ERP</span></span><br><span class="line">erp = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(:,:,:),<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% compute induced power by subtracting ERP from each trial</span></span><br><span class="line">induced_EEG = EEG.data(:,:,:) - <span class="built_in">repmat</span>(erp,[<span class="number">1</span> <span class="number">1</span> EEG.trials]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% filter the induced eeg data</span></span><br><span class="line">raw_result_non_phase_locked = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frequency),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(induced_EEG(electrodei,:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">        filterweights = firls(<span class="number">200</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        raw_result_non_phase_locked(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">raw_result_non_phase_locked = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(raw_result_non_phase_locked).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% baseline normalization</span></span><br><span class="line">baseline_dbconverted_non_phase_locked = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,raw_result_non_phase_locked,baseline_power));</span><br><span class="line"></span><br><span class="line">non_phase_locked = <span class="built_in">zeros</span>(<span class="built_in">length</span>(timewindow),EEG.nbchan,<span class="built_in">length</span>(frequency));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timewindow)</span><br><span class="line">    non_phase_locked(<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(baseline_dbconverted_non_phase_locked(:,:,timewindowidx(<span class="built_in">i</span>,<span class="number">1</span>):timewindowidx(<span class="built_in">i</span>,<span class="number">2</span>)),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% compute phase-locked power</span></span><br><span class="line">phase_locked = total - non_phase_locked;</span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">n = <span class="number">0</span>;  <span class="comment">% 用于绘子图时计算行数</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">    <span class="keyword">for</span> twi = <span class="number">1</span>:<span class="built_in">length</span>(timewindow)</span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>*n+<span class="number">1</span>)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(total(twi,:,fi)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-2</span>,<span class="number">2</span>])</span><br><span class="line">        title([<span class="string">&#x27;Total (&#x27;</span> num2str(frequency(fi)) <span class="string">&#x27;Hz, &#x27;</span> num2str(timewindow(twi,<span class="number">1</span>)) <span class="string">&#x27;-&#x27;</span> num2str(timewindow(twi,<span class="number">2</span>)) <span class="string">&#x27;ms)&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>*n+<span class="number">2</span>)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(non_phase_locked(twi,:,fi)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-2</span>,<span class="number">2</span>])</span><br><span class="line">        title([<span class="string">&#x27;Non-Phase-Locked (&#x27;</span> num2str(frequency(fi)) <span class="string">&#x27;Hz, &#x27;</span> num2str(timewindow(twi,<span class="number">1</span>)) <span class="string">&#x27;-&#x27;</span> num2str(timewindow(twi,<span class="number">2</span>)) <span class="string">&#x27;ms)&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>*n+<span class="number">3</span>)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(phase_locked(twi,:,fi)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-1</span>,<span class="number">1</span>])</span><br><span class="line">        title([<span class="string">&#x27;Phase-Locked (&#x27;</span> num2str(frequency(fi)) <span class="string">&#x27;Hz, &#x27;</span> num2str(timewindow(twi,<span class="number">1</span>)) <span class="string">&#x27;-&#x27;</span> num2str(timewindow(twi,<span class="number">2</span>)) <span class="string">&#x27;ms)&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        n = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    colormap jet</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/04/yZaAUzbl3Nus6wh.png" alt="Ex_20" style="zoom:67%;" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part 3 Frequency and Time-Frequency Domains Analyses | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd8c3.html"/>
      <url>/post/c9dcd8c3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-10-amp-11"><a href="#Chapter-10-amp-11" class="headerlink" title="Chapter 10&amp;11"></a>Chapter 10&amp;11</h1><p>推荐3b1b的一段关于<strong>卷积</strong>、<strong>离散傅里叶变换（DFT）</strong>和快速傅里叶变换（FFT）的视频</p><p><a href="https://www.bilibili.com/video/BV1Vd4y1e7pj/?t=0.8&amp;vd_source=e7f03c857e620b80dcde0db3e7f51d26">【官方双语】那么……什么是卷积？</a></p><h2 id="Supplementary-Code-for-Figure-11-5"><a href="#Supplementary-Code-for-Figure-11-5" class="headerlink" title="Supplementary Code for Figure 11.5"></a>Supplementary Code for Figure 11.5</h2><p>对于书中所提供的图11.5对应代码的一些细节注释</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Figure 11.5</span></span><br><span class="line"></span><br><span class="line">N       = <span class="number">10</span>;         <span class="comment">% length of sequence  长度为10的向量</span></span><br><span class="line">data    = <span class="built_in">randn</span>(<span class="number">1</span>,N); <span class="comment">% random numbers</span></span><br><span class="line">srate   = <span class="number">200</span>;        <span class="comment">% sampling rate in Hz 采样率200Hz</span></span><br><span class="line">nyquist = srate/<span class="number">2</span>;    <span class="comment">% Nyquist frequency -- the highest frequency you can measure in the data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize Fourier output matrix</span></span><br><span class="line">fourier = <span class="built_in">zeros</span>(<span class="built_in">size</span>(data)); </span><br><span class="line"></span><br><span class="line"><span class="comment">% These are the actual frequencies in Hz that will be returned by the</span></span><br><span class="line"><span class="comment">% Fourier transform. The number of unique frequencies we can measure is</span></span><br><span class="line"><span class="comment">% exactly 1/2 of the number of data points in the time series (plus DC). </span></span><br><span class="line"><span class="comment">% 一个长度为 N 的信号需要 N 个正交基（frequency）才能完全表示</span></span><br><span class="line"><span class="comment">% 但在这里只保留了N/2+1个frequencies，是因为对于实数值信号，负频率与正频率对应的幅值、相位信息是对称的</span></span><br><span class="line"><span class="comment">% 所以舍去了N/2个负频率</span></span><br><span class="line">frequencies = <span class="built_in">linspace</span>(<span class="number">0</span>,nyquist,N/<span class="number">2</span>+<span class="number">1</span>);   <span class="comment">% 生成的频率从 0 到 100 Hz，共有 N/2 + 1 个点，间隔为srate/N</span></span><br><span class="line">time = ((<span class="number">1</span>:N)<span class="number">-1</span>)/N;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Fourier transform is dot-product between sine wave and data at each frequency</span></span><br><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:N      </span><br><span class="line">    <span class="comment">% fi（归一化频率，index，无单位）有N个取值，与frequencies（物理频率，Hz）为线性映射关系</span></span><br><span class="line">    <span class="comment">% 所以使用这两种频率DFT后的结果一致（幅值、相位相等）</span></span><br><span class="line">    sine_wave   = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time);</span><br><span class="line">    fourier(fi) = sum(sine_wave.*data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fourier=fourier/N;  <span class="comment">% 归一化，使得振幅具有实际意义，并保证能量的一致性</span></span><br></pre></td></tr></table></figure><h2 id="The-Fast-Fourier-Transform-FFT"><a href="#The-Fast-Fourier-Transform-FFT" class="headerlink" title="The Fast Fourier Transform | FFT"></a>The Fast Fourier Transform | FFT</h2><p>如何将 fft 函数的输出与实际的频率和幅值对应起来：</p><ul><li>采样率：$F_s$     采样点数：$N$</li><li>FFT后向量中某点索引：$n$<ul><li>该点频率：$f_n=(n-1)\cdot F_s/N$ </li><li>该点幅值：$abs(Result_{FFT})/(N/2)$</li></ul></li></ul><hr><h1 id="Chapter-12"><a href="#Chapter-12" class="headerlink" title="Chapter 12"></a>Chapter 12</h1><h2 id="How-to-Wake-Wavelets-小波的创造"><a href="#How-to-Wake-Wavelets-小波的创造" class="headerlink" title="How to Wake Wavelets | 小波的创造"></a>How to Wake Wavelets | 小波的创造</h2><p>不同于使用傅里叶变换进行的分析，使用小波变换时小波的频率和数目可以自行选择。一组具有相同性质但频率不同的<strong>小波</strong>叫作<strong>小波族</strong>，构造一组小波族有如下限制：</p><ol><li><strong>不能用比你划分的时间小段（epochs）更慢的频率。</strong>例如，你有一段1s长的数据，那么你不能分析低于1Hz的活动，应该让这1s中包含多个活动周期，建议使用4Hz或更快的小波。</li><li><p><strong>小波的频率不能高于奈奎斯特频率（采样率的一半）</strong></p></li><li><p>选择相近的频率所获得的结果会很相近（例如15.0Hz和14.9Hz），且越密集的频率所需要的计算时间会越长，<strong>一般而言，在3Hz到60Hz之间选择15到30个频率就够了</strong>。</p></li></ol><hr><h1 id="Chapter-13-Complex-Morlet-Wavelets-cmw"><a href="#Chapter-13-Complex-Morlet-Wavelets-cmw" class="headerlink" title="Chapter 13 Complex Morlet Wavelets (cmw)"></a>Chapter 13 Complex Morlet Wavelets (cmw)</h1><h2 id="Create-complex-sine-wave"><a href="#Create-complex-sine-wave" class="headerlink" title="Create complex sine wave"></a>Create complex sine wave</h2><p>复数域的Wavelet函数也是由sine函数和Gaussian相乘得来，只是所使用的sine函数是在复数域表示的（<script type="math/tex">e^{i2\pi ft}</script>）</p><ul><li><script type="math/tex">cmw=Ae^{-t^2/2s^2}e^{i2\pi ft}</script> (the x-axis offset for Gaussian are omitted)</li><li><script type="math/tex; mode=display">A=\frac{1}{(s\sqrt{\pi})^{1/2}}</script></li></ul><h2 id="The-Result-of-cmw"><a href="#The-Result-of-cmw" class="headerlink" title="The Result of cmw"></a>The Result of cmw</h2><p>复数wavelet与信号点积的结果有三个维度：<strong>时间、实部、虚部</strong>。将该结果绘制在复平面上，其在实轴、虚轴上的投影分别对应于wavelet的实部、虚部与信号的点积结果。</p><p>点积结果在复平面上所对应向量的长度反映了信号（signal）和核（kernal）的相似（重叠）程度，而且该长度与二者间的相位关系无关。相位关系由向量与实轴的夹角表示。</p><ul><li><strong>在实轴上的投影：带通滤波信号</strong>，其正负符号反映<strong>相位</strong>关系</li><li><strong>向量长度（振幅）：</strong>反映wavelet与signal的<strong>相似性</strong>或<strong>重叠度</strong>，其<strong>平方称为功率</strong><ul><li><code>abs(X).^2;</code> or <code>X.*conj(X);</code> (乘以共轭)</li></ul></li><li><strong>与实轴夹角：</strong>反映了在wavelet<strong>中心时间点</strong>（即分析时段的中间时刻）和wavelet的<strong>主频率</strong>（即小波的主要振荡频率）下，信号的<strong>相位</strong>信息。<ul><li><code>angle(X);</code> </li></ul></li><li>上述提到的功率和相位值只能作为估计值，因为它们会受到邻近时间点活动的影响。</li></ul><p><img src="https://s2.loli.net/2024/08/19/YXlf9aM2iv6UByK.png" alt="image-20240819201632545" style="zoom:67%;" /></p><h2 id="Parameters-of-Wavelets"><a href="#Parameters-of-Wavelets" class="headerlink" title="Parameters of Wavelets"></a>Parameters of Wavelets</h2><ul><li><p><strong>最低频率</strong></p><ul><li>如果关注alpha-band activity，大概在5或6Hz即可</li><li>划分的时间区段（epoch）尽可能包含多个周期（如果epoch长1s，则不要低于4Hz）</li></ul></li><li><p><strong>最高频率</strong></p><ul><li>不能超过<strong>奈奎斯特频率（采样率的一半）</strong></li><li>单个wavelet周期尽可能包含更多的信号数据点，可以提高信噪比</li><li>没有特别的期望的话，可能选择4Hz到6Hz的频率范围</li></ul></li><li><p><strong>频率数目</strong></p><ul><li>一般取20-30个频率足够覆盖较宽的频率范围。条件允许的情况下当然是越多越好，但是相近的频率不一定能提供更多信息。</li></ul></li><li><p><strong>频率分布间隔</strong></p><ul><li><p><strong>线性分布</strong></p><ul><li><p>突出频谱的高频段</p></li><li><p>可以直接使用 <code>imagesc(EEG.times,frequencies,tf_data);</code> 绘图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">imagesc(EEG.times,frex,eegpower)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>],<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1000</span>],<span class="string">&#x27;ydir&#x27;</span>,<span class="string">&#x27;norm&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;WRONG Y-AXIS LABELS!!!!&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Frequency (Hz)&#x27;</span>), xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>对数分布（推荐）</strong>：</p><ul><li><p>4-8Hz（theta）和30-80Hz（lower gamma）在y轴上占据的宽度会比较接近</p></li><li><p>突出频谱的低频段</p></li><li><p>使用 <code>imagesc(EEG.times,[],tf_data)</code> 绘图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">imagesc(EEG.times,[],eegpower)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>],<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1000</span>],<span class="string">&#x27;ydir&#x27;</span>,<span class="string">&#x27;norm&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:<span class="number">6</span>:num_frex,<span class="string">&#x27;yticklabel&#x27;</span>,<span class="built_in">round</span>(<span class="built_in">logspace</span>(<span class="built_in">log10</span>(min_freq),<span class="built_in">log10</span>(max_freq),<span class="number">6</span>)*<span class="number">10</span>)/<span class="number">10</span>)<span class="comment">% important!</span></span><br><span class="line">title(<span class="string">&#x27;CORRECT Y-AXIS LABELS!!!!&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>wavelets 的长度</strong></p><ul><li>要足够长，使得<strong>两侧能衰减到0</strong>（接近0）</li><li><strong>没有长度限制</strong>，如果 -1s ~ +1s 不够，就设置成 -2s ~ +2s，不同的频率长度也不一定要相同</li><li>wavelet 的图像要<strong>设置在时间轴中央</strong>（关于中间时刻对称），最简单的方法是将时间范围设置成  -x seconds to +x seconds</li><li>wavelet 的<strong>采样率要和 EEG.data 一致</strong></li></ul></li><li><p><strong>Gaussian函数要包含多少个周期</strong></p><ul><li>“包含的周期数目”指的是Gaussian函数标准差公式<script type="math/tex">s=\frac{n}{2\pi f}</script>中的<strong><script type="math/tex">n</script></strong></li><li>包含周期数越多，<strong>频率精度</strong>越高，<strong>时间精度</strong>越低</li><li>包含周期的数目也可随频率改变</li><li>应至少包含3个周期，至多包含14个周期</li><li>在wavelet的非零段，需要保证数据（进行卷积的信号片段）的<strong>平稳性</strong>（均值、方差等统计特性保持稳定）</li></ul></li></ul><h2 id="相邻频率对小波卷积的贡献程度"><a href="#相邻频率对小波卷积的贡献程度" class="headerlink" title="相邻频率对小波卷积的贡献程度"></a>相邻频率对小波卷积的贡献程度</h2><ul><li><p><strong>Full width at half-maximum (FWHM)</strong></p><ul><li><p>指频谱上功率在峰值的左右两侧分别为<strong>50%</strong>时的频率宽度：<strong><script type="math/tex">FWHM=2\sqrt{2\ln 2}\sigma</script></strong>，其中<script type="math/tex">\sigma</script>是频率响应的<strong>标准差</strong></p><ul><li>首先标准化功率谱，使得峰值为1，两端衰减至0</li><li>找到功率值为0.5的点对应的频率，即可计算出FWHM</li></ul><p><img src="https://s2.loli.net/2024/08/22/IGb3NMwy4gUQfjA.png" alt="image-20240822161841368"></p></li></ul></li></ul><h2 id="卷积的Matlab计算技巧"><a href="#卷积的Matlab计算技巧" class="headerlink" title="卷积的Matlab计算技巧"></a>卷积的Matlab计算技巧</h2><ul><li>FFT的数据点数为<strong><script type="math/tex">2^n</script></strong>时，计算速度更快。可以通过适当的<strong>补零</strong>来实现</li><li>不需要对每个trial进行一次卷积，可以将所有trial连接成一个长时间序列，再对整个时间序列执行一次卷积</li></ul><hr><h1 id="Chapter-14-Bandpass-Filtering-and-the-Hilbert-Transform"><a href="#Chapter-14-Bandpass-Filtering-and-the-Hilbert-Transform" class="headerlink" title="Chapter 14 Bandpass Filtering and the Hilbert Transform"></a>Chapter 14 Bandpass Filtering and the Hilbert Transform</h1><h2 id="The-Procedure-of-Hilbert-Transform-Hilbert变换及其步骤"><a href="#The-Procedure-of-Hilbert-Transform-Hilbert变换及其步骤" class="headerlink" title="The Procedure of Hilbert Transform | Hilbert变换及其步骤"></a>The Procedure of Hilbert Transform | Hilbert变换及其步骤</h2><ul><li><p>对于一个只有实部的信号<script type="math/tex">A(t)\cos(2\pi ft)</script>，我们无法获得其相位信息，Hilbert变换能够帮助我们<strong>从实信号中提取出虚部</strong>，从而获得相位信息</p></li><li><p><strong>正频率与负频率</strong></p><ul><li><p><strong>正频率：</strong>介于<strong>0</strong>与<strong>奈奎斯特频率</strong>之间的频率（不包含0和奈奎斯特频率）</p></li><li><p><strong>负频率：</strong>大于奈奎斯特频率</p></li><li><p><strong>为什么要区分正频率与负频率？</strong></p><p><strong>信号的实部与虚部</strong>：一个纯实信号（如 <script type="math/tex">M\cos⁡(2πft)</script>）在频域中有对称的正负频率分量，它们共同构成了这个信号的傅里叶表示。然而，虚部（如<script type="math/tex">iM\sin ⁡(2πft)</script>）的引入使得信号不再是对称的，因此需要对正频率和负频率分量分别进行处理，以生成一个复信号。</p></li></ul></li><li><p><strong>Hilbert变换的步骤：</strong></p><ul><li><p>对信号做<strong>Fourier变换</strong>，得到<script type="math/tex">M(t)\cos (2\pi ft)</script>，乘以复数单位 <script type="math/tex">i</script>，得到<strong><script type="math/tex">iM(t)cos(2\pi ft)</script></strong></p></li><li><p><strong>正负频率的处理</strong></p><p><strong>正频率的处理</strong></p><ul><li><strong>逆时针旋转四分之一周期</strong>：正频率分量的傅里叶系数在复平面上表示时，通过逆时针旋转四分之一周期（即<script type="math/tex">-90°</script>或<script type="math/tex">\frac{\pi}{2}</script>），可以将余弦信号（<script type="math/tex">\cos ⁡(2πft)</script>)转化为正弦信号（<script type="math/tex">\sin⁡(2πft)</script>）。</li><li><strong>数学处理</strong>：这种旋转通过将傅里叶系数乘以 <script type="math/tex">−i</script>（即$-i=e^{-i\pi/2}$）来实现。这样，当你把旋转后的正频率系数加回到原来的正频率系数时，实际操作效果是将这些系数变成了原来系数的两倍。</li></ul><p><strong>负频率的处理</strong></p><ul><li><strong>顺时针旋转四分之一周期</strong>：负频率分量对应的傅里叶系数需要顺时针旋转四分之一周期（即$90°$或$\frac{\pi}{2}$），将余弦信号（$\cos ⁡(2πft)$）转化为负的正弦信号。</li><li><strong>数学处理</strong>：这个旋转通过将负频率傅里叶系数乘以 <script type="math/tex">i</script>（即 <script type="math/tex">i=e^{i\pi /2}</script>）来实现。由于这导致$i$和$i$相乘等于-1，负频率的系数经过处理后在添加回原来的系数时会变成零。这意味着负频率部分被完全消除。</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/08/24/bBZKcUlpuLw8CVn.png" alt="image-20240824004215712" style="zoom: 20%;" /></p><ul><li><strong>Hilbert变换的代码</strong></li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% the FFT-based hilbert transform</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% generate random numbers</span></span><br><span class="line">n = <span class="number">21</span>;</span><br><span class="line">randomnumbers = <span class="built_in">randn</span>(n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% take FFT</span></span><br><span class="line">f = fft(randomnumbers);</span><br><span class="line"><span class="comment">% create a copy that is multiplied by the complex operator</span></span><br><span class="line">complexf = <span class="number">1</span><span class="built_in">i</span>*f;</span><br><span class="line"></span><br><span class="line"><span class="comment">% find indices of positive and negative frequencies</span></span><br><span class="line">posF = <span class="number">2</span>:<span class="built_in">floor</span>(n/<span class="number">2</span>)+<span class="built_in">mod</span>(n,<span class="number">2</span>);</span><br><span class="line">negF = <span class="built_in">ceil</span>(n/<span class="number">2</span>)+<span class="number">1</span>+~<span class="built_in">mod</span>(n,<span class="number">2</span>):n;</span><br><span class="line"></span><br><span class="line"><span class="comment">% rotate Fourier coefficients</span></span><br><span class="line"><span class="comment">% (note 1: this works by computing the iAsin(2pft) component, i.e., the phase quadrature)</span></span><br><span class="line"><span class="comment">% (note 2: positive frequencies are rotated counter-clockwise; negative frequencies are rotated clockwise)</span></span><br><span class="line">f(posF) = f(posF) + <span class="number">-1</span><span class="built_in">i</span>*complexf(posF);</span><br><span class="line">f(negF) = f(negF) +  <span class="number">1</span><span class="built_in">i</span>*complexf(negF);</span><br><span class="line"><span class="comment">% The next two lines are an alternative and slightly faster method. </span></span><br><span class="line"><span class="comment">% The book explains why this is equivalent to the previous two lines.</span></span><br><span class="line"><span class="comment">% f(posF) = f(posF)*2;</span></span><br><span class="line"><span class="comment">% f(negF) = f(negF)*0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% take inverse FFT</span></span><br><span class="line">hilbertx = ifft(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">% compare with Matlab function hilbert</span></span><br><span class="line">hilbertm = hilbert(randomnumbers);</span><br></pre></td></tr></table></figure><ul><li>Hilbert变换并<strong>不改变信号的实部</strong>，可用此性质<strong>检验变换后的信号</strong>是否正确</li><li>在Matlab中，函数<code>hilbert()</code>的输入可以是一个矩阵<code>filtered_data = zeros(demension_1,demension_2)</code>，但是矩阵的第一个维度必须是时间（<code>filtered_data = zeros(EEG.pnts,EEG.nbchan)</code>），即对于二维矩阵，矩阵的<strong>每一列</strong>是一组信号</li><li>在进行Hilbert变换前，建议先对信号进行滤波，从而将信号分离成不同的频段，以便于分析</li></ul><h2 id="Bandpass-Filtering-带通滤波"><a href="#Bandpass-Filtering-带通滤波" class="headerlink" title="Bandpass Filtering | 带通滤波"></a>Bandpass Filtering | 带通滤波</h2><ul><li><p><strong>FIR &amp; IIR Filters</strong> </p><ul><li><strong>FIR (Finit Impluse Response, 有限冲激响应)：</strong>提供脉冲输入后，响应会在某一点终止。更稳定，且不容易引入非线性相位畸变</li><li><strong>FIR (Infinit Impluse Response, 无限冲激响应)：</strong>提供脉冲输入后，响应不会终止。算法计算复杂度更低，耗时少</li></ul></li><li><p><strong>Bandpass, Band-Stop, High-Pass, Low-Pass</strong></p><p><img src="https://s2.loli.net/2024/08/24/uLS7YHFP2wB8Icb.jpg" alt="img" style="zoom: 67%;" /></p></li><li><p><strong>Create a filter kernel in Matlab</strong></p><ul><li><p><code>firls()</code>：通过最小二乘创建FIR滤波器。常用于<strong>宽频带</strong></p><ul><li><p><strong>第一个参数：The order of the filter</strong>，定义kernel的长度（单位为ms），决定了滤波器频率响应的精度。通常设置为<strong>下频界的2~5倍</strong>（如果下频界为10Hz（100ms），那么就是200到500ms）</p></li><li><p><strong>第二个参数：</strong>一个包含一组频率的频率向量，决定滤波器频率响应的形状。对于带通滤波器，可以使用六个频率：①零频率，②下过渡区开始的频率，③带通的下界，④带通的上界，⑤上过渡区结束的频率，⑥奈奎斯特频率。<strong>最后将这6个频率除以奈奎斯特频率</strong>（即以奈奎斯特频率为1）</p><p><img src="https://s2.loli.net/2024/08/24/dzoLqDucORCjNAS.png" alt="image-20240824003328931" style="zoom: 80%;" /></p><ul><li><strong>第三个参数：</strong>一个元素为0~1的向量，通过控制第二个输入参数的纵坐标来修改滤波器频响形状。对于带通滤波器，可以使用[0 0 1 1 0 0]，其中的“1”对应带通平台的上下频界，第一个和最后一个“0”对应直流和奈奎斯特频率，第二个和第五个“0”对应过渡区的频率界。</li></ul></li></ul></li><li><p><code>fir1()</code>：带有<strong>紧密过渡区</strong>的窗函数线性相位滤波器。常用于<strong>窄频带</strong></p><ul><li>第二个参数只需输入带通下界、带通上界两个频率值</li></ul></li><li><p><code>fir2()</code>：基于频率采样的滤波器结构</p></li><li><p><code>firrcos()</code>：凸起的余弦形滤波器</p></li><li><p><code>gaussfir()</code>：高斯形滤波器</p></li><li><p><code>firpm()</code>：Parks-McClellan</p></li></ul></li><li><p>频域内的<strong>尖锐边缘</strong>会引起时域内的<strong>伪影振荡</strong>，使用包含<strong>过渡区</strong>的滤波器可以缓解这一点，但是会牺牲一定的频率精度</p></li><li><p>检验滤波器是否合格：$sse=\Sigma_{i=1}^{n}(ideal_i-actual_i)^2$，sse即the sum of squared errors，对理想滤波器而言，n指的是滤波器的6个定位点（第二个参数）。</p></li><li><p>得到kernel后，使用<strong><code>filtfilt()</code>函数</strong>完成对信号的滤波，该函数输入的第一个为kernel；第二个参数为一个标量和向量，代表kernel的权重。通常设为；第三个参数为被处理信号。</p><ul><li>使用<code>filter()</code>函数会引入相位延迟，而<code>filtfilt()</code> 通过两次应用<code>filter</code>函数来消除相位延迟。具体来说，它首先对信号进行正向滤波，然后反转信号顺序，再次应用相同的滤波器，最后再将信号反转回来。</li></ul></li><li><p>Butterworth (IIR) Filter</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 5th-order butterworth filter</span></span><br><span class="line">[butterB,butterA] = butter(<span class="number">5</span>,[(center_freq-filter_frequency_spread)/nyquist (center_freq+filter_frequency_spread)/nyquist],<span class="string">&#x27;bandpass&#x27;</span>);</span><br><span class="line">butter_filter     = filtfilt(butterB,butterA,data2filter);</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="Chapter-15-Short-Time-FFT"><a href="#Chapter-15-Short-Time-FFT" class="headerlink" title="Chapter 15 Short-Time FFT"></a>Chapter 15 Short-Time FFT</h1><ul><li><p>Short-Time FFT 即取一小段时间内的数据进行fft，为了减小artifact，需要对这一段数据的两侧进行减弱处理</p><ul><li><p>可以用<strong>Hann、Hamming、Gaussian</strong>三种函数（tapers）完成减弱处理，推荐用<strong>Hann</strong>，因为它最终会衰减到0。其他taper还包括Kaiser, cosine, Blackman, …</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">timewin= <span class="number">400</span>; <span class="comment">% in ms, for stFFT</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(timewin/(<span class="number">1000</span>/EEG.srate));</span><br><span class="line"></span><br><span class="line"><span class="comment">% create hamming</span></span><br><span class="line">hamming_win = <span class="number">.54</span> - <span class="number">.46</span>*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>));</span><br><span class="line"><span class="comment">% create hann</span></span><br><span class="line">hann_win    = <span class="number">.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% create gaussian</span></span><br><span class="line">gaus_win = <span class="built_in">exp</span>(<span class="number">-.5</span>*(<span class="number">2.5</span>*(-timewinidx/<span class="number">2</span>:timewinidx/<span class="number">2</span><span class="number">-1</span>)/(timewinidx/<span class="number">2</span>)).^<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>得到FFT结果后，建议以目标频率周围几个频率的频响平均值（或Gaussian加权平均值）作为最终结果，可以提高信噪比</p></li></ul></li><li><p>时间段长度的选择</p><ul><li>A trade-off between temporal and frequency precision and resolution</li><li>时间段长度应至少包含<strong>所分析频率的一个周期</strong></li><li>时间段长度可以设为频率的函数（低频-时间段长；高频-时间段短）</li></ul></li></ul><hr><h1 id="Chapter-16-Multitapers"><a href="#Chapter-16-Multitapers" class="headerlink" title="Chapter 16 Multitapers"></a>Chapter 16 Multitapers</h1><ul><li><p>常用于低信噪比的情况，如高频活动或功率的单试次估计</p><p><img src="https://s2.loli.net/2024/08/26/nyjkdE6NG2bFCaB.png" alt="image-20240826221516720"></p></li><li><p><strong>The Tapers</strong></p><ul><li><p>multitapers使用的tapers是<strong>discrete prolate spheroidal sequences</strong>，也叫做Slepian tapers。可以使用Matlab中的<code>dpss()</code>函数生成。一组slepian tapers相互正交</p></li><li><h4 id="dpss-函数的基本调用格式如下："><a href="#dpss-函数的基本调用格式如下：" class="headerlink" title="dpss 函数的基本调用格式如下："></a><strong><code>dpss</code> 函数的基本调用格式如下：</strong></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br></pre></td></tr></table></figure><ul><li><code>N</code>：时间段的长度（以样本点为单位）。</li><li><code>NW</code>：时间带宽参数。它是时间段长度和频带宽度的乘积，<code>NW = N * (W / (Fs/2))</code>，其中 <code>W</code> 是频带宽度（以采样率的一半为单位，所以要除以采样率的一半），<code>Fs</code> 是采样率。</li><li><code>tapers</code>：返回的锥窗函数的矩阵，每一列是一个taper。</li><li><code>eigenvalues</code>：对应的特征值，表示每个taper在指定频带内包含的能量。</li></ul><h4 id="确定参数"><a href="#确定参数" class="headerlink" title="确定参数"></a><strong>确定参数</strong></h4><ul><li><strong>时间段长度 <code>N</code></strong>：取决于你想要的时间分辨率。</li><li><strong>带宽参数 <code>NW</code></strong>：它控制频谱的平滑程度。<code>NW</code> 的值越大，频谱越平滑，但时间分辨率越低。通常，<code>NW</code> 的值在 2 到 4 之间，也可随频率值改变。</li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1000</span>; <span class="comment">% 假设有1000个样本点</span></span><br><span class="line">W = <span class="number">2</span>;    <span class="comment">% 频带宽度, 以赫兹为单位</span></span><br><span class="line">Fs = <span class="number">1000</span>; <span class="comment">% 采样率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算NW参数</span></span><br><span class="line">NW = N * (W / (Fs/<span class="number">2</span>));</span><br><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br></pre></td></tr></table></figure><h4 id="确定锥窗数量"><a href="#确定锥窗数量" class="headerlink" title="确定锥窗数量"></a><strong>确定锥窗数量</strong></h4><p><code>dpss</code> 函数返回的锥窗数量是 <code>2*NW</code> 四舍五入后的整数。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">numTapers = <span class="built_in">round</span>(<span class="number">2</span> * NW);</span><br></pre></td></tr></table></figure><h4 id="分析特征值"><a href="#分析特征值" class="headerlink" title="分析特征值"></a><strong>分析特征值</strong></h4><p><code>tapers</code> 的最后一个特征值一般较低（例如 0.7 或 0.8），表示该taper的频谱表现较差，通常可以忽略这些较差的锥窗。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 检查特征值</span></span><br><span class="line"><span class="built_in">disp</span>(eigenvalues);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 忽略最后一个特征值较低的taper</span></span><br><span class="line">tapersToUse = tapers(:, eigenvalues &gt; <span class="number">0.9</span>);</span><br></pre></td></tr></table></figure><h3 id="5-完整示例代码"><a href="#5-完整示例代码" class="headerlink" title="5. 完整示例代码"></a>5. <strong>完整示例代码</strong></h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 参数设置</span></span><br><span class="line">N = <span class="number">1000</span>; <span class="comment">% 样本点数</span></span><br><span class="line">W = <span class="number">2</span>;    <span class="comment">% 频带宽度</span></span><br><span class="line">Fs = <span class="number">1000</span>; <span class="comment">% 采样率</span></span><br><span class="line">NW = N * (W / (Fs/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成tapers</span></span><br><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示特征值</span></span><br><span class="line"><span class="built_in">disp</span>(eigenvalues);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择特征值大于0.9的tapers</span></span><br><span class="line">tapersToUse = tapers(:, eigenvalues &gt; <span class="number">0.9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制tapers</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(tapersToUse);</span><br><span class="line">title(<span class="string">&#x27;Selected DPSS Tapers&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (samples)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/26/ovNmqH5TaYcE41J.png" alt="test_dps"></p></li></ul></li><li><p>通过使用多个taper，multitaper方法在频率轴上引入了一定的<strong>平滑效应</strong>。这种平滑可以减少频率分辨率的精细度，使得<strong>频谱变得更加连续和平滑</strong>。</p><p><strong>（ChatGPT的例子）</strong>假设你在一个任务中研究Gamma频段活动，并且发现某些被试的伽马频段峰值在50Hz，而另一些被试的峰值在65Hz。如果你使用精细的小波分析，每个被试的频谱可能显示出各自独特的伽马活动峰值，但这些峰值的差异可能在跨被试平均时抵消，导致难以在群体水平上识别伽马活动。此时，通过使用multitapers方法并引入适当的频率平滑，你可以让50Hz和65Hz的峰值在频谱中更接近，从而在群体平均时更容易识别出Gamma频段的整体活动。这种平滑可以帮助你在不损失重要频率信息的情况下，更好地捕捉和解释群体层面的神经活动。</p></li><li><p>适用情况</p><ul><li>noisy data, small number of trials</li><li>single-trial analyses, analyze frequencies above around 30 Hz</li><li>high-frequency power above around 60 Hz</li></ul></li></ul><hr><h1 id="Chapter-18-Time-Frequency-Power-and-Baseline-Normalization"><a href="#Chapter-18-Time-Frequency-Power-and-Baseline-Normalization" class="headerlink" title="Chapter 18 Time-Frequency Power and Baseline Normalization"></a>Chapter 18 Time-Frequency Power and Baseline Normalization</h1><h2 id="1-f-Power-Scaling"><a href="#1-f-Power-Scaling" class="headerlink" title="1/f Power Scaling"></a>1/f Power Scaling</h2><ul><li>EEG的<strong>时频功率</strong>和<strong>频率</strong>呈现<strong>幂函数</strong>的关系：$power=\frac{c}{frequency^x}$，难以进行数据分析</li></ul><script type="math/tex; mode=display">dB_{tf}=10\log10(\frac{activity_{tf}}{\overline{baseline}_f})</script><h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><ul><li><strong>baseline</strong>指的是一段时间，通常在<strong>试验开始前几百毫秒</strong>，在这段时间内<strong>很少或没有任务相关的脑电活动</strong>。</li></ul><h2 id="Decibel-Conversion"><a href="#Decibel-Conversion" class="headerlink" title="Decibel Conversion"></a>Decibel Conversion</h2><ul><li><strong>计算公式：</strong></li></ul><script type="math/tex; mode=display">dB_{tf}=10\log10(\frac{activity_{tf}}{\overline{baseline_f}})</script><p>​    由于对数函数的存在，该公式不适用于存在非正值的数据，但功率值总是为正的</p><ul><li><strong>Matlab计算代码</strong></li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 定义baseline所处时间段</span></span><br><span class="line">baselinetime = [ <span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 找到baseline所划分时间段的时间索引</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct 转换为分贝指</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(tf_data(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>);<span class="comment">% 以baseline时间段内功率的时间平均值作为baseline_power，即分贝计算的分母</span></span><br><span class="line">dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,tf_data,baseline_power));</span><br><span class="line"><span class="comment">% FYI: the following lines of code are equivalent to the previous line:</span></span><br><span class="line"><span class="comment">% dbconverted = 10*( bsxfun(@minus,log10(tf_data),log10(baseline_power)));</span></span><br><span class="line"><span class="comment">% dbconverted = 10*log10( tf_data ./ repmat(baseline_power,1,EEG.pnts) );</span></span><br><span class="line"><span class="comment">% dbconverted = 10*( log10(tf_data) - log10(repmat(baseline_power,1,EEG.pnts)) );</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">contourf(EEG.times,frequencies,dbconverted,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;ytick&#x27;</span>,<span class="built_in">round</span>(<span class="built_in">logspace</span>(<span class="built_in">log10</span>(frequencies(<span class="number">1</span>)),<span class="built_in">log10</span>(frequencies(<span class="keyword">end</span>)),<span class="number">10</span>)*<span class="number">100</span>)/<span class="number">100</span>,<span class="string">&#x27;yscale&#x27;</span>,<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-500</span> <span class="number">1500</span>],<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-12</span> <span class="number">12</span>])</span><br></pre></td></tr></table></figure><ul><li><strong>一些细节</strong><ul><li>对于多个trial平均后的数据，经分贝转换后的功率通常分布在$\pm 1-4\ dB$</li><li>通常采用对称的颜色映射分布，便于比较增大与减小的幅度。某些情况下也可以用不对称的分布来突出某些特征</li></ul></li></ul><h2 id="Percentage-Change"><a href="#Percentage-Change" class="headerlink" title="Percentage Change"></a>Percentage Change</h2><ul><li><strong>计算公式</strong></li></ul><script type="math/tex; mode=display">prctchange_{tf}=100\frac{activity_{tf}-\overline{baseline_f}}{\overline{baseline}_f}</script><h2 id="Baseline-Division"><a href="#Baseline-Division" class="headerlink" title="Baseline Division"></a>Baseline Division</h2><ul><li><strong>计算公式</strong><script type="math/tex; mode=display">BaselineDivision = \frac{activity_{tf}}{\overline{baseline_f}}</script></li></ul><h2 id="Z-Transform"><a href="#Z-Transform" class="headerlink" title="Z-Transform"></a>Z-Transform</h2><ul><li><strong>计算公式</strong><script type="math/tex; mode=display">Z_{tf}=\frac{activity_{tf}-\overline{baseline_f}}{\sqrt{n^{-1}\sum_{i=1}^{n}(baseline_{if}-\overline{baseline_f})^2}}</script>其中n是baseline中的时间点数目，分母是baseline的标准差。当baseline的标准差较大时，不建议使用Z-Tranform</li></ul><h2 id="均值or中位数"><a href="#均值or中位数" class="headerlink" title="均值or中位数"></a>均值or中位数</h2><ul><li>在trial数量少、噪声大的情况下，中位数更不易受到离群值的影响</li><li>在对所有trial进行平均前，先对单个trial进行baseline normalization（single-trial Z-transform），可以减少离群数据的影响</li></ul><h2 id="如何选择Baseline"><a href="#如何选择Baseline" class="headerlink" title="如何选择Baseline"></a>如何选择Baseline</h2><ul><li><strong>ERP</strong><ul><li>baseline通常终止于time=0</li></ul></li><li><strong>time-frequency analyses</strong><ul><li>baseline通常设置为 <strong>-500 ~ -200 ms</strong> 或 <strong>-400 ~ -100 ms</strong>。因为在提取频域信息时，每个时间点上的数据会“泄露”到周围的时间点上，所以应该尽量避开刺激前的一段时间</li><li>要确保选择的baseline时间段内<strong>没有多余的刺激</strong>，比如试验开始的提示等</li><li>尽可能使用<strong>pretrial period</strong>作为baseline，而非preresponse period等其他时间段，以减少刺激相关神经活动的影响</li><li>baseline通常包含<strong>几百毫秒</strong></li><li>如果无法使用pretrial period作为baseline，可以考虑如下替代方案<ul><li>使用休息时间作为baseline。但被试对待休息与试验时心态的差异可能会影响最终结果</li><li>使用对照条件（区别于实验条件）作为baseline。对照与实验条件下反应时间的差异可能会影响最终结果</li><li>使用整个实验过程作为baseline。难以观测到功率在整个实验中的持续变化</li></ul></li><li>如果有多种不同的试验条件（condition），需要考虑使用 <strong>condition-specific baseline</strong> 还是 <strong>condition-average baseline</strong> ，即不同条件是否要使用同一段baseline</li></ul></li></ul><h2 id="Signal-to-Noise-Ratio-SNR-Estimates-信噪比的估计"><a href="#Signal-to-Noise-Ratio-SNR-Estimates-信噪比的估计" class="headerlink" title="Signal-to-Noise Ratio (SNR) Estimates| 信噪比的估计"></a>Signal-to-Noise Ratio (SNR) Estimates| 信噪比的估计</h2><ul><li><p>信噪比：可以认为是信号的<strong>平均值</strong>与信号的<strong>标准差</strong>的比值</p></li><li><p>计算公式：</p><script type="math/tex; mode=display">SNR=\frac{\mu}{\sigma}</script></li><li><p>对ERP而言</p><ul><li>$\mu$可以认为是某个ERP成分的峰值，$\sigma$可以认为是baseline的时间方差</li></ul></li><li>对time-frequency analyses<ul><li>$SNR_{tf}$：$\mu$为所有trial的平均功率，$\sigma$为所有trial的功率标准差，$tf$表示一个时频点</li><li>$SNR_{base}$：$\mu$为所有trial的平均功率，$\sigma$为baseline的功率标准差</li></ul></li></ul><h2 id="检验Trial的数量是否足够"><a href="#检验Trial的数量是否足够" class="headerlink" title="检验Trial的数量是否足够"></a>检验Trial的数量是否足够</h2><p>随机选取n个trial，计算这n个trial的平均值与所有trial平均值的相关系数，相关性越强，说明trial的数目越充足。对于没有进行baseline transform的非正态分布数据，通常计算Spearman相关系数</p><p><img src="https://s2.loli.net/2024/08/28/Q7treEbVA5qJgaY.png" alt="Figure18.13"></p><h2 id="DownSampling-降采样"><a href="#DownSampling-降采样" class="headerlink" title="DownSampling | 降采样"></a>DownSampling | 降采样</h2><p>时频分解后由于泄露，信号的时间精度会降低，因此时间分辨率可以适当降低，比如降低到 40 或 50 Hz</p><hr><h1 id="Chapter-19-Intertrial-Phase-Clustering"><a href="#Chapter-19-Intertrial-Phase-Clustering" class="headerlink" title="Chapter 19 Intertrial Phase Clustering"></a>Chapter 19 Intertrial Phase Clustering</h1><h2 id="Intertrial-Phase-Clustering-ITPC"><a href="#Intertrial-Phase-Clustering-ITPC" class="headerlink" title="Intertrial Phase Clustering (ITPC)"></a>Intertrial Phase Clustering (ITPC)</h2><ul><li><p><strong>主要思路</strong>：将不同trial在某一时刻的相位向量绘制在复平面上，模长为1，角度为各相位值，再计算所有向量的平均值，所得新向量的平均长度介于0和1之间，反映了<strong>多个Trial间相位的一致性(ITPC)</strong>，新向量的相位角则反映了<strong>相位的平均大小</strong></p></li><li><p><strong>计算公式：</strong></p><script type="math/tex; mode=display">ITPC_{tf}=|n^{-1}\Sigma^n_{r=1}e^{ik_{tfr}}|</script></li></ul><p><img src="https://s2.loli.net/2024/08/29/LPwYcRU3kfC6hvX.png" alt="image-20240829212545402" style="zoom:50%;" /></p><ul><li><p>Trial数目越多，ITPC值减小并趋于稳定。所以尽量保证Trial数目足够多，且不同实验条件下的Trial数尽量保持一致</p></li><li><p>Trial数目不足且不一致时可采用的措施</p><ul><li><p>对trial进行筛选，以匹配不同条件下的trial数目</p></li><li><p>采用baseline ITPC，因为不服从1/f的分布，通常采用linear baseline</p></li><li><p>将$ITPC$转换为$ITPC_Z$</p><script type="math/tex; mode=display">ITPC_Z=n\cdot ITPC^2</script></li></ul></li></ul><h2 id="Effect-of-Temporal-Jitter-on-ITPC"><a href="#Effect-of-Temporal-Jitter-on-ITPC" class="headerlink" title="Effect of Temporal Jitter on ITPC"></a>Effect of Temporal Jitter on ITPC</h2><ul><li>Temporal Jitter：刺激呈现等事件发生时间的波动或不确定性</li><li>Temporal Jitter对相位的影响大于对功率的影响，且在高频处的影响更大</li></ul><h2 id="ITPC-and-Power"><a href="#ITPC-and-Power" class="headerlink" title="ITPC and Power"></a>ITPC and Power</h2><ul><li>ITPC和Power通常是不相关的，可以分别进行分析说明</li><li>功率越小，相位越难估计（可以想象功率为0的极端情况）</li></ul><h2 id="Weighted-ITPC-wITPC"><a href="#Weighted-ITPC-wITPC" class="headerlink" title="Weighted  ITPC (wITPC)"></a>Weighted  ITPC (wITPC)</h2><ul><li>wITPC中向量的长度不是1，而是和试验中的行为或试验变量有关，比如反应时间、刺激亮度、瞳孔反映等</li></ul><script type="math/tex; mode=display">wITPC_{tf}=|n^{-1}\Sigma^n_{r=1}b_re^{ik_{tfr}}|</script><ul><li><blockquote><p><strong>wITPCz（待补充）</strong></p></blockquote></li></ul><hr><h1 id="Chapter-20-Differences-among-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency"><a href="#Chapter-20-Differences-among-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency" class="headerlink" title="Chapter 20 Differences among Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency"></a>Chapter 20 Differences among Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency</h1><ul><li><p>Non-Phase-Locked Power (Induced Power)</p><ul><li>计算方法：首先从每次试验的数据中减去ERP，然后对单次试验进行时间-频率分解，计算功率。这种方法去除了所有相位锁定 的成分，因此剩下的功率仅代表非相位锁定的部分</li></ul></li><li><p>Phase-Locked Power</p><ul><li>计算方法：从总功率中减去非相位锁定功率，注意需要先将总功率和非锁相功率分别转化为分贝，再相减</li><li>高频活动在多个周期后难以保持相位锁定，因此相位锁定功率中通常不包含大于20Hz左右的高频成分</li></ul></li><li>ERP Time-Frequency Power<ul><li>先计算ERP，再进行频域变换，而不是先进行频域变换，再计算ERP</li><li>It is appropriate to use <strong>the ERP baseline</strong> to normalize the ERP time-frequency power, rather than using the base line period power from the total or non-phase-locked analysis.</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercises Part 2 | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd3e2.html"/>
      <url>/post/c9dcd3e2.html</url>
      
        <content type="html"><![CDATA[<h1 id="9-8-Exercise"><a href="#9-8-Exercise" class="headerlink" title="9.8 Exercise"></a>9.8 Exercise</h1><h2 id="9-8-1"><a href="#9-8-1" class="headerlink" title="9.8.1"></a>9.8.1</h2><p>Compute the ERP at each electrode. Select five time points at which to show topographical plots (e.g., 0 to 400 ms in 100-ms steps). In one figure, make a series of topographical plots  at these time points. To increase the signal-to-noise ratio, make each plot show the average of activity from 20 ms before until 20 ms after each time point. For example, the topographical  plot from 200 ms should show average activity from 180 ms until 220 ms. Indicate the center  time point in a title on each subplot. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex_09 (1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% load EEG data</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute the ERP at each electrode</span></span><br><span class="line">ERP = <span class="built_in">zeros</span>(EEG.nbchan, EEG.pnts);</span><br><span class="line"><span class="keyword">for</span> electrode_i = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    ERP(electrode_i,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(electrode_i,:,:),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% select 5 time points (0 to 400ms in 100-ms steps) </span></span><br><span class="line"><span class="comment">% and plot topographical Maps</span></span><br><span class="line">dt = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="keyword">for</span> timei=<span class="number">0</span>:<span class="number">100</span>:<span class="number">400</span></span><br><span class="line">    <span class="comment">% Each point show the average of activity from 20ms before until 20ms</span></span><br><span class="line">    <span class="comment">% after each point</span></span><br><span class="line">    TimeSpani = <span class="built_in">find</span>(EEG.times &gt;= timei-dt &amp; EEG.times &lt;= timei+dt);</span><br><span class="line">    MeanEEG = <span class="built_in">mean</span>(EEG.data(:,TimeSpani,:),<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% topographical plots</span></span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">2</span>,timei/<span class="number">100</span>+<span class="number">1</span>);</span><br><span class="line">    c = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(MeanEEG(:,:,:),<span class="number">3</span>));</span><br><span class="line">    topoplot(double(c),EEG.chanlocs,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="number">-10</span>,<span class="number">10</span>]);   <span class="comment">% 统一各subplot的colorbar</span></span><br><span class="line">    title([<span class="string">&#x27;ERP around &#x27;</span> num2str(timei) <span class="string">&#x27;ms&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    colormap jet</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot colorbar</span></span><br><span class="line">ax6 = subplot(<span class="number">326</span>);</span><br><span class="line">axis off</span><br><span class="line">cb = colorbar;</span><br><span class="line">set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="number">-10</span>,<span class="number">10</span>]);</span><br><span class="line">cb.Position(<span class="number">1</span>) = ax6.Position(<span class="number">1</span>);</span><br><span class="line">cb.Position(<span class="number">2</span>) = ax6.Position(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/hdsRq2Gbtv6QfNl.png" alt="Ex09(1)" style="zoom:67%;" /></p><h2 id="9-8-2"><a href="#9-8-2" class="headerlink" title="9.8.2"></a>9.8.2</h2><p>Loop through each electrode and find the peak time of the ERP between 100 and 400 ms. Store these peak times in a separate variable and then make a topographical plot of the peak times (that is, the topographical map will illustrate times in milliseconds, not activity at peak times). Include a color bar in the figure and make sure to show times in milliseconds from time 0 (not, for example, time in milliseconds since 100 ms or indices instead of milliseconds). What areas of the scalp show the earliest and the latest peak responses to the stimulus within this window?</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex_09 (2)</span></span><br><span class="line"></span><br><span class="line">PeakTimes = <span class="built_in">zeros</span>(EEG.nbchan,<span class="number">1</span>);      <span class="comment">% the peak time of the ERP between 100 and 400ms (in ms)</span></span><br><span class="line">PeakTimedx = <span class="built_in">zeros</span>(EEG.nbchan,<span class="number">1</span>);      <span class="comment">% peak time index of each channel</span></span><br><span class="line">Timedx = <span class="built_in">find</span>(EEG.times &gt;= <span class="number">100</span> &amp; EEG.times &lt;= <span class="number">400</span>);     <span class="comment">% index of 100~400ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% find ERP peak times</span></span><br><span class="line"><span class="keyword">for</span> electrode_i = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    PeakTimedx(electrode_i) = Timedx(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> timespani = <span class="number">1</span>:<span class="built_in">length</span>(Timedx)</span><br><span class="line">        <span class="keyword">if</span> ERP(electrode_i,Timedx(timespani)) &gt; ERP(electrode_i,PeakTimedx(electrode_i))</span><br><span class="line">            PeakTimedx(electrode_i) = Timedx(timespani);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    PeakTimes(electrode_i) = EEG.times(PeakTimedx(electrode_i));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot a topographical plot of peak times</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">topoplot(PeakTimes,EEG.chanlocs,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">colormap jet</span><br><span class="line">set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="built_in">min</span>(PeakTimes) <span class="built_in">max</span>(PeakTimes)]);</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;ERP peak times between 100 and 400 ms&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/zgitBZ9TsY3bc6K.png" alt="EX09(2)" style="zoom:67%;" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercises Part 1 | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcc4e1.html"/>
      <url>/post/c9dcc4e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="4-7-Exercise"><a href="#4-7-Exercise" class="headerlink" title="4.7 Exercise"></a>4.7 Exercise</h1><h2 id="4-7-1-Exercises-for-Script-A"><a href="#4-7-1-Exercises-for-Script-A" class="headerlink" title="4.7.1 Exercises for Script A"></a><strong>4.7.1 Exercises for Script A</strong></h2><ol><li><p>Create a 4 × 8 matrix of randomly generated numbers. </p></li><li><p>Loop through all rows and columns, and test whether each element is greater than 0.5. </p></li><li><p>Report the results of the test along with the value of the matrix element and its row-column position. For example, your Matlab script should print The 3rd row and 8th column has a value of 0.42345 and is not bigger than 0.5 . </p></li><li><p>Make sure to add exceptions to print out 1st, 2nd, and 3rd, instead of 1th, 2th, and 3th. </p></li><li><p>Put this code into a separate function that you can call from the command line with two inputs, corresponding to the number of rows and the number of columns of the matrix. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.1 Exercises for Script A</span></span><br><span class="line">matA = GreaterThanPointFive(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成一个 rowx × colx 的0~1随机数矩阵，并输出各行各列上的元素及其与0.5的大小关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matx</span> = <span class="title">GreaterThanPointFive</span><span class="params">(rowx, colx)</span></span></span><br><span class="line">    matx = <span class="built_in">rand</span>(rowx,colx);</span><br><span class="line">    NoString = [<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;st&#x27;</span>;<span class="string">&#x27;nd&#x27;</span>;<span class="string">&#x27;rd&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> rowi = <span class="number">1</span>:rowx</span><br><span class="line">        <span class="keyword">for</span> coli = <span class="number">1</span>:colx</span><br><span class="line">            <span class="keyword">if</span> matx(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is not bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="4-7-2-Exercises-for-Script-B"><a href="#4-7-2-Exercises-for-Script-B" class="headerlink" title="4.7.2 Exercises for Script B"></a><strong>4.7.2 Exercises for Script B</strong></h2><ol><li><p>Import and plot the picture of Amsterdam that comes with the online Matlab code. </p></li><li><p>On top of the picture, plot a thick red line from “ Nieuwmarkt ” (near the center of the picture) to “ Station Amsterdam Centraal ” (near the top of the picture). </p></li><li><p>Plot a magenta star over the Waterlooplein metro station (a bit South of Nieuwmarkt). </p></li><li><p>Find the maximum value on each color dimension (red, green, or blue) and plot a circle using that color. There may be more than one pixel with a maximum value; if so, pick one pixel at random. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.2 Exercises for Script B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 6. Import and plot picture</span></span><br><span class="line">amsterdamImg = imread(<span class="string">&quot;amsterdam.bmp&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">imagesc(amsterdamImg);</span><br><span class="line">axis image</span><br><span class="line">axis on</span><br><span class="line">grid on</span><br><span class="line">grid minor</span><br><span class="line"></span><br><span class="line"><span class="comment">% 7. plot a thick red line</span></span><br><span class="line">line([<span class="number">367</span>,<span class="number">395</span>],[<span class="number">325</span>,<span class="number">75</span>],<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 8. plot a magenta star</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">375</span>,<span class="number">490</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 9.find maximum value on each color dimension and plot a circle using it</span></span><br><span class="line"><span class="comment">% 分别提取RGB数值</span></span><br><span class="line">R = amsterdamImg(:,:,<span class="number">1</span>);</span><br><span class="line">G = amsterdamImg(:,:,<span class="number">2</span>);</span><br><span class="line">B = amsterdamImg(:,:,<span class="number">3</span>);</span><br><span class="line"><span class="comment">% 找到最大的RGB值</span></span><br><span class="line">R_max = <span class="built_in">max</span>(R);</span><br><span class="line">G_max = <span class="built_in">max</span>(G);</span><br><span class="line">B_max = <span class="built_in">max</span>(B);</span><br><span class="line"><span class="comment">% 找到最大值所在位置</span></span><br><span class="line">[R_maxRow, R_maxCol] = <span class="built_in">find</span>(R==R_max);</span><br><span class="line">[G_maxRow, G_maxCol] = <span class="built_in">find</span>(G==G_max);</span><br><span class="line">[B_maxRow, B_maxCol] = <span class="built_in">find</span>(B==B_max);</span><br><span class="line"><span class="comment">% 随机选择一个索引</span></span><br><span class="line">R_idx = randi(<span class="built_in">length</span>(R_maxRow));</span><br><span class="line">G_idx = randi(<span class="built_in">length</span>(G_maxRow));</span><br><span class="line">B_idx = randi(<span class="built_in">length</span>(B_maxRow));</span><br><span class="line"><span class="comment">% 获取坐标</span></span><br><span class="line">R_position = [R_maxRow(R_idx), R_maxCol(R_idx)];</span><br><span class="line">G_position = [G_maxCol(G_idx), G_maxCol(G_idx)];</span><br><span class="line">B_position = [B_maxCol(B_idx), B_maxCol(B_idx)];</span><br><span class="line"><span class="comment">% 在图像上最大值位置绘制圆圈</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(R_position(<span class="number">1</span>),R_position(<span class="number">2</span>),<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(G_position(<span class="number">1</span>),G_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(B_position(<span class="number">1</span>),B_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/14/iN765E42mOtMnhP.png" alt="image-20240814164819625" style="zoom:67%;" /></p><h2 id="4-7-3-Exercises-for-Script-C"><a href="#4-7-3-Exercises-for-Script-C" class="headerlink" title="4.7.3 Exercises for Script C"></a><strong>4.7.3 Exercises for Script C</strong></h2><ol><li><p>From the function you wrote for exercise 5, generate a 32 × 3 number matrix in which the three numbers in each row correspond to the row, column, and result of the test (1 for bigger than 0.5; 0 for smaller than 0.5). </p></li><li><p>Write this 32 × 3 matrix to a text file that contains this matrix along with appropriate variable labels in the first row. Make sure this file is tab-delimited and readable by a spreadsheet software such as Microsoft Excel or Open Office Calc. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 运行该代码前请先运行Exercise_04_A</span></span><br><span class="line"></span><br><span class="line">matC = NaN(<span class="number">32</span>,<span class="number">3</span>);   <span class="comment">% 第一、二列为matA的行、列坐标，第三列为该坐标上的元素是否大于0.5</span></span><br><span class="line">countRowi = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rowi = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> coli = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">2</span>)</span><br><span class="line">        matC(countRowi,<span class="number">1</span>) = rowi;</span><br><span class="line">        matC(countRowi,<span class="number">2</span>) = coli;</span><br><span class="line">        <span class="keyword">if</span> matA(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        countRowi = countRowi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 将matC写入txt文件</span></span><br><span class="line">fileC = fopen(<span class="string">&#x27;data_output_04C.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% variable labels</span></span><br><span class="line">variable_labels = &#123;<span class="string">&#x27;row&#x27;</span>;<span class="string">&#x27;column&#x27;</span>;<span class="string">&#x27;result&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">% 写入第一行变量名</span></span><br><span class="line"><span class="keyword">for</span> vari=<span class="number">1</span>:<span class="built_in">length</span>(variable_labels)</span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;%s\t&#x27;</span>,variable_labels&#123;vari&#125;);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 换行</span></span><br><span class="line">fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> datarowi=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> columni=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">2</span>)</span><br><span class="line">        fprintf(fileC,<span class="string">&#x27;%g\t&#x27;</span>,matC(datarowi,columni));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fclose(fileC);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part 2 Preprocessing and Time-Domain Analyses | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd3c2.html"/>
      <url>/post/c9dcd3c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-7-数据预处理"><a href="#Chapter-7-数据预处理" class="headerlink" title="Chapter 7 数据预处理"></a>Chapter 7 数据预处理</h1><h2 id="The-Balance-between-Signal-and-Noise-信号与噪声的取舍平衡"><a href="#The-Balance-between-Signal-and-Noise-信号与噪声的取舍平衡" class="headerlink" title="The Balance between Signal and Noise | 信号与噪声的取舍平衡"></a>The Balance between Signal and Noise | 信号与噪声的取舍平衡</h2><p>保留更多的信号通常也意味着保留更多的噪声。</p><p>某些数据是信号还是噪声取决于实验的目的。</p><hr><h2 id="Creating-Epochs"><a href="#Creating-Epochs" class="headerlink" title="Creating Epochs"></a>Creating Epochs</h2><p>提取epoch的过程可以认为是将一段完整的数据划分成不同的小段</p><h4 id="1-如何选择“time-0”的时刻"><a href="#1-如何选择“time-0”的时刻" class="headerlink" title="1. 如何选择“time=0”的时刻"></a>1. 如何选择“time=0”的时刻</h4><ul><li>对于大多数实验，选择刺激开始的时刻作为time=0</li><li>对于其他情况，如有多个刺激时，可选择第一个刺激或最关键的刺激开始的时刻作为time=0</li><li>time-lock（time=0时刻的选择）是可以根据需要调节变化的</li></ul><h4 id="2-time-0前后需要包含多长时间"><a href="#2-time-0前后需要包含多长时间" class="headerlink" title="2. time=0前后需要包含多长时间"></a>2. time=0前后需要包含多长时间</h4><p>对于<strong>ERPs</strong>分析，划分的小段只需要包含你<strong>想要分析的时间段加上baseline</strong>，例如相对于0时刻的-200ms到800ms。</p><p>对于<strong>时频分析</strong>，需要划分<strong>更长</strong>的时间段，以避免<strong>边缘伪影（edge artifacts）</strong>，即需要<strong>预留足够长的缓冲区，使边缘伪影消退</strong>。此外，提取的频带越小，需要预留的缓冲区也应该越长。在时频功率谱中，边缘伪影很容易识别，因此可以先试分析一组数据再确定需要预留的缓冲区长度。通常情况下，将缓冲区长度设置为所分析的最低频率所对应的三个周期就足够了（例如，对2Hz的频率，设置缓冲区为1500ms）。</p><p>如果划分的epoch不够长，可以使用“reflection”的方法，即将这一段数据关于开始和结尾时刻首尾对称一下，再拼接到数据前和数据后，这样就可以得到三倍长的epoch。</p><p><img src="https://s2.loli.net/2024/08/12/pR8OtBZfriq4GJx.png" alt="image-20240812153014767"></p><hr><h2 id="Matching-Trial-Count-across-Conditions-Trial数量的设置与平衡"><a href="#Matching-Trial-Count-across-Conditions-Trial数量的设置与平衡" class="headerlink" title="Matching Trial Count across Conditions | Trial数量的设置与平衡"></a>Matching Trial Count across Conditions | Trial数量的设置与平衡</h2><h4 id="1-不同的实验条件尽量设置相同的trial数："><a href="#1-不同的实验条件尽量设置相同的trial数：" class="headerlink" title="1. 不同的实验条件尽量设置相同的trial数："></a><strong>1. 不同的实验条件尽量设置相同的trial数：</strong></h4><p>理想情况下，所有条件（例如实验设计中的不同实验条件或组别）应该有相同数量的试验。这样可以确保分析结果的公平性和可比性。</p><h4 id="2-trial数量对不同分析的影响："><a href="#2-trial数量对不同分析的影响：" class="headerlink" title="2. trial数量对不同分析的影响："></a><strong>2. trial数量对不同分析的影响</strong>：</h4><ul><li><strong>基于相位的分析</strong>：相位分析对试验数量特别敏感。如果trial数量较少，结果中会出现正偏差（positive bias），即trial数量少的实验条件可能显示出更大的结果。这是因为相位分析对于小样本量更容易受到随机波动的影响，导致条件间结果的偏差。</li><li><strong>基于功率的分析</strong>：功率分析也可能出现一些正偏差。因为功率值通常是正值，数据中的噪声更倾向于增加功率值，所以较少的试验数量可能导致功率结果偏高。</li><li>xxxxxxxxxx % 运行该代码前请先运行Exercise_04_A​matC = NaN(32,3);   % 第一、二列为matA的行、列坐标，第三列为该坐标上的元素是否大于0.5countRowi = 1;​for rowi = 1:size(matA,1)    for coli = 1:size(matA,2)        matC(countRowi,1) = rowi;        matC(countRowi,2) = coli;        if matA(rowi,coli) &gt; 0.5            matC(countRowi,3) = 1;        else            matC(countRowi,3) = 0;        end        countRowi = countRowi + 1;    endend​% 将matC写入txt文件fileC = fopen(‘data_output_04C.txt’,’w’);​% variable labelsvariable_labels = {‘row’;’column’;’result’};% 写入第一行变量名for vari=1:length(variable_labels)    fprintf(fileC,’%s\t’,variable_labels{vari});end​% 换行fprintf(fileC,’\n’);​for datarowi=1:size(matC,1)    for columni=1:size(matC,2)        fprintf(fileC,’%g\t’,matC(datarowi,columni));    end    fprintf(fileC,’\n’);end​fclose(fileC);​matlab</li></ul><h4 id="3-应对低trial数量的方法："><a href="#3-应对低trial数量的方法：" class="headerlink" title="3. 应对低trial数量的方法："></a><strong>3. 应对低trial数量的方法</strong>：</h4><p>对于ERP分析，如果试验数量较少，与其依赖峰值时间（peak times）的分析，不如取一段时间范围内的平均幅值（mean amplitude）。这种方法对噪声更为稳健，不容易受到个别异常值的影响。</p><h4 id="4-应对不同实验条件的trial数量不一致的方法："><a href="#4-应对不同实验条件的trial数量不一致的方法：" class="headerlink" title="4. 应对不同实验条件的trial数量不一致的方法："></a><strong>4. 应对不同实验条件的trial数量不一致的方法</strong>：</h4><p>如果出现不同的实验条件下的trial数目不一致，假设最小的trial数为N，那么可以通过以下方法来平衡trial数：</p><ul><li>（不建议采用）直接选前N个trial</li><li>随机选N个trial</li><li>根据一些相关的行为或实验变量，如反应时间等，有目的地选N个trial</li></ul><hr><h2 id="Trial-Rejection"><a href="#Trial-Rejection" class="headerlink" title="Trial Rejection"></a>Trial Rejection</h2><hr><h1 id="Chapter-9-Overview-of-Time-Domain-EEG-Analyses"><a href="#Chapter-9-Overview-of-Time-Domain-EEG-Analyses" class="headerlink" title="Chapter 9 Overview of Time-Domain EEG Analyses"></a>Chapter 9 Overview of Time-Domain EEG Analyses</h1><h2 id="Event-Related-Potentials-ERPs"><a href="#Event-Related-Potentials-ERPs" class="headerlink" title="Event-Related Potentials (ERPs)"></a>Event-Related Potentials (ERPs)</h2><p>To create ERPs, simply align the time-domain EEG to the time=0 event (this was probably already done during preprocessing) and <strong>average across trials</strong> at each time point.</p><ul><li>指定 time points</li><li>trial average</li></ul><hr><h2 id="Butterfly-Plots"><a href="#Butterfly-Plots" class="headerlink" title="Butterfly Plots"></a>Butterfly Plots</h2><p>A butterfly ploy shows <strong>the ERP from all electrodes</strong> overlaid in the same figure.</p><hr><h2 id="Global-Field-Power-Topographical-Variance-Plots"><a href="#Global-Field-Power-Topographical-Variance-Plots" class="headerlink" title="Global Field Power / Topographical Variance Plots"></a>Global Field Power / Topographical Variance Plots</h2><p>The global field power is <strong>the standard deviation</strong> of activity over <strong>all electrodes</strong>.</p><hr><h2 id="The-Flicker-Effect"><a href="#The-Flicker-Effect" class="headerlink" title="The Flicker Effect"></a>The Flicker Effect</h2><p>The flicker effect in EEG research refers to entrainment of brain activity to a rhythmic extrinsic driving factor. This effect is also referred to as steady-state evoked potential, frequency tagging, SSVEP (steady-state visual evoked potential), SSAEP (auditory evoked potential), or something similar. </p><p>The flicker effect is arguably an underutilized tool in cognitive electrophysiology. The main benefit of the flicker effect is that it allows you to <strong>“ tag ” the processing of a specific stimulus</strong>.</p><p><strong>(from ChatGPT)</strong></p><p>假设你正在进行一项视觉注意力的研究，目的是研究大脑如何同时处理多个视觉刺激。你在屏幕上呈现两个物体：一个物体以12 Hz的频率闪烁（即每秒闪烁12次），另一个物体以15 Hz的频率闪烁。你让参与者专注于两个物体之一，然后使用EEG记录他们的大脑活动。</p><p>在这种情况下，闪烁效应会导致大脑中处理视觉信息的区域（通常是视觉皮层）出现与这两个频率相对应的节律性活动。12 Hz的物体会在大脑中产生12 Hz的节律性活动，15 Hz的物体会产生15 Hz的节律性活动。通过分析EEG数据中的频率成分，你可以识别出大脑中对应这两个不同频率的活动区域。</p><p>即使EEG无法像功能性磁共振成像（fMRI）那样精确地显示大脑中具体的活动区域，你仍然可以通过这些频率标记来“分离”出大脑中对12 Hz和15 Hz刺激分别作出反应的神经元群体。换句话说，虽然EEG的空间分辨率较低，但通过闪烁效应，你可以“假设”出对不同刺激反应的特定神经区域。</p><p><strong>具体的例子说明</strong>：</p><ul><li><p><strong>12 Hz闪烁的物体</strong>：如果参与者主要关注这个物体，你会看到EEG数据中12 Hz频率的功率增加，这表明视觉皮层中的某个区域在处理这个物体。</p></li><li><p><strong>15 Hz闪烁的物体</strong>：如果参与者关注这个物体，EEG数据中15 Hz频率的功率会增加，显示另一个区域在处理这个物体。</p></li></ul><p>通过这种方法，即使两个物体在大脑中产生的活动区域相距较近，由于频率不同，你依然能够区分开来。这就相当于“模拟”出了一种高空间分辨率，使得你可以推断大脑中不同区域对不同刺激的反应。</p><hr><h2 id="Topographical-Maps"><a href="#Topographical-Maps" class="headerlink" title="Topographical Maps"></a>Topographical Maps</h2><p>Creating a topographical map is conceptually similar to interpolating an electrode, except that instead of estimating the activity at one point in space corresponding to a missing electrode, activity is estimated at many point in space between electrodes.</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">topoplot()</span><br></pre></td></tr></table></figure><hr><h2 id="Microstates"><a href="#Microstates" class="headerlink" title="Microstates"></a>Microstates</h2><p>In EEG as well as ERP map series, for brief, subsecond time periods, map landscapes typically remain quasi-stable, then change very quickly into different landscapes.</p><p>Durations tend to be around the <strong>alpha range (70-130 ms)</strong>, and topographical distributions tend to fit into <strong>four or five distinct patterns</strong>.</p><hr><h2 id="ERP-Images"><a href="#ERP-Images" class="headerlink" title="ERP Images"></a>ERP Images</h2><p>An ERP image is a 2-D representation of the EEG data from <strong>a single electrode</strong>. Rather than all trials averaged together to form an ERP, the <strong>single-trial</strong> EEG traces are stacked vertically and then color coded to show changes in amplitude as changes in color. </p>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part 1 Introduction | Analyzing Neural Time Series Data</title>
      <link href="/post/c9der4c1.html"/>
      <url>/post/c9der4c1.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-D-topographical-locations-of-EEG-electrodes"><a href="#2-D-topographical-locations-of-EEG-electrodes" class="headerlink" title="2-D topographical locations of EEG electrodes"></a>2-D topographical locations of EEG electrodes</h2><p><img src="https://s2.loli.net/2024/08/14/A4dNGTsBf8xHj5t.png" alt="image-20240814152033522" style="zoom:60%;" /> </p><hr><h2 id="Brain-rhythm-frequency-bands"><a href="#Brain-rhythm-frequency-bands" class="headerlink" title="Brain rhythm frequency bands"></a>Brain rhythm frequency bands</h2><blockquote><p>delta (2-4 HZ)</p><p>theta (4-8 Hz)</p><p>alpha (8-12 Hz)</p><p>beta (15-30 Hz)</p><p>lower gamma (30-80 Hz)</p><p>upper gamma (80-150 Hz)</p><p>subdelta and omega (up to 600 HZ)</p></blockquote><hr><h1 id="Intra-and-Intertrial-Timing"><a href="#Intra-and-Intertrial-Timing" class="headerlink" title="Intra- and Intertrial Timing"></a><strong>Intra- and Intertrial Timing</strong></h1><ul><li><strong>*Intra</strong>trial*：单个trail内。</li><li><strong>*Inter</strong>tial*: 不同trial之间。the duration of time between the end of one trial and the start of the next trial</li></ul><hr><h1 id="Phase-Locked-and-Nonphase-Locked"><a href="#Phase-Locked-and-Nonphase-Locked" class="headerlink" title="Phase-Locked and Nonphase-Locked"></a>Phase-Locked and Nonphase-Locked</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL之哈希表</title>
      <link href="/post/751f48bb.html"/>
      <url>/post/751f48bb.html</url>
      
        <content type="html"><![CDATA[<p>C++ STL中，哈希表对应的容器是unordered_map（since C++ 11）。</p><p>STL中，<strong>map</strong> 对应的数据结构是 <strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 <strong>O(logN)</strong>。而 <strong>unordered_map</strong> 对应 <strong>哈希表</strong>，哈希表的特点就是查找效率高，时间复杂度为常数级别 <strong>O(1)</strong>， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 unordered_map 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 map 容器。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p>unordered_map 是一种关联容器，用于存储由关键值 (Key Value，以下称为Key 值) 和映射值 (Mapped Value，以下称为映射值) 组成的元素，并且允许根据其 Key 值快速检索各个元素。</p></li><li><p>在 unordered_map 容器中，Key 值通常用来唯一标识元素，映射值是与该 Key 值关联内容的对象。Key 值与映射值的类型可能不同。</p></li><li><p>在 unordered_map 内部，元素没有按照其 Key 值与映射值的任何顺序进行排序 ，而是根据它们的 Hash 值组织成桶，允许它们通过其 Key 值直接快速访问单个元素（通常具有常数等级的平均时间复杂度）。</p></li><li><p>unordered_map 容器与 map 容器相比，通过 Key 值访问各个元素的速度更快，然而通过其元素子集进行范围迭代的效率通常较低。</p></li><li><p>unordered_map 实现了直接访问操作符 (operator[])，它允许使用 Key 值作为输入参数，直接访问映射值。</p></li><li><p>容器中的迭代器至少是前向迭代器。</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>引入头文件 <strong><unordered_map></strong> </p></li><li><p>unordered_map<key,value> m;</p></li><li><p>m.size();    //元素数量</p></li><li><p>m.insert(x);</p></li><li><p>m.find(key);</p><p>m.count(key);</p></li><li><p>m.erese(key);</p></li><li><p>m[key] → value</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li><p>基本使用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="string">&#x27;a&#x27;</span>] = <span class="number">9</span>;</span><br><span class="line">m[<span class="string">&#x27;?&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">m[<span class="string">&#x27;z&#x27;</span>] = <span class="number">99</span>;</span><br><span class="line">m[<span class="string">&#x27;A&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">m[<span class="string">&#x27;Z&#x27;</span>] = <span class="number">-2</span>;</span><br><span class="line">m[<span class="string">&#x27; &#x27;</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出元素个数</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找&#x27; &#x27;元素是否存在，若存在，输出其对应的值；</span></span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">count</span>(<span class="string">&#x27; &#x27;</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; m[<span class="string">&#x27; &#x27;</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出内部所有元素，体现无序性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">begins</span>(); it != m.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">Z -2</span><br><span class="line">  0</span><br><span class="line">A 50</span><br><span class="line">? 5</span><br><span class="line">z 99</span><br><span class="line">a 9</span><br></pre></td></tr></table></figure></li><li><p>Leetcode <a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Key is the number and value is its index in the vector</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hash;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> &lt;<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> numberToFind = target - number[i];</span><br><span class="line">            <span class="comment">//if numberToFind is found in map, return them</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(numberToFind) != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(hash[numberToFind);</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">                hash[numbers[i]] = i;                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;                              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 散落的知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建记录</title>
      <link href="/post/7cfd23b7.html"/>
      <url>/post/7cfd23b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="2023-2"><a href="#2023-2" class="headerlink" title="2023.2"></a>2023.2</h2><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>生成markdown文件，在命令行输入:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>在blog根目录下的source文件夹中的post文件夹会多一个 <strong>博客名字.md</strong> 的markdown文件，打开即可进行编辑。</p><h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>markdown语法参考链接 <a href="https://www.appinn.com/markdown/">Markdown语法说明（简体中文版）</a></p><h3 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h3><p>在根目录下git命令行输入三连指令，即可完成新页面的发布</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>如果在发布前想预览生成网站的效果，可输入</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><hr><h2 id="2024-7-25"><a href="#2024-7-25" class="headerlink" title="2024.7.25"></a>2024.7.25</h2><p>近日心血来潮地想起自己两年前心血来潮搭的网站，想到自己已经为这个域名掏了三年的钱包，还是要好好利用起来，于是再次开始维护。</p><h3 id="主页顶部图片更改"><a href="#主页顶部图片更改" class="headerlink" title="主页顶部图片更改"></a>主页顶部图片更改</h3><p>维护时首先想到的就是把主页顶部图片换了，顶部图片的更换非常简单，我目前使用的是butterfly主题，只需要在<code>_config.butterfly.yml</code>中修改<code>index_img</code>后的图片链接即可：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The banner image of home page （主页封面图片）</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/img/The_Valley_of_the_Wind.jpg</span></span><br></pre></td></tr></table></figure><h3 id="文章页背景更换"><a href="#文章页背景更换" class="headerlink" title="文章页背景更换"></a>文章页背景更换</h3><p>之前不知什么时候给博客更换了一个花里胡哨的背景，使用一段时间后还是觉得白底黑字看起来最舒服，于是决定修改当前背景。背景更换需打开<code>Blog\themes\butterfly\source\css</code>目录下的<code>custom.css</code>，修改其中的<code>#web_bg</code></p><p>背景设置为渐变色</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#web_bg &#123;</span></span><br><span class="line"><span class="attr">background-image:</span> <span class="string">linear-gradient(to</span> <span class="string">top,</span> <span class="comment">#fef9d7 0%, #d299c2 100%);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>背景设置为纯色</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#web_bg &#123;</span></span><br><span class="line"><span class="attr">background-color:</span> <span class="comment">#ffffff;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="部署时spawn-failed报错问题的解决"><a href="#部署时spawn-failed报错问题的解决" class="headerlink" title="部署时spawn failed报错问题的解决"></a>部署时spawn failed报错问题的解决</h3><p>在完成一些参数的修改后，使用<code>hexo d</code>部署时却出现了spawn failed的报错。发现报错后首先尝试了目前主流的两种解决方案：</p><h4 id="1-重置git的deploy文件夹"><a href="#1-重置git的deploy文件夹" class="headerlink" title="1. 重置git的deploy文件夹"></a>1. 重置git的deploy文件夹</h4><p>删除blog文件夹中的<code>.deploy_git</code>文件夹，然后在终端cd进这个文件夹后输入<code>git config --global core.autocrlf false</code></p><h4 id="2-修改git-repo配置地址"><a href="#2-修改git-repo配置地址" class="headerlink" title="2. 修改git repo配置地址"></a>2. 修改git repo配置地址</h4><p>打开<code>_config.yml</code>配置文件，修改以下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"></span><br><span class="line"><span class="attr">repo:</span> <span class="string">https://github.com/yourname/yourname.github.io.git</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>其中的repo修改为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br></pre></td></tr></table></figure><h4 id="3-重置GitHub-SSH密钥"><a href="#3-重置GitHub-SSH密钥" class="headerlink" title="3. 重置GitHub SSH密钥"></a>3. 重置GitHub SSH密钥</h4><p>很遗憾，上面的两种方法最终都没能解决我的问题，但在查看<a href="https://blog.zhheo.com/p/128998ac.html">张洪Heo</a>的博客文章后我意识到可能是<strong>GitHub SSH密钥设置</strong>出现了问题。果然，在git命令行中尝试使用SSH连接时出现了错误。</p><p>git命令行输入：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey)</span><br></pre></td></tr></table></figure><p>登录许久未使用的用于部署网站的GitHub账号，发现<strong>原有的SSH密钥已被删除</strong>，原来作为安全预防措施，GitHub会自动删除一年内未使用过的 SSH 密钥。于是重新走了一遍设置GitHub密钥的流程（具体可参考“<a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a>”），问题终于成功解决。</p><hr><h2 id="2024-8-12"><a href="#2024-8-12" class="headerlink" title="2024.8.12"></a><strong>2024.8.12</strong></h2><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>在markdown中插入图片的语法为</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">src</span>)</span><br></pre></td></tr></table></figure><p>其中<code>src</code>既可以是本地图片的绝对/相对路径，比如<code>../images/test.png</code>，也可以是URL。<code>alt</code>是图片的注释，可以为空。</p><p>考虑到本地图片在网页中的加载速度较慢，且插入至markdown中的步骤比较繁琐，我采用了SMMS图床＋Typora自动上传的方法，这样只需要直接将图片粘贴到Typora中，图片就可以自动上传到图床。具体的配置步骤见<a href="https://blog.csdn.net/m0_56416743/article/details/132021539">Typora1.6.7+图床SMMS自动上传教程(PicGo-Core(command line)方式</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP问题</title>
      <link href="/post/41ef174f.html"/>
      <url>/post/41ef174f.html</url>
      
        <content type="html"><![CDATA[<h1 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h1><ul><li><strong>NP问题</strong> 的全称是：Non deterministic Ploynomial问题，即非确定性多项式问题。</li><li><strong>多项式时间（Polynomial time）</strong> 在计算复杂度理论中，指的是一个问题的计算时间m(n)不大于问题大小n的多项式倍数。</li><li><p><strong>什么是非确定性问题？</strong> </p><p>  有些计算问题是确定性的，比如加减乘除之类，你只要按照公式推导，按部就班一步步来，就可以得到结果。但是，有些问题是无法按部就班直接地计算出来。比如，找大质数的问题。有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的。再比如，大的合数分解质因数的问题，有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式。</p><p>  这种问题的答案，是无法直接计算得到的，只能通过间接的“猜算”来得到结果。这也就是<em>非确定性问题</em>。而这些问题的通常有个算法，它不能直接告诉你答案是什么，但可以告诉你，某个可能的结果是正确的答案还是错误的。这个可以告诉你“猜算”的答案正确与否的算法，假如可以在多项式时间内算出来，就叫做<em>多项式非确定性问题</em>。</p></li><li><strong>NP问题</strong> 就是非确定性的多项式问题，也就是说，可以在多项式时间内验证一个解是否正确的问题是NP问题。</li><li><p><strong>P问题</strong> 是能在多项式时间内求出其解的问题，所有的P问题都是NP问题，但是是否P=NP，目前还没有被证明。</p><p>  （不是所有的NP问题都是难解的问题，比如数组排序的问题就是P类问题，但是P属于NP问题，所它也是NP问题，但是他并不难解。）</p></li><li><p><strong>NP困难问题：</strong> 对于一个判定问题A,如果所有的NP问题都可以多项式时间规约到A，那么这个问题就是NP困难问题。</p></li><li><p><strong>NPC问题：</strong> 对于一个NP问题A，如果所有的NP问题都可以多项式时间规约到A，那么这个问题就是NP困难问题。</p></li><li><p><strong>NPC</strong>，也称NP完全问题，它是NP问题的一个子类，比如哈密尔顿回路问题就是NPC问题。它是这样描述的，给定N个顶点，以及任意两个顶点之间的距离，求出一条回路，使其经过每个顶点，且回路的总距离最短。这个问题可以通过枚举求出解，但是他的时间复杂度是(N-1)!,随着N的增大，要计算解是不可能的。</p><p>  NPC有一种性质，那就是如果能证明NPC问题可以在多项式时间内求出其解，则所有的NP都可以在多项式时间内求解了，即P=NP成立。所以，我们一般认为NPC问题是难解的问题，因为他不太可能存在一个多项式时间的算法（如果存在则所有的NP问题都存在多项式时间算法，这太不可思议了，但是也不是不可能）。</p></li><li><p><strong>NP完全问题的证明:</strong> 要证明一个判定问题是NP完全的,只要在NP完全类中找到一个问题A,将这个问题归约到待证明问题即可.要证明问题是NP完全是很困难的,因为很多问题之间的转化过程是很难想到的.第一个被证明的NP完全问题是可满足性问题,它是判定一个合取范式的布尔公式F是否存在真值指派的问题.在很多NP完全问题的证明中,我们都可以用这个问题来归约,这里不再详述。</p></li></ul><hr><p>转自<a href="https://blog.csdn.net/zxj1988/article/details/6275458">CSDN博主zxj1988的文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 散落的知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
