<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Part 3 Exercises | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd3t1.html"/>
      <url>/post/c9dcd3t1.html</url>
      
        <content type="html"><![CDATA[<h1 id="10-6-Exercise"><a href="#10-6-Exercise" class="headerlink" title="10.6 Exercise"></a>10.6 Exercise</h1><h2 id="10-6-1"><a href="#10-6-1" class="headerlink" title="10.6.1"></a>10.6.1</h2><ol><li>Create two kernels for convolution: one that looks like a U and one that looks like a decay function. There is no need to be too sophisticated in generating, for example, a Gaussian and an exponential; numerical approximations are fine.</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 10</span></span><br><span class="line"><span class="comment">% 1. Create two kernels </span></span><br><span class="line">kernel_U = [<span class="number">1</span> <span class="number">0.8</span> <span class="number">0.3</span> <span class="number">0.1</span> <span class="number">0</span> <span class="number">0.1</span> <span class="number">0.3</span> <span class="number">0.8</span> <span class="number">1</span>];</span><br><span class="line">kernel_decay = [<span class="number">1</span> <span class="number">0.9</span> <span class="number">0.8</span> <span class="number">0.7</span> <span class="number">0.5</span> <span class="number">0.3</span> <span class="number">0.2</span> <span class="number">0.1</span> <span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="10-6-2"><a href="#10-6-2" class="headerlink" title="10.6.2"></a>10.6.2</h2><ol><li>Convolve these two kernels with 50 time points of EEG data from one electrode. Make a plot showing the kernels, the EEG data, and the result of the convolution between the data and each kernel. Use time-domain convolution as explained in this chapter and as illustrated in the online Matlab code. Based on visual inspection, what is the effect of convolving the EEG data with these two kernels?</li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2</span></span><br><span class="line"><span class="comment">% Snippet of EEG data</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">impEEG = EEG.data(<span class="number">47</span>,<span class="number">100</span>:<span class="number">149</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用自编函数计算impEEG与kernel_U的convolution</span></span><br><span class="line"><span class="comment">% data that we&#x27;ll use for convolution (must be zero-padded).</span></span><br><span class="line">dat4conv = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) impEEG <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) ];</span><br><span class="line"></span><br><span class="line"><span class="comment">% used for cutting the result of convolution</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize convolution output</span></span><br><span class="line">convolution_result_U = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(impEEG)+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% run convolution (note that kernel is flipped backwards) ti以外的范围会被舍弃，没必要计算</span></span><br><span class="line"><span class="keyword">for</span> ti=half_of_kernel_size+<span class="number">1</span>:<span class="built_in">length</span>(convolution_result_U)-half_of_kernel_size         </span><br><span class="line">    convolution_result_U(ti) = sum(dat4conv(ti:ti+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>).*kernel_U(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_U = convolution_result_U(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用Matlab自带函数conv()计算impEEG与kernel_decay的convolution</span></span><br><span class="line">convolution_result_decay = conv(impEEG,kernel_decay,<span class="string">&#x27;same&#x27;</span>);    <span class="comment">%% &#x27;same&#x27;:conv的结果与impfun的长度相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot kernels</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">311</span>)</span><br><span class="line"><span class="built_in">plot</span>(kernel_U,<span class="string">&#x27;bo-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(kernel_decay,<span class="string">&#x27;ro-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;decay&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.84</span> <span class="number">0.13512</span> <span class="number">0.064683</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Points&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Convolution kernels&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot Snippet of EEG data</span></span><br><span class="line">subplot(<span class="number">312</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Snippet of EEG data (EEG.data(47,100:149,10))&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot EEG data before and after convolution</span></span><br><span class="line">subplot(<span class="number">313</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;k-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_U./sum(kernel_U),<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_decay./sum(kernel_decay),<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;U-convolved&#x27;</span>,<span class="string">&#x27;decay-convolved&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.65</span> <span class="number">0.245</span> <span class="number">0.2</span> <span class="number">0.09</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;EEG data before and after convolution&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/17/Id6gBtjlfc2LV1M.png" alt="Ex_10" style="zoom:67%;" /></p><hr><h1 id="11-12-Exercise"><a href="#11-12-Exercise" class="headerlink" title="11.12 Exercise"></a>11.12 Exercise</h1><h2 id="11-12-1"><a href="#11-12-1" class="headerlink" title="11.12.1"></a>11.12.1</h2><p>Reproduce the top three panels of figure 11.12 three times. </p><ul><li><p>First, perform time-domain convolution using <strong>the “ manual ” convolution method</strong> shown in chapter 10. </p></li><li><p>Second, perform frequency-domain convolution using <strong>the discrete time Fourier transform</strong> presented at the beginning of this chapter. </p></li><li>Finally, perform frequency-domain convolution using <strong>the Matlab functions fft and ifft</strong> (do not use the function conv). (You can optionally reproduce the bottom panel of figure 11.12 for the frequency domain analyses; keep in mind that the power scaling is for display purposes only.) </li></ul><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 1. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">    conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"><span class="comment">% Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    <span class="comment">% create sine wave</span></span><br><span class="line">    sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">    fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line"></span><br><span class="line"><span class="comment">% inverse Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line">conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,eegdat4convol);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_manual,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_Fourier,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_fft,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;&quot;manual&quot; convolution method&#x27;</span>,<span class="string">&#x27;discrete time Fourier transform&#x27;</span>,<span class="string">&#x27;Matlab functions fft and ifft&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/dHleLSJOyTUR9xt.png" alt="Ex_11"></p><h2 id="11-12-2"><a href="#11-12-2" class="headerlink" title="11.12.2"></a>11.12.2</h2><p>From the three sets of Matlab code you have for reproducing figure 11.12 , run a computation time test. That is, time how long it takes Matlab to perform 1000 repetitions of each of the three methods for computing convolution that you generated in the previous exercise (do not plot the results each time). You can use the Matlab function pairs tic and toc to time a Matlab process. Plot the results in a bar plot, similar to figure 11.8 . </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 2. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line">t = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">        conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">1</span>) = toc;</span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="comment">% Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        <span class="comment">% create sine wave</span></span><br><span class="line">        sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">        fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% inverse Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">2</span>) = toc;</span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">    conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">3</span>) = toc;</span><br><span class="line"><span class="comment">%% plot results in a bar plot</span></span><br><span class="line">b = bar(t);</span><br><span class="line">labels = string(b(<span class="number">1</span>).YData);</span><br><span class="line">text(b(<span class="number">1</span>).XEndPoints,b(<span class="number">1</span>).YEndPoints,labels,<span class="string">&#x27;HorizontalAlignment&#x27;</span>,<span class="string">&#x27;center&#x27;</span>,<span class="string">&#x27;VerticalAlignment&#x27;</span>,<span class="string">&#x27;top&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>])</span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,&#123;<span class="string">&#x27;manual convolution&#x27;</span>;<span class="string">&#x27;DTFT&amp;IDTFT&#x27;</span>;<span class="string">&#x27;FFT&amp;IFFt&#x27;</span>&#125;)</span><br><span class="line">set(gca, <span class="string">&#x27;YScale&#x27;</span>, <span class="string">&#x27;log&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;time(s)&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/391pAN7iXbJEkdl.png" alt="Ex_11(2)" style="zoom: 50%;" /></p><h2 id="11-12-3"><a href="#11-12-3" class="headerlink" title="11.12.3"></a>11.12.3</h2><p>Generate a time series by creating and summing sine waves, as in figure 11.2B . Use between two and four sine waves, so that the individual sine waves are still somewhat visible in the sum. Perform a Fourier analysis (you can use the fft function) on the resulting time series and plot the power structure. Confirm that your code is correct by comparing the frequencies with nonzero power to the frequencies of the sine waves that you generated. Now try adding random noise to the signal before computing the Fourier transform. First, add a small amount of noise so that the sine waves are still visually recognizable. Next, add a large amount of noise so that the sine waves are no longer visually recognizable in the time domain data. Perform a Fourier analysis on the two noisy signals and plot the results. What is the effect of a small and a large amount of noise in the power spectrum? Are the sine waves with noise easier to detect in the time domain or in the frequency domain, or is it equally easy/difficult to detect a sine wave in the presence of noise? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Create sine waves</span></span><br><span class="line">srate = <span class="number">400</span>;</span><br><span class="line">time=<span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">N = <span class="built_in">length</span>(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create three sine waves</span></span><br><span class="line">s1 = <span class="number">20</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">3</span>*time);</span><br><span class="line">s2 = <span class="number">10</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">8</span>*time);</span><br><span class="line">s3 = <span class="number">5</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">15</span>*time);</span><br><span class="line">sum_Sine = s1+s2+s3;</span><br><span class="line"></span><br><span class="line"><span class="comment">% add random noise</span></span><br><span class="line">Sine_LitteNoise = sum_Sine + <span class="number">10</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line">Sine_LargeNoise = sum_Sine + <span class="number">40</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">linspace</span>(<span class="number">0</span>,srate/<span class="number">2</span>,<span class="built_in">floor</span>(N/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = fft(sum_Sine)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LitteNoise = fft(Sine_LitteNoise)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LargeNoise = fft(Sine_LargeNoise)./(N/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = <span class="built_in">abs</span>(FFT_Sine(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LitteNoise = <span class="built_in">abs</span>(FFT_LitteNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LargeNoise = <span class="built_in">abs</span>(FFT_LargeNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(time,sum_Sine);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Original time series&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">bar(f,FFT_Sine);</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LitteNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">bar(f,FFT_LitteNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LargeNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, large noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>)</span><br><span class="line">bar(f,FFT_LargeNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, large noise&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/I5wHdjzGkQmMDN6.png" alt="Ex_11(3)" style="zoom: 80%;" /></p><h1 id="12-5-Exercise"><a href="#12-5-Exercise" class="headerlink" title="12.5 Exercise"></a>12.5 Exercise</h1><ol><li><p>Create a family of Morlet wavelets ranging in frequency from 2 Hz to 30 Hz in five steps. </p></li><li><p>Select one electrode from the scalp EEG dataset and convolve each wavelet with EEG data from all trials from that electrode. Apply the Matlab function real to the convolution result, as in <code>convol_result=real(convol_result)</code>. This will return the EEG data bandpass filtered at the peak frequency of the wavelet. You learn more about why this is in the next chapter. </p></li><li><p>Average the result of convolution over all trials and plot an ERP corresponding to each wavelet frequency. Each frequency should be in its own subplot. </p></li><li><p>Plot the broadband ERP (without any convolution). Thus, you will have six subplots in one figure. How do the wavelet-convolved ERPs compare with the broadband ERP? Are there dynamics revealed by the wavelet-convolved ERPs that are not apparent in the broadband ERP, and are there dynamics in the broadband ERP that are not apparent in the waveletconvolved ERPs? Base your answer on qualitative visual inspection of the results; statistics or other quantitative comparisons are not necessary. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercise 12</span></span><br><span class="line"><span class="comment">%% 1. Create a family of Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequencies = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">num_wavelets = <span class="built_in">length</span>(frequencies);</span><br><span class="line"></span><br><span class="line">srate = EEG.srate;</span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">wavelet_family = <span class="built_in">zeros</span>(num_wavelets,<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Loop through frequencies and make a family of wavelets.</span></span><br><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:num_wavelets</span><br><span class="line"> </span><br><span class="line">    <span class="comment">% create a sine wave at this frequency</span></span><br><span class="line">    sinewave = <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*frequencies(fi).*time); <span class="comment">% the &quot;1i&quot; makes it a complex wavelet</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create a Gaussian window</span></span><br><span class="line">    gaus_win = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi)))^<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create wavelet via element-by-element multiplication of the sinewave and gaussian window</span></span><br><span class="line">    wavelet_family(fi,:) = sinewave.*gaus_win;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 2. Get EEG data from electrode 47, convolve each wavelet with EEG data</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line">channel = <span class="number">47</span>;</span><br><span class="line">n_conv = EEG.pnts + <span class="built_in">length</span>(time) - <span class="number">1</span>;</span><br><span class="line">convol_result = <span class="built_in">zeros</span>(EEG.trials,num_wavelets,n_conv);</span><br><span class="line">half_of_kernal_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> trial_i = <span class="number">1</span>:EEG.trials</span><br><span class="line">    fft_EEG = fft(EEG.data(channel,:,trial_i),n_conv);</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:num_wavelets</span><br><span class="line">        fft_wavelet = fft(wavelet_family(fi,:),n_conv);</span><br><span class="line">        convol_result(trial_i,fi,:) = ifft(fft_EEG.*fft_wavelet,n_conv) * <span class="built_in">sqrt</span>(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi))) / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convol_result = <span class="built_in">real</span>(convol_result(:,:,half_of_kernal_size+<span class="number">1</span>:n_conv-half_of_kernal_size));</span><br><span class="line">filtered_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(convol_result,<span class="number">1</span>));<span class="comment">% 经过wavelet滤波后的ERP</span></span><br><span class="line">broadband_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(channel,:,:),<span class="number">3</span>)); <span class="comment">% 未滤波的ERP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_wavelets</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,filtered_ERP(<span class="built_in">i</span>,:));</span><br><span class="line">    set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-300</span>, <span class="number">1000</span>])</span><br><span class="line">    ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">    xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Wavelet filtered ERP at &#x27;</span> num2str(frequencies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,broadband_ERP);</span><br><span class="line">ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Unfiltered broadband ERP&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/19/3lrQXKtgZI4docT.png" alt="Ex_12"></p><h1 id="13-11-Exercise"><a href="#13-11-Exercise" class="headerlink" title="13.11 Exercise"></a>13.11 Exercise</h1><h2 id="1-Create-a-family-of-complex-Morlet-wavelets"><a href="#1-Create-a-family-of-complex-Morlet-wavelets" class="headerlink" title="1. Create a family of complex Morlet wavelets"></a>1. Create a family of complex Morlet wavelets</h2><p>Create a family of complex Morlet wavelets ranging in frequencies from 2 Hz to 30 Hz in five steps. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 13</span></span><br><span class="line"><span class="comment">% 1. Create a family of complex Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">time = <span class="number">-2</span>:<span class="number">1</span>/EEG.srate:<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在3和10之间生成5个对数分别的数，作为不同频率下wavelet包含的周期数目</span></span><br><span class="line">numcycles = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">10</span>),<span class="built_in">length</span>(frex));</span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex), <span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% make complex Morlet wavelets</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi));</span><br><span class="line">    wavelet(fi,:) = <span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)) * <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi).*time);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 检查两侧是否衰减到0</span></span><br><span class="line">    <span class="comment">% subplot(ceil(length(frex)/3), ceil(length(frex)/2), fi);</span></span><br><span class="line">    <span class="comment">% plot(time,real(cmw));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="2-Convolve-each-wavelet-with-EEG-data"><a href="#2-Convolve-each-wavelet-with-EEG-data" class="headerlink" title="2. Convolve each wavelet with EEG data"></a>2. Convolve each wavelet with EEG data</h2><p>Convolve each wavelet with EEG data from all electrodes and from one trial. </p><h2 id="3-Extract-power-and-phase"><a href="#3-Extract-power-and-phase" class="headerlink" title="3. Extract power and phase"></a>3. Extract power and phase</h2><p>Extract power and phase from the result of complex wavelet convolution and store in a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix). </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2. Convolve each wavelet with EEG data from all electrode and from one trial</span></span><br><span class="line">trial = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 3. a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix)</span></span><br><span class="line">convolution_result_fft = <span class="built_in">zeros</span>(n_convolution,<span class="built_in">length</span>(frex),EEG.nbchan,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% FFT of wavelet and EEG data</span></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    fft_data    = fft(<span class="built_in">squeeze</span>(EEG.data(electrodei,:,trial)),n_convolution); <span class="comment">% trial 1</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">        fft_wavelet = fft(wavelet(fi,:),n_convolution);</span><br><span class="line">        convoli = ifft(fft_wavelet.*fft_data,n_convolution) * <span class="built_in">sqrt</span>(s);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">1</span>) = <span class="built_in">abs</span>(convoli.^<span class="number">2</span>);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">2</span>) = <span class="built_in">angle</span>(convoli);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_fft = convolution_result_fft(half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size,:,:,:);</span><br></pre></td></tr></table></figure><h2 id="4-Make-topographical-plots-of-power-and-phase"><a href="#4-Make-topographical-plots-of-power-and-phase" class="headerlink" title="4. Make topographical plots of power and phase"></a>4. Make topographical plots of power and phase</h2><p>Make topographical plots of power and phase at 180 ms at all frequencies (hint: you may need to use the squeeze function to remove singleton dimensions). Arrange the plots in one figure with five columns for frequency and two rows for power/phase. Put labels in the plot so it is clear which topographical maps correspond to which frequencies. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 180 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">180</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/Tig9hvGVdEof1wx.png" alt="Ex_13(1)"></p><h2 id="5-Repeat-step-4-for-activity-at-360-ms"><a href="#5-Repeat-step-4-for-activity-at-360-ms" class="headerlink" title="5. Repeat step 4 for activity at 360 ms."></a>5. Repeat step 4 for activity at 360 ms.</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 360 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">360</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/vjkoRLn3GPxZ72m.png" alt="Ex_13(2)"></p><h2 id="6-Think"><a href="#6-Think" class="headerlink" title="6. Think"></a>6. Think</h2><p>Are there any prominent topographical features in power or in phase?     - Yes.</p><p>Do these differ for different frequencies?     - Yes.</p><p>Do power and phase have similar topographical distributions?    - It doesn’t look very similar.</p><p>Is there any reason to suspect that they might have similar or different topographies?     </p><blockquote><p><strong>(From ChatGPT for reference, GPT is not provided with corresponding pictures)</strong></p><p>When analyzing EEG data, particularly through time-frequency decomposition, you might observe various topographical features in both power and phase distributions across the scalp. These features can provide insights into underlying neural processes. Let’s break down each question:</p><p>(1) <strong>Are there any prominent topographical features in power or in phase?</strong></p><ul><li><strong>Power Topography</strong>: Power topography represents the distribution of signal power across the scalp. Prominent features in power maps could indicate areas of strong neural activity, which might correspond to specific cognitive or sensory processes. For example, increased power in the occipital regions might be related to visual processing.</li><li><strong>Phase Topography</strong>: Phase topography shows the distribution of phase angles across the scalp. Prominent features in phase topography could indicate phase synchronization between regions, which might be associated with communication between different brain areas.</li></ul><p>(2) <strong>Do these differ for different frequencies?</strong></p><ul><li>Yes, topographical features often differ for different frequencies. Different frequencies in EEG are associated with different types of neural activity (e.g., alpha waves in the 8-12 Hz range are often related to relaxation and closed eyes, while beta waves in the 13-30 Hz range are associated with active thinking or focus). The power and phase topographies can change significantly across different frequency bands, reflecting the different functional roles of these frequencies.</li></ul><p>(3) <strong>Do power and phase have similar topographical distributions?</strong></p><ul><li>Power and phase distributions are often not identical. Power topography might highlight regions with strong amplitude, while phase topography might emphasize regions where the timing of oscillatory activity is synchronized across electrodes. However, there can be similarities, especially in regions where strong power is accompanied by consistent phase alignment (e.g., in tasks requiring coordinated neural activity across brain regions).</li></ul><p>(4) <strong>Is there any reason to suspect that they might have similar or different topographies?</strong></p><ul><li><strong>Similar Topographies</strong>: Power and phase could have similar topographies in cases where high power is associated with phase-locked activity across trials or regions. For instance, during sensory processing, a stimulus might evoke both strong power and phase synchronization in relevant brain areas.</li><li><strong>Different Topographies</strong>: Conversely, power and phase might differ in their topographical distributions due to different underlying mechanisms. High power might occur in one region without strong phase alignment, especially if the neural activity is more localized or independent across trials. Additionally, phase synchronization can occur without strong power, especially in low-amplitude oscillations that are critical for certain cognitive processes.</li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h3><ul><li><strong>Power and phase topographies can both reveal important aspects of neural activity, but they often provide different insights</strong>. Power maps tend to show where neural activity is strong, while phase maps can indicate where different regions are temporally synchronized. The topographies of power and phase may differ depending on the frequency of interest and the specific neural processes involved. Understanding these distributions and their relationships is key to interpreting EEG data in the context of neural dynamics.</li></ul></blockquote><h2 id="7-Create-a-circular-colormap"><a href="#7-Create-a-circular-colormap" class="headerlink" title="7.  Create a circular colormap"></a>7.  Create a circular colormap</h2><p>Because phase values are circular ( – <em>π</em> and + <em>π</em> are identical), most color maps are inappropriate because they suggest that – <em>π</em> and + <em>π</em> are very different values (represented, e.g., by blue and red colors). Create a circular colormap that can be used for phase values. You can do this by setting the red, green, and/or blue values to be a cosine function rather than a linear function. Recreate the phase topographical maps. Do they look any different with the new color maps? </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自定义用于相位的环形colormap，使得-pi和pi对应的颜色相同</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ax6 = subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">nColors = <span class="number">128</span>; <span class="comment">% 调色板的颜色数量</span></span><br><span class="line">cmap = hsv(nColors); <span class="comment">% 使用 HSV colormap</span></span><br><span class="line">cmap = cmap([<span class="number">1</span>:<span class="keyword">end</span> <span class="number">1</span>], :); <span class="comment">% 将第一个颜色重复，使得 -pi 和 pi 一致</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加环形 colorbar</span></span><br><span class="line">cb = colorbar;</span><br><span class="line">set(cb, <span class="string">&#x27;Ticks&#x27;</span>, [-<span class="built_in">pi</span>, -<span class="built_in">pi</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="built_in">pi</span>/<span class="number">2</span>, <span class="built_in">pi</span>], <span class="string">&#x27;TickLabels&#x27;</span>, &#123;<span class="string">&#x27;-\pi&#x27;</span>, <span class="string">&#x27;-\pi/2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;\pi/2&#x27;</span>, <span class="string">&#x27;\pi&#x27;</span>&#125;);</span><br><span class="line">clim([-<span class="built_in">pi</span> <span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">axis off</span><br><span class="line">cb.Position(<span class="number">1</span>) = ax6.Position(<span class="number">1</span>);</span><br><span class="line">cb.Position(<span class="number">2</span>) = ax6.Position(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/23/8dGJkcTSfWMRO1A.png" alt="Ex_13(3)"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part 3 Frequency and Time-Frequency Domains Analyses | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd8k1.html"/>
      <url>/post/c9dcd8k1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-10-amp-11"><a href="#Chapter-10-amp-11" class="headerlink" title="Chapter 10&amp;11"></a>Chapter 10&amp;11</h1><p>推荐3b1b的一段关于<strong>卷积</strong>、<strong>离散傅里叶变换（DFT）</strong>和快速傅里叶变换（FFT）的视频</p><p><a href="https://www.bilibili.com/video/BV1Vd4y1e7pj/?t=0.8&amp;vd_source=e7f03c857e620b80dcde0db3e7f51d26">【官方双语】那么……什么是卷积？</a></p><h2 id="Figure-11-5"><a href="#Figure-11-5" class="headerlink" title="Figure 11.5"></a>Figure 11.5</h2><p>对于书中所提供的图11.5对应代码的一些细节注释</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Figure 11.5</span></span><br><span class="line"></span><br><span class="line">N       = <span class="number">10</span>;         <span class="comment">% length of sequence  长度为10的向量</span></span><br><span class="line">data    = <span class="built_in">randn</span>(<span class="number">1</span>,N); <span class="comment">% random numbers</span></span><br><span class="line">srate   = <span class="number">200</span>;        <span class="comment">% sampling rate in Hz 采样率200Hz</span></span><br><span class="line">nyquist = srate/<span class="number">2</span>;    <span class="comment">% Nyquist frequency -- the highest frequency you can measure in the data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize Fourier output matrix</span></span><br><span class="line">fourier = <span class="built_in">zeros</span>(<span class="built_in">size</span>(data)); </span><br><span class="line"></span><br><span class="line"><span class="comment">% These are the actual frequencies in Hz that will be returned by the</span></span><br><span class="line"><span class="comment">% Fourier transform. The number of unique frequencies we can measure is</span></span><br><span class="line"><span class="comment">% exactly 1/2 of the number of data points in the time series (plus DC). </span></span><br><span class="line"><span class="comment">% 一个长度为 N 的信号需要 N 个正交基（frequency）才能完全表示</span></span><br><span class="line"><span class="comment">% 但在这里只保留了N/2+1个frequencies，是因为对于实数值信号，负频率与正频率对应的幅值、相位信息是对称的</span></span><br><span class="line"><span class="comment">% 所以舍去了N/2个负频率</span></span><br><span class="line">frequencies = <span class="built_in">linspace</span>(<span class="number">0</span>,nyquist,N/<span class="number">2</span>+<span class="number">1</span>);   <span class="comment">% 生成的频率从 0 到 100 Hz，共有 N/2 + 1 个点，间隔为srate/N</span></span><br><span class="line">time = ((<span class="number">1</span>:N)<span class="number">-1</span>)/N;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Fourier transform is dot-product between sine wave and data at each frequency</span></span><br><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:N      </span><br><span class="line">    <span class="comment">% fi（归一化频率，index，无单位）有N个取值，与frequencies（物理频率，Hz）为线性映射关系</span></span><br><span class="line">    <span class="comment">% 所以使用这两种频率DFT后的结果一致（幅值、相位相等）</span></span><br><span class="line">    sine_wave   = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time);</span><br><span class="line">    fourier(fi) = sum(sine_wave.*data);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fourier=fourier/N;  <span class="comment">% 归一化，使得振幅具有实际意义，并保证能量的一致性</span></span><br></pre></td></tr></table></figure><h2 id="11-7-The-Fast-Fourier-Transform-FFT"><a href="#11-7-The-Fast-Fourier-Transform-FFT" class="headerlink" title="11.7 The Fast Fourier Transform | FFT"></a>11.7 The Fast Fourier Transform | FFT</h2><p>如何将 fft 函数的输出与实际的频率和幅值对应起来：</p><ul><li>采样率：$F_s$     采样点数：$N$</li><li>FFT后向量中某点索引：$n$<ul><li>该点频率：$f_n=(n-1)\cdot F_s/N$ </li><li>该点幅值：$abs(Result_{FFT})/(N/2)$</li></ul></li></ul><hr><h1 id="Chapter-12"><a href="#Chapter-12" class="headerlink" title="Chapter 12"></a>Chapter 12</h1><h2 id="12-2-How-to-Wake-Wavelets-小波的创造"><a href="#12-2-How-to-Wake-Wavelets-小波的创造" class="headerlink" title="12.2 How to Wake Wavelets | 小波的创造"></a>12.2 How to Wake Wavelets | 小波的创造</h2><p>不同于使用傅里叶变换进行的分析，使用小波变换时小波的频率和数目可以自行选择。一组具有相同性质但频率不同的<strong>小波</strong>叫作<strong>小波族</strong>，构造一组小波族有如下限制：</p><ol><li><strong>不能用比你划分的时间小段（epochs）更慢的频率。</strong>例如，你有一段1s长的数据，那么你不能分析低于1Hz的活动，应该让这1s中包含多个活动周期，建议使用4Hz或更快的小波。</li><li><p><strong>小波的频率不能高于奈奎斯特频率（采样率的一半）</strong></p></li><li><p>选择相近的频率所获得的结果会很相近（例如15.0Hz和14.9Hz），且越密集的频率所需要的计算时间会越长，<strong>一般而言，在3Hz到60Hz之间选择15到30个频率就够了</strong>。</p></li></ol><hr><h1 id="Chapter-13-Complex-Morlet-Wavelets-cmw"><a href="#Chapter-13-Complex-Morlet-Wavelets-cmw" class="headerlink" title="Chapter 13 Complex Morlet Wavelets (cmw)"></a>Chapter 13 Complex Morlet Wavelets (cmw)</h1><h2 id="1-Create-complex-sine-wave"><a href="#1-Create-complex-sine-wave" class="headerlink" title="1. Create complex sine wave"></a>1. Create complex sine wave</h2><p>复数域的Wavelet函数也是由sine函数和Gaussian相乘得来，只是所使用的sine函数是在复数域表示的（<script type="math/tex">e^{2\pi ft}</script>）</p><ul><li><script type="math/tex">cmw=Ae^{-t^2/2s^2}e^{2\pi ft}</script> (the x-axis offset for Gaussian are omitted)</li><li><script type="math/tex; mode=display">A=\frac{1}{(s\sqrt{\pi})^{1/2}}</script></li></ul><h2 id="2-The-Result-of-cmw"><a href="#2-The-Result-of-cmw" class="headerlink" title="2. The Result of cmw |"></a>2. The Result of cmw |</h2><p>复数wavelet与信号点积的结果有三个维度：<strong>时间、实部、虚部</strong>。将该结果绘制在复平面上，其在实轴、虚轴上的投影分别对应于wavelet的实部、虚部与信号的点积结果。</p><p>点积结果在复平面上所对应向量的长度反映了信号（signal）和核（kernal）的相似（重叠）程度，而且该长度与二者间的相位关系无关。相位关系由向量与实轴的夹角表示。</p><ul><li><strong>在实轴上的投影：带通滤波信号</strong>，其正负符号反映<strong>相位</strong>关系</li><li><strong>向量长度（振幅）：</strong>反映wavelet与signal的<strong>相似性</strong>或<strong>重叠度</strong>，其<strong>平方称为功率</strong><ul><li><code>abs(X).^2;</code> or <code>X.*conj(X);</code> (乘以共轭)</li></ul></li><li><strong>与实轴夹角：</strong>反映了在wavelet<strong>中心时间点</strong>（即分析时段的中间时刻）和wavelet的<strong>主频率</strong>（即小波的主要振荡频率）下，信号的<strong>相位</strong>信息。<ul><li><code>angle(X);</code> </li></ul></li><li>上述提到的功率和相位值只能作为估计值，因为它们会受到邻近时间点活动的影响。</li></ul><p><img src="https://s2.loli.net/2024/08/19/YXlf9aM2iv6UByK.png" alt="image-20240819201632545" style="zoom:67%;" /></p><h2 id="3-Parameters-of-Wavelets"><a href="#3-Parameters-of-Wavelets" class="headerlink" title="3. Parameters of Wavelets"></a>3. Parameters of Wavelets</h2><ul><li><p><strong>最低频率</strong></p><ul><li>如果关注alpha-band activity，大概在5或6Hz即可</li><li>划分的时间区段（epoch）尽可能包含多个周期（如果epoch长1s，则不要低于4Hz）</li></ul></li><li><p><strong>最高频率</strong></p><ul><li>不能超过<strong>奈奎斯特频率（采样率的一半）</strong></li><li>单个wavelet周期尽可能包含更多的信号数据点，可以提高信噪比</li><li>没有特别的期望的话，可能选择4Hz到6Hz的频率范围</li></ul></li><li><p><strong>频率数目</strong></p><ul><li>一般取20-30个频率足够覆盖较宽的频率范围。条件允许的情况下当然是越多越好，但是相近的频率不一定能提供更多信息。</li></ul></li><li><p><strong>频率分布间隔</strong></p><ul><li><p><strong>线性分布</strong></p><ul><li><p>突出频谱的高频段</p></li><li><p>可以直接使用 <code>imagesc(EEG.times,frequencies,tf_data);</code> 绘图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">imagesc(EEG.times,frex,eegpower)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>],<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1000</span>],<span class="string">&#x27;ydir&#x27;</span>,<span class="string">&#x27;norm&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;WRONG Y-AXIS LABELS!!!!&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Frequency (Hz)&#x27;</span>), xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>对数分布（推荐）</strong>：</p><ul><li><p>4-8Hz（theta）和30-80Hz（lower gamma）在y轴上占据的宽度会比较接近</p></li><li><p>突出频谱的低频段</p></li><li><p>使用 <code>imagesc(EEG.times,[],tf_data)</code> 绘图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">imagesc(EEG.times,[],eegpower)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>],<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1000</span>],<span class="string">&#x27;ydir&#x27;</span>,<span class="string">&#x27;norm&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;ytick&#x27;</span>,<span class="number">1</span>:<span class="number">6</span>:num_frex,<span class="string">&#x27;yticklabel&#x27;</span>,<span class="built_in">round</span>(<span class="built_in">logspace</span>(<span class="built_in">log10</span>(min_freq),<span class="built_in">log10</span>(max_freq),<span class="number">6</span>)*<span class="number">10</span>)/<span class="number">10</span>)<span class="comment">% important!</span></span><br><span class="line">title(<span class="string">&#x27;CORRECT Y-AXIS LABELS!!!!&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>wavelets 的长度</strong></p><ul><li>要足够长，使得<strong>两侧能衰减到0</strong>（接近0）</li><li><strong>没有长度限制</strong>，如果 -1s ~ +1s 不够，就设置成 -2s ~ +2s，不同的频率长度也不一定要相同</li><li>wavelet 的图像要<strong>设置在时间轴中央</strong>（关于中间时刻对称），最简单的方法是将时间范围设置成  -x seconds to +x seconds</li><li>wavelet 的<strong>采样率要和 EEG.data 一致</strong></li></ul></li><li><p><strong>Gaussian函数要包含多少个周期</strong></p><ul><li>“包含的周期数目”指的是Gaussian函数标准差公式<script type="math/tex">s=\frac{n}{2\pi f}</script>中的<strong><script type="math/tex">n</script></strong></li><li>包含周期数越多，<strong>频率精度</strong>越高，<strong>时间精度</strong>越低</li><li>包含周期的数目也可随频率改变</li><li>应至少包含3个周期，至多包含14个周期</li><li>在wavelet的非零段，需要保证数据（进行卷积的信号片段）的<strong>平稳性</strong>（均值、方差等统计特性保持稳定）</li></ul></li></ul><h2 id="4-相邻频率对小波卷积的贡献程度"><a href="#4-相邻频率对小波卷积的贡献程度" class="headerlink" title="4. 相邻频率对小波卷积的贡献程度"></a>4. 相邻频率对小波卷积的贡献程度</h2><ul><li><p><strong>Full width at half-maximum (FWHM)</strong></p><ul><li><p>指频谱上功率在峰值的左右两侧分别为<strong>50%</strong>时的频率宽度：<strong><script type="math/tex">FWHM=2\sqrt{2\ln 2}\sigma</script></strong>，其中<script type="math/tex">\sigma</script>是频率响应的<strong>标准差</strong></p><ul><li>首先标准化功率谱，使得峰值为1，两端衰减至0</li><li>找到功率值为0.5的点对应的频率，即可计算出FWHM</li></ul><p><img src="https://s2.loli.net/2024/08/22/IGb3NMwy4gUQfjA.png" alt="image-20240822161841368"></p></li></ul></li></ul><h2 id="5-卷积的Matlab计算技巧"><a href="#5-卷积的Matlab计算技巧" class="headerlink" title="5. 卷积的Matlab计算技巧"></a>5. 卷积的Matlab计算技巧</h2><ul><li>FFT的数据点数为<strong><script type="math/tex">2^n</script></strong>时，计算速度更快。可以通过适当的<strong>补零</strong>来实现</li><li>不需要对每个trial进行一次卷积，可以将所有trial连接成一个长时间序列，再对整个时间序列执行一次卷积</li></ul><hr><h1 id="Chapter-14"><a href="#Chapter-14" class="headerlink" title="Chapter 14"></a>Chapter 14</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part 2 Exercises | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd3o1.html"/>
      <url>/post/c9dcd3o1.html</url>
      
        <content type="html"><![CDATA[<h1 id="9-8-Exercise"><a href="#9-8-Exercise" class="headerlink" title="9.8 Exercise"></a>9.8 Exercise</h1><h2 id="9-8-1"><a href="#9-8-1" class="headerlink" title="9.8.1"></a>9.8.1</h2><p>Compute the ERP at each electrode. Select five time points at which to show topographical plots (e.g., 0 to 400 ms in 100-ms steps). In one figure, make a series of topographical plots  at these time points. To increase the signal-to-noise ratio, make each plot show the average of activity from 20 ms before until 20 ms after each time point. For example, the topographical  plot from 200 ms should show average activity from 180 ms until 220 ms. Indicate the center  time point in a title on each subplot. </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex_09 (1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% load EEG data</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute the ERP at each electrode</span></span><br><span class="line">ERP = <span class="built_in">zeros</span>(EEG.nbchan, EEG.pnts);</span><br><span class="line"><span class="keyword">for</span> electrode_i = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    ERP(electrode_i,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(electrode_i,:,:),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% select 5 time points (0 to 400ms in 100-ms steps) </span></span><br><span class="line"><span class="comment">% and plot topographical Maps</span></span><br><span class="line">dt = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="keyword">for</span> timei=<span class="number">0</span>:<span class="number">100</span>:<span class="number">400</span></span><br><span class="line">    <span class="comment">% Each point show the average of activity from 20ms before until 20ms</span></span><br><span class="line">    <span class="comment">% after each point</span></span><br><span class="line">    TimeSpani = <span class="built_in">find</span>(EEG.times &gt;= timei-dt &amp; EEG.times &lt;= timei+dt);</span><br><span class="line">    MeanEEG = <span class="built_in">mean</span>(EEG.data(:,TimeSpani,:),<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% topographical plots</span></span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">2</span>,timei/<span class="number">100</span>+<span class="number">1</span>);</span><br><span class="line">    c = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(MeanEEG(:,:,:),<span class="number">3</span>));</span><br><span class="line">    topoplot(double(c),EEG.chanlocs,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="number">-10</span>,<span class="number">10</span>]);   <span class="comment">% 统一各subplot的colorbar</span></span><br><span class="line">    title([<span class="string">&#x27;ERP around &#x27;</span> num2str(timei) <span class="string">&#x27;ms&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    colormap jet</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot colorbar</span></span><br><span class="line">ax6 = subplot(<span class="number">326</span>);</span><br><span class="line">axis off</span><br><span class="line">cb = colorbar;</span><br><span class="line">set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="number">-10</span>,<span class="number">10</span>]);</span><br><span class="line">cb.Position(<span class="number">1</span>) = ax6.Position(<span class="number">1</span>);</span><br><span class="line">cb.Position(<span class="number">2</span>) = ax6.Position(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/hdsRq2Gbtv6QfNl.png" alt="Ex09(1)" style="zoom:67%;" /></p><h2 id="9-8-2"><a href="#9-8-2" class="headerlink" title="9.8.2"></a>9.8.2</h2><p>Loop through each electrode and find the peak time of the ERP between 100 and 400 ms. Store these peak times in a separate variable and then make a topographical plot of the peak times (that is, the topographical map will illustrate times in milliseconds, not activity at peak times). Include a color bar in the figure and make sure to show times in milliseconds from time 0 (not, for example, time in milliseconds since 100 ms or indices instead of milliseconds). What areas of the scalp show the earliest and the latest peak responses to the stimulus within this window?</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex_09 (2)</span></span><br><span class="line"></span><br><span class="line">PeakTimes = <span class="built_in">zeros</span>(EEG.nbchan,<span class="number">1</span>);      <span class="comment">% the peak time of the ERP between 100 and 400ms (in ms)</span></span><br><span class="line">PeakTimedx = <span class="built_in">zeros</span>(EEG.nbchan,<span class="number">1</span>);      <span class="comment">% peak time index of each channel</span></span><br><span class="line">Timedx = <span class="built_in">find</span>(EEG.times &gt;= <span class="number">100</span> &amp; EEG.times &lt;= <span class="number">400</span>);     <span class="comment">% index of 100~400ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% find ERP peak times</span></span><br><span class="line"><span class="keyword">for</span> electrode_i = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    PeakTimedx(electrode_i) = Timedx(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> timespani = <span class="number">1</span>:<span class="built_in">length</span>(Timedx)</span><br><span class="line">        <span class="keyword">if</span> ERP(electrode_i,Timedx(timespani)) &gt; ERP(electrode_i,PeakTimedx(electrode_i))</span><br><span class="line">            PeakTimedx(electrode_i) = Timedx(timespani);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    PeakTimes(electrode_i) = EEG.times(PeakTimedx(electrode_i));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot a topographical plot of peak times</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">topoplot(PeakTimes,EEG.chanlocs,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">colormap jet</span><br><span class="line">set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="built_in">min</span>(PeakTimes) <span class="built_in">max</span>(PeakTimes)]);</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;ERP peak times between 100 and 400 ms&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/16/zgitBZ9TsY3bc6K.png" alt="EX09(2)" style="zoom:67%;" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part 1 Exercises | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcc4d9.html"/>
      <url>/post/c9dcc4d9.html</url>
      
        <content type="html"><![CDATA[<h1 id="4-7-Exercise"><a href="#4-7-Exercise" class="headerlink" title="4.7 Exercise"></a>4.7 Exercise</h1><h2 id="4-7-1-Exercises-for-Script-A"><a href="#4-7-1-Exercises-for-Script-A" class="headerlink" title="4.7.1 Exercises for Script A"></a><strong>4.7.1 Exercises for Script A</strong></h2><ol><li><p>Create a 4 × 8 matrix of randomly generated numbers. </p></li><li><p>Loop through all rows and columns, and test whether each element is greater than 0.5. </p></li><li><p>Report the results of the test along with the value of the matrix element and its row-column position. For example, your Matlab script should print The 3rd row and 8th column has a value of 0.42345 and is not bigger than 0.5 . </p></li><li><p>Make sure to add exceptions to print out 1st, 2nd, and 3rd, instead of 1th, 2th, and 3th. </p></li><li><p>Put this code into a separate function that you can call from the command line with two inputs, corresponding to the number of rows and the number of columns of the matrix. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.1 Exercises for Script A</span></span><br><span class="line">matA = GreaterThanPointFive(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成一个 rowx × colx 的0~1随机数矩阵，并输出各行各列上的元素及其与0.5的大小关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matx</span> = <span class="title">GreaterThanPointFive</span><span class="params">(rowx, colx)</span></span></span><br><span class="line">    matx = <span class="built_in">rand</span>(rowx,colx);</span><br><span class="line">    NoString = [<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;st&#x27;</span>;<span class="string">&#x27;nd&#x27;</span>;<span class="string">&#x27;rd&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> rowi = <span class="number">1</span>:rowx</span><br><span class="line">        <span class="keyword">for</span> coli = <span class="number">1</span>:colx</span><br><span class="line">            <span class="keyword">if</span> matx(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is not bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="4-7-2-Exercises-for-Script-B"><a href="#4-7-2-Exercises-for-Script-B" class="headerlink" title="4.7.2 Exercises for Script B"></a><strong>4.7.2 Exercises for Script B</strong></h2><ol><li><p>Import and plot the picture of Amsterdam that comes with the online Matlab code. </p></li><li><p>On top of the picture, plot a thick red line from “ Nieuwmarkt ” (near the center of the picture) to “ Station Amsterdam Centraal ” (near the top of the picture). </p></li><li><p>Plot a magenta star over the Waterlooplein metro station (a bit South of Nieuwmarkt). </p></li><li><p>Find the maximum value on each color dimension (red, green, or blue) and plot a circle using that color. There may be more than one pixel with a maximum value; if so, pick one pixel at random. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.2 Exercises for Script B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 6. Import and plot picture</span></span><br><span class="line">amsterdamImg = imread(<span class="string">&quot;amsterdam.bmp&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">imagesc(amsterdamImg);</span><br><span class="line">axis image</span><br><span class="line">axis on</span><br><span class="line">grid on</span><br><span class="line">grid minor</span><br><span class="line"></span><br><span class="line"><span class="comment">% 7. plot a thick red line</span></span><br><span class="line">line([<span class="number">367</span>,<span class="number">395</span>],[<span class="number">325</span>,<span class="number">75</span>],<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 8. plot a magenta star</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">375</span>,<span class="number">490</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 9.find maximum value on each color dimension and plot a circle using it</span></span><br><span class="line"><span class="comment">% 分别提取RGB数值</span></span><br><span class="line">R = amsterdamImg(:,:,<span class="number">1</span>);</span><br><span class="line">G = amsterdamImg(:,:,<span class="number">2</span>);</span><br><span class="line">B = amsterdamImg(:,:,<span class="number">3</span>);</span><br><span class="line"><span class="comment">% 找到最大的RGB值</span></span><br><span class="line">R_max = <span class="built_in">max</span>(R);</span><br><span class="line">G_max = <span class="built_in">max</span>(G);</span><br><span class="line">B_max = <span class="built_in">max</span>(B);</span><br><span class="line"><span class="comment">% 找到最大值所在位置</span></span><br><span class="line">[R_maxRow, R_maxCol] = <span class="built_in">find</span>(R==R_max);</span><br><span class="line">[G_maxRow, G_maxCol] = <span class="built_in">find</span>(G==G_max);</span><br><span class="line">[B_maxRow, B_maxCol] = <span class="built_in">find</span>(B==B_max);</span><br><span class="line"><span class="comment">% 随机选择一个索引</span></span><br><span class="line">R_idx = randi(<span class="built_in">length</span>(R_maxRow));</span><br><span class="line">G_idx = randi(<span class="built_in">length</span>(G_maxRow));</span><br><span class="line">B_idx = randi(<span class="built_in">length</span>(B_maxRow));</span><br><span class="line"><span class="comment">% 获取坐标</span></span><br><span class="line">R_position = [R_maxRow(R_idx), R_maxCol(R_idx)];</span><br><span class="line">G_position = [G_maxCol(G_idx), G_maxCol(G_idx)];</span><br><span class="line">B_position = [B_maxCol(B_idx), B_maxCol(B_idx)];</span><br><span class="line"><span class="comment">% 在图像上最大值位置绘制圆圈</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(R_position(<span class="number">1</span>),R_position(<span class="number">2</span>),<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(G_position(<span class="number">1</span>),G_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(B_position(<span class="number">1</span>),B_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/14/iN765E42mOtMnhP.png" alt="image-20240814164819625" style="zoom:67%;" /></p><h2 id="4-7-3-Exercises-for-Script-C"><a href="#4-7-3-Exercises-for-Script-C" class="headerlink" title="4.7.3 Exercises for Script C"></a><strong>4.7.3 Exercises for Script C</strong></h2><ol><li><p>From the function you wrote for exercise 5, generate a 32 × 3 number matrix in which the three numbers in each row correspond to the row, column, and result of the test (1 for bigger than 0.5; 0 for smaller than 0.5). </p></li><li><p>Write this 32 × 3 matrix to a text file that contains this matrix along with appropriate variable labels in the first row. Make sure this file is tab-delimited and readable by a spreadsheet software such as Microsoft Excel or Open Office Calc. </p></li></ol><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 运行该代码前请先运行Exercise_04_A</span></span><br><span class="line"></span><br><span class="line">matC = NaN(<span class="number">32</span>,<span class="number">3</span>);   <span class="comment">% 第一、二列为matA的行、列坐标，第三列为该坐标上的元素是否大于0.5</span></span><br><span class="line">countRowi = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rowi = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> coli = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">2</span>)</span><br><span class="line">        matC(countRowi,<span class="number">1</span>) = rowi;</span><br><span class="line">        matC(countRowi,<span class="number">2</span>) = coli;</span><br><span class="line">        <span class="keyword">if</span> matA(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        countRowi = countRowi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 将matC写入txt文件</span></span><br><span class="line">fileC = fopen(<span class="string">&#x27;data_output_04C.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% variable labels</span></span><br><span class="line">variable_labels = &#123;<span class="string">&#x27;row&#x27;</span>;<span class="string">&#x27;column&#x27;</span>;<span class="string">&#x27;result&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">% 写入第一行变量名</span></span><br><span class="line"><span class="keyword">for</span> vari=<span class="number">1</span>:<span class="built_in">length</span>(variable_labels)</span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;%s\t&#x27;</span>,variable_labels&#123;vari&#125;);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 换行</span></span><br><span class="line">fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> datarowi=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> columni=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">2</span>)</span><br><span class="line">        fprintf(fileC,<span class="string">&#x27;%g\t&#x27;</span>,matC(datarowi,columni));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fclose(fileC);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part 2 Preprocessing and Time-Domain Analyses | Analyzing Neural Time Series Data</title>
      <link href="/post/c9dcd3d2.html"/>
      <url>/post/c9dcd3d2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-7-数据预处理"><a href="#Chapter-7-数据预处理" class="headerlink" title="Chapter 7 数据预处理"></a>Chapter 7 数据预处理</h1><h2 id="The-Balance-between-Signal-and-Noise-信号与噪声的取舍平衡"><a href="#The-Balance-between-Signal-and-Noise-信号与噪声的取舍平衡" class="headerlink" title="The Balance between Signal and Noise | 信号与噪声的取舍平衡"></a>The Balance between Signal and Noise | 信号与噪声的取舍平衡</h2><p>保留更多的信号通常也意味着保留更多的噪声。</p><p>某些数据是信号还是噪声取决于实验的目的。</p><hr><h2 id="Creating-Epochs"><a href="#Creating-Epochs" class="headerlink" title="Creating Epochs"></a>Creating Epochs</h2><p>提取epoch的过程可以认为是将一段完整的数据划分成不同的小段</p><h4 id="1-如何选择“time-0”的时刻"><a href="#1-如何选择“time-0”的时刻" class="headerlink" title="1. 如何选择“time=0”的时刻"></a>1. 如何选择“time=0”的时刻</h4><ul><li>对于大多数实验，选择刺激开始的时刻作为time=0</li><li>对于其他情况，如有多个刺激时，可选择第一个刺激或最关键的刺激开始的时刻作为time=0</li><li>time-lock（time=0时刻的选择）是可以根据需要调节变化的</li></ul><h4 id="2-time-0前后需要包含多长时间"><a href="#2-time-0前后需要包含多长时间" class="headerlink" title="2. time=0前后需要包含多长时间"></a>2. time=0前后需要包含多长时间</h4><p>对于<strong>ERPs</strong>分析，划分的小段只需要包含你<strong>想要分析的时间段加上baseline</strong>，例如相对于0时刻的-200ms到800ms。</p><p>对于<strong>时频分析</strong>，需要划分<strong>更长</strong>的时间段，以避免<strong>边缘伪影（edge artifacts）</strong>，即需要<strong>预留足够长的缓冲区，使边缘伪影消退</strong>。此外，提取的频带越小，需要预留的缓冲区也应该越长。在时频功率谱中，边缘伪影很容易识别，因此可以先试分析一组数据再确定需要预留的缓冲区长度。通常情况下，将缓冲区长度设置为所分析的最低频率所对应的三个周期就足够了（例如，对2Hz的频率，设置缓冲区为1500ms）。</p><p>如果划分的epoch不够长，可以使用“reflection”的方法，即将这一段数据关于开始和结尾时刻首尾对称一下，再拼接到数据前和数据后，这样就可以得到三倍长的epoch。</p><p><img src="https://s2.loli.net/2024/08/12/pR8OtBZfriq4GJx.png" alt="image-20240812153014767"></p><hr><h2 id="Matching-Trial-Count-across-Conditions-Trial数量的设置与平衡"><a href="#Matching-Trial-Count-across-Conditions-Trial数量的设置与平衡" class="headerlink" title="Matching Trial Count across Conditions | Trial数量的设置与平衡"></a>Matching Trial Count across Conditions | Trial数量的设置与平衡</h2><h4 id="1-不同的实验条件尽量设置相同的trial数："><a href="#1-不同的实验条件尽量设置相同的trial数：" class="headerlink" title="1. 不同的实验条件尽量设置相同的trial数："></a><strong>1. 不同的实验条件尽量设置相同的trial数：</strong></h4><p>理想情况下，所有条件（例如实验设计中的不同实验条件或组别）应该有相同数量的试验。这样可以确保分析结果的公平性和可比性。</p><h4 id="2-trial数量对不同分析的影响："><a href="#2-trial数量对不同分析的影响：" class="headerlink" title="2. trial数量对不同分析的影响："></a><strong>2. trial数量对不同分析的影响</strong>：</h4><ul><li><strong>基于相位的分析</strong>：相位分析对试验数量特别敏感。如果trial数量较少，结果中会出现正偏差（positive bias），即trial数量少的实验条件可能显示出更大的结果。这是因为相位分析对于小样本量更容易受到随机波动的影响，导致条件间结果的偏差。</li><li><strong>基于功率的分析</strong>：功率分析也可能出现一些正偏差。因为功率值通常是正值，数据中的噪声更倾向于增加功率值，所以较少的试验数量可能导致功率结果偏高。</li><li>xxxxxxxxxx % 运行该代码前请先运行Exercise_04_A​matC = NaN(32,3);   % 第一、二列为matA的行、列坐标，第三列为该坐标上的元素是否大于0.5countRowi = 1;​for rowi = 1:size(matA,1)    for coli = 1:size(matA,2)        matC(countRowi,1) = rowi;        matC(countRowi,2) = coli;        if matA(rowi,coli) &gt; 0.5            matC(countRowi,3) = 1;        else            matC(countRowi,3) = 0;        end        countRowi = countRowi + 1;    endend​% 将matC写入txt文件fileC = fopen(‘data_output_04C.txt’,’w’);​% variable labelsvariable_labels = {‘row’;’column’;’result’};% 写入第一行变量名for vari=1:length(variable_labels)    fprintf(fileC,’%s\t’,variable_labels{vari});end​% 换行fprintf(fileC,’\n’);​for datarowi=1:size(matC,1)    for columni=1:size(matC,2)        fprintf(fileC,’%g\t’,matC(datarowi,columni));    end    fprintf(fileC,’\n’);end​fclose(fileC);​matlab</li></ul><h4 id="3-应对低trial数量的方法："><a href="#3-应对低trial数量的方法：" class="headerlink" title="3. 应对低trial数量的方法："></a><strong>3. 应对低trial数量的方法</strong>：</h4><p>对于ERP分析，如果试验数量较少，与其依赖峰值时间（peak times）的分析，不如取一段时间范围内的平均幅值（mean amplitude）。这种方法对噪声更为稳健，不容易受到个别异常值的影响。</p><h4 id="4-应对不同实验条件的trial数量不一致的方法："><a href="#4-应对不同实验条件的trial数量不一致的方法：" class="headerlink" title="4. 应对不同实验条件的trial数量不一致的方法："></a><strong>4. 应对不同实验条件的trial数量不一致的方法</strong>：</h4><p>如果出现不同的实验条件下的trial数目不一致，假设最小的trial数为N，那么可以通过以下方法来平衡trial数：</p><ul><li>（不建议采用）直接选前N个trial</li><li>随机选N个trial</li><li>根据一些相关的行为或实验变量，如反应时间等，有目的地选N个trial</li></ul><hr><h2 id="Trial-Rejection"><a href="#Trial-Rejection" class="headerlink" title="Trial Rejection"></a>Trial Rejection</h2><hr><h1 id="Chapter-9-Overview-of-Time-Domain-EEG-Analyses"><a href="#Chapter-9-Overview-of-Time-Domain-EEG-Analyses" class="headerlink" title="Chapter 9 Overview of Time-Domain EEG Analyses"></a>Chapter 9 Overview of Time-Domain EEG Analyses</h1><h2 id="Event-Related-Potentials-ERPs"><a href="#Event-Related-Potentials-ERPs" class="headerlink" title="Event-Related Potentials (ERPs)"></a>Event-Related Potentials (ERPs)</h2><p>To create ERPs, simply align the time-domain EEG to the time=0 event (this was probably already done during preprocessing) and <strong>average across trials</strong> at each time point.</p><ul><li>指定 time points</li><li>trial average</li></ul><hr><h2 id="Butterfly-Plots"><a href="#Butterfly-Plots" class="headerlink" title="Butterfly Plots"></a>Butterfly Plots</h2><p>A butterfly ploy shows <strong>the ERP from all electrodes</strong> overlaid in the same figure.</p><hr><h2 id="Global-Field-Power-Topographical-Variance-Plots"><a href="#Global-Field-Power-Topographical-Variance-Plots" class="headerlink" title="Global Field Power / Topographical Variance Plots"></a>Global Field Power / Topographical Variance Plots</h2><p>The global field power is <strong>the standard deviation</strong> of activity over <strong>all electrodes</strong>.</p><hr><h2 id="The-Flicker-Effect"><a href="#The-Flicker-Effect" class="headerlink" title="The Flicker Effect"></a>The Flicker Effect</h2><p>The flicker effect in EEG research refers to entrainment of brain activity to a rhythmic extrinsic driving factor. This effect is also referred to as steady-state evoked potential, frequency tagging, SSVEP (steady-state visual evoked potential), SSAEP (auditory evoked potential), or something similar. </p><p>The flicker effect is arguably an underutilized tool in cognitive electrophysiology. The main benefit of the flicker effect is that it allows you to <strong>“ tag ” the processing of a specific stimulus</strong>.</p><p><strong>(from ChatGPT)</strong></p><p>假设你正在进行一项视觉注意力的研究，目的是研究大脑如何同时处理多个视觉刺激。你在屏幕上呈现两个物体：一个物体以12 Hz的频率闪烁（即每秒闪烁12次），另一个物体以15 Hz的频率闪烁。你让参与者专注于两个物体之一，然后使用EEG记录他们的大脑活动。</p><p>在这种情况下，闪烁效应会导致大脑中处理视觉信息的区域（通常是视觉皮层）出现与这两个频率相对应的节律性活动。12 Hz的物体会在大脑中产生12 Hz的节律性活动，15 Hz的物体会产生15 Hz的节律性活动。通过分析EEG数据中的频率成分，你可以识别出大脑中对应这两个不同频率的活动区域。</p><p>即使EEG无法像功能性磁共振成像（fMRI）那样精确地显示大脑中具体的活动区域，你仍然可以通过这些频率标记来“分离”出大脑中对12 Hz和15 Hz刺激分别作出反应的神经元群体。换句话说，虽然EEG的空间分辨率较低，但通过闪烁效应，你可以“假设”出对不同刺激反应的特定神经区域。</p><p><strong>具体的例子说明</strong>：</p><ul><li><p><strong>12 Hz闪烁的物体</strong>：如果参与者主要关注这个物体，你会看到EEG数据中12 Hz频率的功率增加，这表明视觉皮层中的某个区域在处理这个物体。</p></li><li><p><strong>15 Hz闪烁的物体</strong>：如果参与者关注这个物体，EEG数据中15 Hz频率的功率会增加，显示另一个区域在处理这个物体。</p></li></ul><p>通过这种方法，即使两个物体在大脑中产生的活动区域相距较近，由于频率不同，你依然能够区分开来。这就相当于“模拟”出了一种高空间分辨率，使得你可以推断大脑中不同区域对不同刺激的反应。</p><hr><h2 id="Topographical-Maps"><a href="#Topographical-Maps" class="headerlink" title="Topographical Maps"></a>Topographical Maps</h2><p>Creating a topographical map is conceptually similar to interpolating an electrode, except that instead of estimating the activity at one point in space corresponding to a missing electrode, activity is estimated at many point in space between electrodes.</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">topoplot()</span><br></pre></td></tr></table></figure><hr><h2 id="Microstates"><a href="#Microstates" class="headerlink" title="Microstates"></a>Microstates</h2><p>In EEG as well as ERP map series, for brief, subsecond time periods, map landscapes typically remain quasi-stable, then change very quickly into different landscapes.</p><p>Durations tend to be around the <strong>alpha range (70-130 ms)</strong>, and topographical distributions tend to fit into <strong>four or five distinct patterns</strong>.</p><hr><h2 id="ERP-Images"><a href="#ERP-Images" class="headerlink" title="ERP Images"></a>ERP Images</h2><p>An ERP image is a 2-D representation of the EEG data from <strong>a single electrode</strong>. Rather than all trials averaged together to form an ERP, the <strong>single-trial</strong> EEG traces are stacked vertically and then color coded to show changes in amplitude as changes in color. </p>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part 1 Introduction | Analyzing Neural Time Series Data</title>
      <link href="/post/c9der4d1.html"/>
      <url>/post/c9der4d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-D-topographical-locations-of-EEG-electrodes"><a href="#2-D-topographical-locations-of-EEG-electrodes" class="headerlink" title="2-D topographical locations of EEG electrodes"></a>2-D topographical locations of EEG electrodes</h2><p><img src="https://s2.loli.net/2024/08/14/A4dNGTsBf8xHj5t.png" alt="image-20240814152033522" style="zoom:60%;" /> </p><hr><h2 id="Brain-rhythm-frequency-bands"><a href="#Brain-rhythm-frequency-bands" class="headerlink" title="Brain rhythm frequency bands"></a>Brain rhythm frequency bands</h2><blockquote><p>delta (2-4 HZ)</p><p>theta (4-8 Hz)</p><p>alpha (8-12 Hz)</p><p>beta (15-30 Hz)</p><p>lower gamma (30-80 Hz)</p><p>upper gamma (80-150 Hz)</p><p>subdelta and omega (up to 600 HZ)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Analyzing Neural Time Series Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL之哈希表</title>
      <link href="/post/751f48bb.html"/>
      <url>/post/751f48bb.html</url>
      
        <content type="html"><![CDATA[<p>C++ STL中，哈希表对应的容器是unordered_map（since C++ 11）。</p><p>STL中，<strong>map</strong> 对应的数据结构是 <strong>红黑树</strong>。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 <strong>O(logN)</strong>。而 <strong>unordered_map</strong> 对应 <strong>哈希表</strong>，哈希表的特点就是查找效率高，时间复杂度为常数级别 <strong>O(1)</strong>， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 unordered_map 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 map 容器。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p>unordered_map 是一种关联容器，用于存储由关键值 (Key Value，以下称为Key 值) 和映射值 (Mapped Value，以下称为映射值) 组成的元素，并且允许根据其 Key 值快速检索各个元素。</p></li><li><p>在 unordered_map 容器中，Key 值通常用来唯一标识元素，映射值是与该 Key 值关联内容的对象。Key 值与映射值的类型可能不同。</p></li><li><p>在 unordered_map 内部，元素没有按照其 Key 值与映射值的任何顺序进行排序 ，而是根据它们的 Hash 值组织成桶，允许它们通过其 Key 值直接快速访问单个元素（通常具有常数等级的平均时间复杂度）。</p></li><li><p>unordered_map 容器与 map 容器相比，通过 Key 值访问各个元素的速度更快，然而通过其元素子集进行范围迭代的效率通常较低。</p></li><li><p>unordered_map 实现了直接访问操作符 (operator[])，它允许使用 Key 值作为输入参数，直接访问映射值。</p></li><li><p>容器中的迭代器至少是前向迭代器。</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>引入头文件 <strong><unordered_map></strong> </p></li><li><p>unordered_map<key,value> m;</p></li><li><p>m.size();    //元素数量</p></li><li><p>m.insert(x);</p></li><li><p>m.find(key);</p><p>m.count(key);</p></li><li><p>m.erese(key);</p></li><li><p>m[key] → value</p></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li><p>基本使用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="string">&#x27;a&#x27;</span>] = <span class="number">9</span>;</span><br><span class="line">m[<span class="string">&#x27;?&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">m[<span class="string">&#x27;z&#x27;</span>] = <span class="number">99</span>;</span><br><span class="line">m[<span class="string">&#x27;A&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">m[<span class="string">&#x27;Z&#x27;</span>] = <span class="number">-2</span>;</span><br><span class="line">m[<span class="string">&#x27; &#x27;</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出元素个数</span></span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找&#x27; &#x27;元素是否存在，若存在，输出其对应的值；</span></span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">count</span>(<span class="string">&#x27; &#x27;</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; m[<span class="string">&#x27; &#x27;</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出内部所有元素，体现无序性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">begins</span>(); it != m.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">Z -2</span><br><span class="line">  0</span><br><span class="line">A 50</span><br><span class="line">? 5</span><br><span class="line">z 99</span><br><span class="line">a 9</span><br></pre></td></tr></table></figure></li><li><p>Leetcode <a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Key is the number and value is its index in the vector</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hash;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> &lt;<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> numberToFind = target - number[i];</span><br><span class="line">            <span class="comment">//if numberToFind is found in map, return them</span></span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">find</span>(numberToFind) != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(hash[numberToFind);</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">                hash[numbers[i]] = i;                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;                              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 散落的知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建记录</title>
      <link href="/post/7cfd23b7.html"/>
      <url>/post/7cfd23b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="2023-2"><a href="#2023-2" class="headerlink" title="2023.2"></a>2023.2</h2><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>生成markdown文件，在命令行输入:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>在blog根目录下的source文件夹中的post文件夹会多一个 <strong>博客名字.md</strong> 的markdown文件，打开即可进行编辑。</p><h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>markdown语法参考链接 <a href="https://www.appinn.com/markdown/">Markdown语法说明（简体中文版）</a></p><h3 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h3><p>在根目录下git命令行输入三连指令，即可完成新页面的发布</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>如果在发布前想预览生成网站的效果，可输入</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><hr><h2 id="2024-7-25"><a href="#2024-7-25" class="headerlink" title="2024.7.25"></a>2024.7.25</h2><p>近日心血来潮地想起自己两年前心血来潮搭的网站，想到自己已经为这个域名掏了三年的钱包，还是要好好利用起来，于是再次开始维护。</p><h3 id="主页顶部图片更改"><a href="#主页顶部图片更改" class="headerlink" title="主页顶部图片更改"></a>主页顶部图片更改</h3><p>维护时首先想到的就是把主页顶部图片换了，顶部图片的更换非常简单，我目前使用的是butterfly主题，只需要在<code>_config.butterfly.yml</code>中修改<code>index_img</code>后的图片链接即可：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The banner image of home page （主页封面图片）</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">/img/The_Valley_of_the_Wind.jpg</span></span><br></pre></td></tr></table></figure><h3 id="文章页背景更换"><a href="#文章页背景更换" class="headerlink" title="文章页背景更换"></a>文章页背景更换</h3><p>之前不知什么时候给博客更换了一个花里胡哨的背景，使用一段时间后还是觉得白底黑字看起来最舒服，于是决定修改当前背景。背景更换需打开<code>Blog\themes\butterfly\source\css</code>目录下的<code>custom.css</code>，修改其中的<code>#web_bg</code></p><p>背景设置为渐变色</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#web_bg &#123;</span></span><br><span class="line"><span class="attr">background-image:</span> <span class="string">linear-gradient(to</span> <span class="string">top,</span> <span class="comment">#fef9d7 0%, #d299c2 100%);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>背景设置为纯色</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#web_bg &#123;</span></span><br><span class="line"><span class="attr">background-color:</span> <span class="comment">#ffffff;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="部署时spawn-failed报错问题的解决"><a href="#部署时spawn-failed报错问题的解决" class="headerlink" title="部署时spawn failed报错问题的解决"></a>部署时spawn failed报错问题的解决</h3><p>在完成一些参数的修改后，使用<code>hexo d</code>部署时却出现了spawn failed的报错。发现报错后首先尝试了目前主流的两种解决方案：</p><h4 id="1-重置git的deploy文件夹"><a href="#1-重置git的deploy文件夹" class="headerlink" title="1. 重置git的deploy文件夹"></a>1. 重置git的deploy文件夹</h4><p>删除blog文件夹中的<code>.deploy_git</code>文件夹，然后在终端cd进这个文件夹后输入<code>git config --global core.autocrlf false</code></p><h4 id="2-修改git-repo配置地址"><a href="#2-修改git-repo配置地址" class="headerlink" title="2. 修改git repo配置地址"></a>2. 修改git repo配置地址</h4><p>打开<code>_config.yml</code>配置文件，修改以下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"></span><br><span class="line"><span class="attr">repo:</span> <span class="string">https://github.com/yourname/yourname.github.io.git</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>其中的repo修改为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br></pre></td></tr></table></figure><h4 id="3-重置GitHub-SSH密钥"><a href="#3-重置GitHub-SSH密钥" class="headerlink" title="3. 重置GitHub SSH密钥"></a>3. 重置GitHub SSH密钥</h4><p>很遗憾，上面的两种方法最终都没能解决我的问题，但在查看<a href="https://blog.zhheo.com/p/128998ac.html">张洪Heo</a>的博客文章后我意识到可能是<strong>GitHub SSH密钥设置</strong>出现了问题。果然，在git命令行中尝试使用SSH连接时出现了错误。</p><p>git命令行输入：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git@github.com: Permission denied (publickey)</span><br></pre></td></tr></table></figure><p>登录许久未使用的用于部署网站的GitHub账号，发现<strong>原有的SSH密钥已被删除</strong>，原来作为安全预防措施，GitHub会自动删除一年内未使用过的 SSH 密钥。于是重新走了一遍设置GitHub密钥的流程（具体可参考“<a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a>”），问题终于成功解决。</p><hr><h2 id="2024-8-12"><a href="#2024-8-12" class="headerlink" title="2024.8.12"></a><strong>2024.8.12</strong></h2><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>在markdown中插入图片的语法为</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">src</span>)</span><br></pre></td></tr></table></figure><p>其中<code>src</code>既可以是本地图片的绝对/相对路径，比如<code>../images/test.png</code>，也可以是URL。<code>alt</code>是图片的注释，可以为空。</p><p>考虑到本地图片在网页中的加载速度较慢，且插入至markdown中的步骤比较繁琐，我采用了SMMS图床＋Typora自动上传的方法，这样只需要直接将图片粘贴到Typora中，图片就可以自动上传到图床。具体的配置步骤见<a href="https://blog.csdn.net/m0_56416743/article/details/132021539">Typora1.6.7+图床SMMS自动上传教程(PicGo-Core(command line)方式</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP问题</title>
      <link href="/post/41ef174f.html"/>
      <url>/post/41ef174f.html</url>
      
        <content type="html"><![CDATA[<h1 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h1><ul><li><strong>NP问题</strong> 的全称是：Non deterministic Ploynomial问题，即非确定性多项式问题。</li><li><strong>多项式时间（Polynomial time）</strong> 在计算复杂度理论中，指的是一个问题的计算时间m(n)不大于问题大小n的多项式倍数。</li><li><p><strong>什么是非确定性问题？</strong> </p><p>  有些计算问题是确定性的，比如加减乘除之类，你只要按照公式推导，按部就班一步步来，就可以得到结果。但是，有些问题是无法按部就班直接地计算出来。比如，找大质数的问题。有没有一个公式，你一套公式，就可以一步步推算出来，下一个质数应该是多少呢？这样的公式是没有的。再比如，大的合数分解质因数的问题，有没有一个公式，把合数代进去，就直接可以算出，它的因子各自是多少？也没有这样的公式。</p><p>  这种问题的答案，是无法直接计算得到的，只能通过间接的“猜算”来得到结果。这也就是<em>非确定性问题</em>。而这些问题的通常有个算法，它不能直接告诉你答案是什么，但可以告诉你，某个可能的结果是正确的答案还是错误的。这个可以告诉你“猜算”的答案正确与否的算法，假如可以在多项式时间内算出来，就叫做<em>多项式非确定性问题</em>。</p></li><li><strong>NP问题</strong> 就是非确定性的多项式问题，也就是说，可以在多项式时间内验证一个解是否正确的问题是NP问题。</li><li><p><strong>P问题</strong> 是能在多项式时间内求出其解的问题，所有的P问题都是NP问题，但是是否P=NP，目前还没有被证明。</p><p>  （不是所有的NP问题都是难解的问题，比如数组排序的问题就是P类问题，但是P属于NP问题，所它也是NP问题，但是他并不难解。）</p></li><li><p><strong>NP困难问题：</strong> 对于一个判定问题A,如果所有的NP问题都可以多项式时间规约到A，那么这个问题就是NP困难问题。</p></li><li><p><strong>NPC问题：</strong> 对于一个NP问题A，如果所有的NP问题都可以多项式时间规约到A，那么这个问题就是NP困难问题。</p></li><li><p><strong>NPC</strong>，也称NP完全问题，它是NP问题的一个子类，比如哈密尔顿回路问题就是NPC问题。它是这样描述的，给定N个顶点，以及任意两个顶点之间的距离，求出一条回路，使其经过每个顶点，且回路的总距离最短。这个问题可以通过枚举求出解，但是他的时间复杂度是(N-1)!,随着N的增大，要计算解是不可能的。</p><p>  NPC有一种性质，那就是如果能证明NPC问题可以在多项式时间内求出其解，则所有的NP都可以在多项式时间内求解了，即P=NP成立。所以，我们一般认为NPC问题是难解的问题，因为他不太可能存在一个多项式时间的算法（如果存在则所有的NP问题都存在多项式时间算法，这太不可思议了，但是也不是不可能）。</p></li><li><p><strong>NP完全问题的证明:</strong> 要证明一个判定问题是NP完全的,只要在NP完全类中找到一个问题A,将这个问题归约到待证明问题即可.要证明问题是NP完全是很困难的,因为很多问题之间的转化过程是很难想到的.第一个被证明的NP完全问题是可满足性问题,它是判定一个合取范式的布尔公式F是否存在真值指派的问题.在很多NP完全问题的证明中,我们都可以用这个问题来归约,这里不再详述。</p></li></ul><hr><p>转自<a href="https://blog.csdn.net/zxj1988/article/details/6275458">CSDN博主zxj1988的文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 散落的知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
