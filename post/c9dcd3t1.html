<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Exercises Part 3 | Analyzing Neural Time Series Data | Icarus</title><meta name="keywords" content="Analyzing Neural Time Series Data"><meta name="author" content="Icarus"><meta name="copyright" content="Icarus"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Exercises 10 | Convolution10.6.1 Create two kernels for convolution: one that looks like a U and one that looks like a decay function. There is no need to be too sophisticated in generating, for examp">
<meta property="og:type" content="article">
<meta property="og:title" content="Exercises Part 3 | Analyzing Neural Time Series Data">
<meta property="og:url" content="http://yuxii.top/post/c9dcd3t1.html">
<meta property="og:site_name" content="Icarus">
<meta property="og:description" content="Exercises 10 | Convolution10.6.1 Create two kernels for convolution: one that looks like a U and one that looks like a decay function. There is no need to be too sophisticated in generating, for examp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images2.alphacoders.com/907/907164.jpg">
<meta property="article:published_time" content="2024-08-17T02:48:00.835Z">
<meta property="article:modified_time" content="2024-09-02T16:18:29.919Z">
<meta property="article:author" content="Icarus">
<meta property="article:tag" content="Analyzing Neural Time Series Data">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images2.alphacoders.com/907/907164.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yuxii.top/post/c9dcd3t1"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Exercises Part 3 | Analyzing Neural Time Series Data',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-03 00:18:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Icarus" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/fox.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Icarus</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Exercises Part 3 | Analyzing Neural Time Series Data</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-17T02:48:00.835Z" title="发表于 2024-08-17 10:48:00">2024-08-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-02T16:18:29.919Z" title="更新于 2024-09-03 00:18:29">2024-09-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Exercises Part 3 | Analyzing Neural Time Series Data"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Exercises-10-Convolution"><a href="#Exercises-10-Convolution" class="headerlink" title="Exercises 10 | Convolution"></a>Exercises 10 | Convolution</h1><h2 id="10-6-1"><a href="#10-6-1" class="headerlink" title="10.6.1"></a>10.6.1</h2><ol>
<li>Create two kernels for convolution: one that looks like a U and one that looks like a decay function. There is no need to be too sophisticated in generating, for example, a Gaussian and an exponential; numerical approximations are fine.</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 10</span></span><br><span class="line"><span class="comment">% 1. Create two kernels </span></span><br><span class="line">kernel_U = [<span class="number">1</span> <span class="number">0.8</span> <span class="number">0.3</span> <span class="number">0.1</span> <span class="number">0</span> <span class="number">0.1</span> <span class="number">0.3</span> <span class="number">0.8</span> <span class="number">1</span>];</span><br><span class="line">kernel_decay = [<span class="number">1</span> <span class="number">0.9</span> <span class="number">0.8</span> <span class="number">0.7</span> <span class="number">0.5</span> <span class="number">0.3</span> <span class="number">0.2</span> <span class="number">0.1</span> <span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h2 id="10-6-2"><a href="#10-6-2" class="headerlink" title="10.6.2"></a>10.6.2</h2><ol>
<li>Convolve these two kernels with 50 time points of EEG data from one electrode. Make a plot showing the kernels, the EEG data, and the result of the convolution between the data and each kernel. Use time-domain convolution as explained in this chapter and as illustrated in the online Matlab code. Based on visual inspection, what is the effect of convolving the EEG data with these two kernels?</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2</span></span><br><span class="line"><span class="comment">% Snippet of EEG data</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">impEEG = EEG.data(<span class="number">47</span>,<span class="number">100</span>:<span class="number">149</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用自编函数计算impEEG与kernel_U的convolution</span></span><br><span class="line"><span class="comment">% data that we&#x27;ll use for convolution (must be zero-padded).</span></span><br><span class="line">dat4conv = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) impEEG <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) ];</span><br><span class="line"></span><br><span class="line"><span class="comment">% used for cutting the result of convolution</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize convolution output</span></span><br><span class="line">convolution_result_U = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(impEEG)+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% run convolution (note that kernel is flipped backwards) ti以外的范围会被舍弃，没必要计算</span></span><br><span class="line"><span class="keyword">for</span> ti=half_of_kernel_size+<span class="number">1</span>:<span class="built_in">length</span>(convolution_result_U)-half_of_kernel_size         </span><br><span class="line">    convolution_result_U(ti) = sum(dat4conv(ti:ti+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>).*kernel_U(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_U = convolution_result_U(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用Matlab自带函数conv()计算impEEG与kernel_decay的convolution</span></span><br><span class="line">convolution_result_decay = conv(impEEG,kernel_decay,<span class="string">&#x27;same&#x27;</span>);    <span class="comment">%% &#x27;same&#x27;:conv的结果与impfun的长度相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot kernels</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">311</span>)</span><br><span class="line"><span class="built_in">plot</span>(kernel_U,<span class="string">&#x27;bo-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(kernel_decay,<span class="string">&#x27;ro-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;decay&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.84</span> <span class="number">0.13512</span> <span class="number">0.064683</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Points&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Convolution kernels&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot Snippet of EEG data</span></span><br><span class="line">subplot(<span class="number">312</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Snippet of EEG data (EEG.data(47,100:149,10))&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot EEG data before and after convolution</span></span><br><span class="line">subplot(<span class="number">313</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;k-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_U./sum(kernel_U),<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_decay./sum(kernel_decay),<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;U-convolved&#x27;</span>,<span class="string">&#x27;decay-convolved&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.65</span> <span class="number">0.245</span> <span class="number">0.2</span> <span class="number">0.09</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;EEG data before and after convolution&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/17/Id6gBtjlfc2LV1M.png" alt="Ex_10" style="zoom:67%;" /></p>
<hr>
<h1 id="Exercises-11-Fourier-Transform"><a href="#Exercises-11-Fourier-Transform" class="headerlink" title="Exercises 11 | Fourier Transform"></a>Exercises 11 | Fourier Transform</h1><h2 id="11-12-1"><a href="#11-12-1" class="headerlink" title="11.12.1"></a>11.12.1</h2><p>Reproduce the top three panels of figure 11.12 three times. </p>
<ul>
<li><p>First, perform time-domain convolution using <strong>the “ manual ” convolution method</strong> shown in chapter 10. </p>
</li>
<li><p>Second, perform frequency-domain convolution using <strong>the discrete time Fourier transform</strong> presented at the beginning of this chapter. </p>
</li>
<li>Finally, perform frequency-domain convolution using <strong>the Matlab functions fft and ifft</strong> (do not use the function conv). (You can optionally reproduce the bottom panel of figure 11.12 for the frequency domain analyses; keep in mind that the power scaling is for display purposes only.) </li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 1. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">    conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"><span class="comment">% Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    <span class="comment">% create sine wave</span></span><br><span class="line">    sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">    fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line"></span><br><span class="line"><span class="comment">% inverse Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line">conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,eegdat4convol);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_manual,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_Fourier,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_fft,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;&quot;manual&quot; convolution method&#x27;</span>,<span class="string">&#x27;discrete time Fourier transform&#x27;</span>,<span class="string">&#x27;Matlab functions fft and ifft&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/dHleLSJOyTUR9xt.png" alt="Ex_11"></p>
<h2 id="11-12-2"><a href="#11-12-2" class="headerlink" title="11.12.2"></a>11.12.2</h2><p>From the three sets of Matlab code you have for reproducing figure 11.12 , run a computation time test. That is, time how long it takes Matlab to perform 1000 repetitions of each of the three methods for computing convolution that you generated in the previous exercise (do not plot the results each time). You can use the Matlab function pairs tic and toc to time a Matlab process. Plot the results in a bar plot, similar to figure 11.8 . </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 2. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line">t = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">        conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">1</span>) = toc;</span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="comment">% Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        <span class="comment">% create sine wave</span></span><br><span class="line">        sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">        fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% inverse Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">2</span>) = toc;</span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">    conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">3</span>) = toc;</span><br><span class="line"><span class="comment">%% plot results in a bar plot</span></span><br><span class="line">b = bar(t);</span><br><span class="line">labels = string(b(<span class="number">1</span>).YData);</span><br><span class="line">text(b(<span class="number">1</span>).XEndPoints,b(<span class="number">1</span>).YEndPoints,labels,<span class="string">&#x27;HorizontalAlignment&#x27;</span>,<span class="string">&#x27;center&#x27;</span>,<span class="string">&#x27;VerticalAlignment&#x27;</span>,<span class="string">&#x27;top&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>])</span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,&#123;<span class="string">&#x27;manual convolution&#x27;</span>;<span class="string">&#x27;DTFT&amp;IDTFT&#x27;</span>;<span class="string">&#x27;FFT&amp;IFFt&#x27;</span>&#125;)</span><br><span class="line">set(gca, <span class="string">&#x27;YScale&#x27;</span>, <span class="string">&#x27;log&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;time(s)&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/391pAN7iXbJEkdl.png" alt="Ex_11(2)" style="zoom: 50%;" /></p>
<h2 id="11-12-3"><a href="#11-12-3" class="headerlink" title="11.12.3"></a>11.12.3</h2><p>Generate a time series by creating and summing sine waves, as in figure 11.2B . Use between two and four sine waves, so that the individual sine waves are still somewhat visible in the sum. Perform a Fourier analysis (you can use the fft function) on the resulting time series and plot the power structure. Confirm that your code is correct by comparing the frequencies with nonzero power to the frequencies of the sine waves that you generated. Now try adding random noise to the signal before computing the Fourier transform. First, add a small amount of noise so that the sine waves are still visually recognizable. Next, add a large amount of noise so that the sine waves are no longer visually recognizable in the time domain data. Perform a Fourier analysis on the two noisy signals and plot the results. What is the effect of a small and a large amount of noise in the power spectrum? Are the sine waves with noise easier to detect in the time domain or in the frequency domain, or is it equally easy/difficult to detect a sine wave in the presence of noise? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Create sine waves</span></span><br><span class="line">srate = <span class="number">400</span>;</span><br><span class="line">time=<span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">N = <span class="built_in">length</span>(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create three sine waves</span></span><br><span class="line">s1 = <span class="number">20</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">3</span>*time);</span><br><span class="line">s2 = <span class="number">10</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">8</span>*time);</span><br><span class="line">s3 = <span class="number">5</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">15</span>*time);</span><br><span class="line">sum_Sine = s1+s2+s3;</span><br><span class="line"></span><br><span class="line"><span class="comment">% add random noise</span></span><br><span class="line">Sine_LitteNoise = sum_Sine + <span class="number">10</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line">Sine_LargeNoise = sum_Sine + <span class="number">40</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">linspace</span>(<span class="number">0</span>,srate/<span class="number">2</span>,<span class="built_in">floor</span>(N/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = fft(sum_Sine)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LitteNoise = fft(Sine_LitteNoise)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LargeNoise = fft(Sine_LargeNoise)./(N/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = <span class="built_in">abs</span>(FFT_Sine(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LitteNoise = <span class="built_in">abs</span>(FFT_LitteNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LargeNoise = <span class="built_in">abs</span>(FFT_LargeNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(time,sum_Sine);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Original time series&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">bar(f,FFT_Sine);</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LitteNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">bar(f,FFT_LitteNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LargeNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, large noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>)</span><br><span class="line">bar(f,FFT_LargeNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, large noise&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/I5wHdjzGkQmMDN6.png" alt="Ex_11(3)" style="zoom: 80%;" /></p>
<hr>
<h1 id="Exercises-12-Morlet-wavelets"><a href="#Exercises-12-Morlet-wavelets" class="headerlink" title="Exercises 12 | Morlet wavelets"></a>Exercises 12 | Morlet wavelets</h1><ol>
<li><p>Create a family of Morlet wavelets ranging in frequency from 2 Hz to 30 Hz in five steps. </p>
</li>
<li><p>Select one electrode from the scalp EEG dataset and convolve each wavelet with EEG data from all trials from that electrode. Apply the Matlab function real to the convolution result, as in <code>convol_result=real(convol_result)</code>. This will return the EEG data bandpass filtered at the peak frequency of the wavelet. You learn more about why this is in the next chapter. </p>
</li>
<li><p>Average the result of convolution over all trials and plot an ERP corresponding to each wavelet frequency. Each frequency should be in its own subplot. </p>
</li>
<li><p>Plot the broadband ERP (without any convolution). Thus, you will have six subplots in one figure. How do the wavelet-convolved ERPs compare with the broadband ERP? Are there dynamics revealed by the wavelet-convolved ERPs that are not apparent in the broadband ERP, and are there dynamics in the broadband ERP that are not apparent in the waveletconvolved ERPs? Base your answer on qualitative visual inspection of the results; statistics or other quantitative comparisons are not necessary. </p>
</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercise 12</span></span><br><span class="line"><span class="comment">%% 1. Create a family of Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequencies = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">num_wavelets = <span class="built_in">length</span>(frequencies);</span><br><span class="line"></span><br><span class="line">srate = EEG.srate;</span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">wavelet_family = <span class="built_in">zeros</span>(num_wavelets,<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Loop through frequencies and make a family of wavelets.</span></span><br><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:num_wavelets</span><br><span class="line"> </span><br><span class="line">    <span class="comment">% create a sine wave at this frequency</span></span><br><span class="line">    sinewave = <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*frequencies(fi).*time); <span class="comment">% the &quot;1i&quot; makes it a complex wavelet</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create a Gaussian window</span></span><br><span class="line">    gaus_win = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi)))^<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create wavelet via element-by-element multiplication of the sinewave and gaussian window</span></span><br><span class="line">    wavelet_family(fi,:) = sinewave.*gaus_win;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 2. Get EEG data from electrode 47, convolve each wavelet with EEG data</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line">channel = <span class="number">47</span>;</span><br><span class="line">n_conv = EEG.pnts + <span class="built_in">length</span>(time) - <span class="number">1</span>;</span><br><span class="line">convol_result = <span class="built_in">zeros</span>(EEG.trials,num_wavelets,n_conv);</span><br><span class="line">half_of_kernal_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> trial_i = <span class="number">1</span>:EEG.trials</span><br><span class="line">    fft_EEG = fft(EEG.data(channel,:,trial_i),n_conv);</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:num_wavelets</span><br><span class="line">        fft_wavelet = fft(wavelet_family(fi,:),n_conv);</span><br><span class="line">        convol_result(trial_i,fi,:) = ifft(fft_EEG.*fft_wavelet,n_conv) * <span class="built_in">sqrt</span>(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi))) / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convol_result = <span class="built_in">real</span>(convol_result(:,:,half_of_kernal_size+<span class="number">1</span>:n_conv-half_of_kernal_size));</span><br><span class="line">filtered_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(convol_result,<span class="number">1</span>));		<span class="comment">% 经过wavelet滤波后的ERP</span></span><br><span class="line">broadband_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(channel,:,:),<span class="number">3</span>));		 <span class="comment">% 未滤波的ERP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_wavelets</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,filtered_ERP(<span class="built_in">i</span>,:));</span><br><span class="line">    set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-300</span>, <span class="number">1000</span>])</span><br><span class="line">    ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">    xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Wavelet filtered ERP at &#x27;</span> num2str(frequencies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,broadband_ERP);</span><br><span class="line">ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Unfiltered broadband ERP&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/19/3lrQXKtgZI4docT.png" alt="Ex_12"></p>
<hr>
<h1 id="Exercises-13-complex-Morlet-wavelets"><a href="#Exercises-13-complex-Morlet-wavelets" class="headerlink" title="Exercises 13 | complex Morlet wavelets"></a>Exercises 13 | complex Morlet wavelets</h1><h2 id="1-Create-a-family-of-complex-Morlet-wavelets"><a href="#1-Create-a-family-of-complex-Morlet-wavelets" class="headerlink" title="1. Create a family of complex Morlet wavelets"></a>1. Create a family of complex Morlet wavelets</h2><p>Create a family of complex Morlet wavelets ranging in frequencies from 2 Hz to 30 Hz in five steps. </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 13</span></span><br><span class="line"><span class="comment">% 1. Create a family of complex Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">time = <span class="number">-2</span>:<span class="number">1</span>/EEG.srate:<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在3和10之间生成5个对数分别的数，作为不同频率下wavelet包含的周期数目</span></span><br><span class="line">numcycles = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">10</span>),<span class="built_in">length</span>(frex));</span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex), <span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% make complex Morlet wavelets</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi));</span><br><span class="line">    wavelet(fi,:) = <span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)) * <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi).*time);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 检查两侧是否衰减到0</span></span><br><span class="line">    <span class="comment">% subplot(ceil(length(frex)/3), ceil(length(frex)/2), fi);</span></span><br><span class="line">    <span class="comment">% plot(time,real(wavelet));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="2-Convolve-each-wavelet-with-EEG-data"><a href="#2-Convolve-each-wavelet-with-EEG-data" class="headerlink" title="2. Convolve each wavelet with EEG data"></a>2. Convolve each wavelet with EEG data</h2><p>Convolve each wavelet with EEG data from all electrodes and from one trial. </p>
<h2 id="3-Extract-power-and-phase"><a href="#3-Extract-power-and-phase" class="headerlink" title="3. Extract power and phase"></a>3. Extract power and phase</h2><p>Extract power and phase from the result of complex wavelet convolution and store in a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix). </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2. Convolve each wavelet with EEG data from all electrode and from one trial</span></span><br><span class="line">trial = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 3. a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix)</span></span><br><span class="line">convolution_result_fft = <span class="built_in">zeros</span>(n_convolution,<span class="built_in">length</span>(frex),EEG.nbchan,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% FFT of wavelet and EEG data</span></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    fft_data    = fft(<span class="built_in">squeeze</span>(EEG.data(electrodei,:,trial)),n_convolution); <span class="comment">% trial 1</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">        fft_wavelet = fft(wavelet(fi,:),n_convolution);</span><br><span class="line">        convoli = ifft(fft_wavelet.*fft_data,n_convolution) * <span class="built_in">sqrt</span>(s);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">1</span>) = <span class="built_in">abs</span>(convoli.^<span class="number">2</span>);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">2</span>) = <span class="built_in">angle</span>(convoli);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_fft = convolution_result_fft(half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size,:,:,:);</span><br></pre></td></tr></table></figure>
<h2 id="4-Make-topographical-plots-of-power-and-phase"><a href="#4-Make-topographical-plots-of-power-and-phase" class="headerlink" title="4. Make topographical plots of power and phase"></a>4. Make topographical plots of power and phase</h2><p>Make topographical plots of power and phase at 180 ms at all frequencies (hint: you may need to use the squeeze function to remove singleton dimensions). Arrange the plots in one figure with five columns for frequency and two rows for power/phase. Put labels in the plot so it is clear which topographical maps correspond to which frequencies. </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 180 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">180</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/gypqPbMUZfo2iC5.png" alt="Ex_13(1)"></p>
<h2 id="5-Repeat-step-4-for-activity-at-360-ms"><a href="#5-Repeat-step-4-for-activity-at-360-ms" class="headerlink" title="5. Repeat step 4 for activity at 360 ms."></a>5. Repeat step 4 for activity at 360 ms.</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 360 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">360</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/DxTRqhzK72JtoPL.png" alt="Ex_13(2)"></p>
<h2 id="6-Think"><a href="#6-Think" class="headerlink" title="6. Think"></a>6. Think</h2><p>Are there any prominent topographical features in power or in phase?     - Yes.</p>
<p>Do these differ for different frequencies?     - Yes.</p>
<p>Do power and phase have similar topographical distributions?    - It doesn’t look very similar.</p>
<p>Is there any reason to suspect that they might have similar or different topographies?     </p>
<blockquote>
<h4 id="From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures"><a href="#From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures" class="headerlink" title="(From ChatGPT for reference, GPT is not provided with corresponding pictures)"></a><strong>(From ChatGPT for reference, GPT is not provided with corresponding pictures)</strong></h4><p>When analyzing EEG data, particularly through time-frequency decomposition, you might observe various topographical features in both power and phase distributions across the scalp. These features can provide insights into underlying neural processes. Let’s break down each question:</p>
<h4 id="1-Are-there-any-prominent-topographical-features-in-power-or-in-phase"><a href="#1-Are-there-any-prominent-topographical-features-in-power-or-in-phase" class="headerlink" title="(1) Are there any prominent topographical features in power or in phase?"></a><strong>(1) Are there any prominent topographical features in power or in phase?</strong></h4><ul>
<li><strong>Power Topography</strong>: Power topography represents the distribution of signal power across the scalp. Prominent features in power maps could indicate areas of strong neural activity, which might correspond to specific cognitive or sensory processes. For example, increased power in the occipital regions might be related to visual processing.</li>
<li><strong>Phase Topography</strong>: Phase topography shows the distribution of phase angles across the scalp. Prominent features in phase topography could indicate phase synchronization between regions, which might be associated with communication between different brain areas.</li>
</ul>
<h4 id="2-Do-these-differ-for-different-frequencies"><a href="#2-Do-these-differ-for-different-frequencies" class="headerlink" title="(2) Do these differ for different frequencies?"></a><strong>(2) Do these differ for different frequencies?</strong></h4><ul>
<li>Yes, topographical features often differ for different frequencies. Different frequencies in EEG are associated with different types of neural activity (e.g., alpha waves in the 8-12 Hz range are often related to relaxation and closed eyes, while beta waves in the 13-30 Hz range are associated with active thinking or focus). The power and phase topographies can change significantly across different frequency bands, reflecting the different functional roles of these frequencies.</li>
</ul>
<h4 id="3-Do-power-and-phase-have-similar-topographical-distributions"><a href="#3-Do-power-and-phase-have-similar-topographical-distributions" class="headerlink" title="(3) Do power and phase have similar topographical distributions?"></a><strong>(3) Do power and phase have similar topographical distributions?</strong></h4><ul>
<li>Power and phase distributions are often not identical. Power topography might highlight regions with strong amplitude, while phase topography might emphasize regions where the timing of oscillatory activity is synchronized across electrodes. However, there can be similarities, especially in regions where strong power is accompanied by consistent phase alignment (e.g., in tasks requiring coordinated neural activity across brain regions).</li>
</ul>
<h4 id="4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies"><a href="#4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies" class="headerlink" title="(4) Is there any reason to suspect that they might have similar or different topographies?"></a><strong>(4) Is there any reason to suspect that they might have similar or different topographies?</strong></h4><ul>
<li><strong>Similar Topographies</strong>: Power and phase could have similar topographies in cases where high power is associated with phase-locked activity across trials or regions. For instance, during sensory processing, a stimulus might evoke both strong power and phase synchronization in relevant brain areas.</li>
<li><strong>Different Topographies</strong>: Conversely, power and phase might differ in their topographical distributions due to different underlying mechanisms. High power might occur in one region without strong phase alignment, especially if the neural activity is more localized or independent across trials. Additionally, phase synchronization can occur without strong power, especially in low-amplitude oscillations that are critical for certain cognitive processes.</li>
</ul>
<h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h4><ul>
<li><strong>Power and phase topographies can both reveal important aspects of neural activity, but they often provide different insights</strong>. Power maps tend to show where neural activity is strong, while phase maps can indicate where different regions are temporally synchronized. The topographies of power and phase may differ depending on the frequency of interest and the specific neural processes involved. Understanding these distributions and their relationships is key to interpreting EEG data in the context of neural dynamics.</li>
</ul>
</blockquote>
<h2 id="7-Create-a-circular-colormap"><a href="#7-Create-a-circular-colormap" class="headerlink" title="7.  Create a circular colormap"></a>7.  Create a circular colormap</h2><p>Because phase values are circular ( – <em>π</em> and + <em>π</em> are identical), most color maps are inappropriate because they suggest that – <em>π</em> and + <em>π</em> are very different values (represented, e.g., by blue and red colors). Create a circular colormap that can be used for phase values. You can do this by setting the red, green, and/or blue values to be a cosine function rather than a linear function. Recreate the phase topographical maps. Do they look any different with the new color maps? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自定义用于相位的环形colormap，使得-pi和pi对应的颜色相同</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ax6 = subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">nColors = <span class="number">128</span>; <span class="comment">% 调色板的颜色数量</span></span><br><span class="line">cmap = hsv(nColors); <span class="comment">% 使用 HSV colormap</span></span><br><span class="line">cmap = cmap([<span class="number">1</span>:<span class="keyword">end</span> <span class="number">1</span>], :); <span class="comment">% 将第一个颜色重复，使得 -pi 和 pi 一致</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加环形 colorbar</span></span><br><span class="line">cb = colorbar;</span><br><span class="line">set(cb, <span class="string">&#x27;Ticks&#x27;</span>, [-<span class="built_in">pi</span>, -<span class="built_in">pi</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="built_in">pi</span>/<span class="number">2</span>, <span class="built_in">pi</span>], <span class="string">&#x27;TickLabels&#x27;</span>, &#123;<span class="string">&#x27;-\pi&#x27;</span>, <span class="string">&#x27;-\pi/2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;\pi/2&#x27;</span>, <span class="string">&#x27;\pi&#x27;</span>&#125;);</span><br><span class="line">clim([-<span class="built_in">pi</span> <span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">axis off</span><br><span class="line">cb.Position(<span class="number">1</span>) = ax6.Position(<span class="number">1</span>);</span><br><span class="line">cb.Position(<span class="number">2</span>) = ax6.Position(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/8dGJkcTSfWMRO1A.png" alt="Ex_13(3)"></p>
<hr>
<h1 id="Exercises-14-filter-Hilbert"><a href="#Exercises-14-filter-Hilbert" class="headerlink" title="Exercises 14 | filter-Hilbert"></a>Exercises 14 | filter-Hilbert</h1><ol>
<li>Pick two frequencies (e.g., 5 Hz and 25 Hz) and one electrode and perform complex Morlet wavelet convolution and filter-Hilbert using those two frequencies as the peak/center frequencies for all trials. Plot the resulting power and the bandpass-filtered signal (that is, the real component of the analytic signal) from each method. Plot one single trial (you can choose the trial randomly but plot the same trial for both methods) and then plot the average of all trials. Describe some similarities and differences between the results of the two time-frequency decomposition methods. </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 14</span></span><br><span class="line"><span class="comment">%% 1. perform complex Morlet wavelet convolution and filter-Hilbert using frequencies 5 Hz and 25 Hz</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"><span class="comment">% two frequencies</span></span><br><span class="line">frex = [<span class="number">5</span>, <span class="number">25</span>]; <span class="comment">% the center frequencies</span></span><br><span class="line"><span class="comment">% pick one electrode (Fcz) and one trial</span></span><br><span class="line">electrode = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,<span class="string">&#x27;Fcz&#x27;</span>));</span><br><span class="line">trial = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">data2filter = <span class="built_in">squeeze</span>(EEG.data(electrode,:,trial));</span><br><span class="line">data2filter_average = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(electrode,:,:),<span class="number">3</span>));</span><br><span class="line"><span class="comment">%% perform complex Morlet wavelet convolution</span></span><br><span class="line"><span class="comment">% wavelet parameters</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">numcycles = [<span class="number">4</span> <span class="number">5</span>];</span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">conv_result_wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),n_convolution);</span><br><span class="line">conv_result_wavelet_2 = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),n_convolution);</span><br><span class="line">fft_data = fft(data2filter,n_convolution);</span><br><span class="line">fft_data_2 = fft(data2filter_average,n_convolution);</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi));</span><br><span class="line">    wavelet = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi).*time);</span><br><span class="line">    </span><br><span class="line">    fft_wavelet = fft(wavelet,n_convolution);</span><br><span class="line">    fft_wavelet = fft_wavelet ./ <span class="built_in">max</span>(<span class="built_in">abs</span>(fft_wavelet));</span><br><span class="line">    conv_result_wavelet(fi,:) = ifft(fft_wavelet.*fft_data,n_convolution)*(<span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)));</span><br><span class="line">    conv_result_wavelet_2(fi,:) = ifft(fft_wavelet.*fft_data_2,n_convolution)*(<span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">conv_result_wavelet = conv_result_wavelet(:,half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line">conv_result_wavelet_2 = conv_result_wavelet_2(:,half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line"><span class="comment">%% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">2</span> <span class="number">10</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = [<span class="number">.01</span> <span class="number">.15</span>];</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>) ([<span class="number">1</span> <span class="number">1</span>]-transwid)&#x27;.*(frex-freqspread)&#x27; (frex-freqspread)&#x27; (frex+freqspread)&#x27; ([<span class="number">1</span> <span class="number">1</span>]+transwid)&#x27;.*(frex+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(fi),EEG.pnts);</span><br><span class="line">filter_result_2 = <span class="built_in">zeros</span>(<span class="built_in">length</span>(fi),EEG.pnts);</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">    fft_filter = fft(filterweights);</span><br><span class="line">    filter_result(fi,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    filter_result_2(fi,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter_average));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(conv_result_wavelet(<span class="built_in">i</span>,:)).^<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(filter_result(<span class="built_in">i</span>,:)).^<span class="number">2</span>)</span><br><span class="line">    set(gca,<span class="string">&quot;XLim&quot;</span>,[<span class="number">-500</span>,<span class="number">1000</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Voltage (\muV)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Center Frequency: &#x27;</span> num2str(frex(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;wavelet&#x27;</span>,<span class="string">&#x27;filter-Hilbert&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(conv_result_wavelet_2(<span class="built_in">i</span>,:)).^<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(filter_result_2(<span class="built_in">i</span>,:)).^<span class="number">2</span>)</span><br><span class="line">    set(gca,<span class="string">&quot;XLim&quot;</span>,[<span class="number">-500</span>,<span class="number">1000</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Voltage (\muV)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Center Frequency: &#x27;</span> num2str(frex(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;wavelet&#x27;</span>,<span class="string">&#x27;filter-Hilbert&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/26/5IQZ4tyGiRP6Lck.png" alt="Ex_14(1)_onetrial"></p>
<p><img src="https://s2.loli.net/2024/08/26/LfFCS7RhA6BjYpX.png" alt="Ex_14(1)_onetrial"></p>
<ol>
<li>Modify the wavelet and filter settings (but keep the peak/center frequencies the same) until these two methods produce very similar results. Next, modify the wavelet and filter settings (except the peak/center frequencies) to make the results different (stay within a reasonable range of parameter settings; they do not need to look dramatically different). Which parameters did you change to make the results look more similar versus more different? How different are the results, and would you consider this a meaningful difference? What does this difference tell you about when to use specific parameter settings for wavelet convolution and the filter-Hilbert method? </li>
</ol>
<p>尝试改变的参数：</p>
<ul>
<li>wavelet：<ul>
<li>numcycles：wavelet包含的周期数目参数。包含的周期数目越多，wavelet频带越窄，频率分辨率越高</li>
</ul>
</li>
<li>filter-Hilbert：<ul>
<li>freqspread：带宽参数。带宽越大，频率分辨率越低</li>
<li>transwid：过渡区宽度参数。</li>
<li><code>firls()</code>的第一个参数，the order of the filter：决定filter kernel频率响应的精度。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Exercises-15"><a href="#Exercises-15" class="headerlink" title="Exercises 15"></a>Exercises 15</h1><ol>
<li>Compute the <strong>short-time FFT</strong> at each electrode and make topographical maps of theta band (around 6 Hz) power and alpha-band (around 10 Hz) power at 150 ms and 700 ms. </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Compute the short-time FFT at each electrode</span></span><br><span class="line"><span class="comment">% and make topographical maps of theta band (around 6 Hz) power and alpha-band (around 10 Hz) power at 150 ms and 700 ms. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">50</span>:<span class="number">1000</span>; <span class="comment">% in ms</span></span><br><span class="line">timepoint(<span class="number">1</span>) = <span class="number">150</span>;   <span class="comment">% ms</span></span><br><span class="line">timepoint(<span class="number">2</span>) = <span class="number">700</span>;   <span class="comment">% ms</span></span><br><span class="line">frequency(<span class="number">1</span>) = <span class="number">6</span>;     <span class="comment">% Hz</span></span><br><span class="line">frequency(<span class="number">2</span>) = <span class="number">10</span>;    <span class="comment">% Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert ms to idx</span></span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> frexi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [junk,times2saveidx(frexi)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(frexi)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">0.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">tf = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frex),<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    <span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">        tempdat = <span class="built_in">squeeze</span>(EEG.data(channi,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">        <span class="comment">% and hann_win)</span></span><br><span class="line">        taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">        </span><br><span class="line">        fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">        tf(channi,:,timepointi) = <span class="built_in">mean</span>(<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>,<span class="number">2</span>); <span class="comment">% average over trials</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[junk,frequencyidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency(<span class="number">1</span>)));</span><br><span class="line">[junk,frequencyidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency(<span class="number">2</span>)));</span><br><span class="line">[junk,timepointidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-timepoint(<span class="number">1</span>)));</span><br><span class="line">[junk,timepointidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-timepoint(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> timei = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> frexi = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        subplot(<span class="number">2</span>,<span class="number">2</span>,(timei<span class="number">-1</span>)*<span class="number">2</span>+frexi)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(tf(:,frequencyidx(frexi),timepointidx(timei))),EEG.chanlocs);</span><br><span class="line">        title([num2str(timepoint(timei)) <span class="string">&#x27;ms, &#x27;</span> num2str(frequency(frexi)) <span class="string">&#x27;Hz&#x27;</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/01/IZGUTadVePJ85Qt.png" alt="Ex_15(1)" style="zoom:50%;" /></p>
<ol>
<li>Select one electrode and one frequency and compute power over time at that electrode and that frequency using <strong>complex wavelet convolution</strong>, <strong>filter-Hilbert</strong>, and the <strong>short-time FFT</strong>. Plot the results of these three time-frequency decomposition methods in different subplots of one figure. Note that the scaling might be different because no baseline normalization has been applied. How visually similar are the results from these three methods? If the results from the three methods are different, how are they different, and what parameters do you think you could change in the three methods to make the results look more or less similar? </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% Select one electrode and one frequency and compute power over time at that electrode and that frequency</span><br><span class="line">% using complex wavelet convolution, filter-Hilbert, and the short-time FFT.</span><br><span class="line"></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">channel2plot = &#x27;Fcz&#x27;;</span><br><span class="line">electrode = strcmpi(channel2plot,&#123;EEG.chanlocs.labels&#125;);</span><br><span class="line">frequency = 6;     % in Hz</span><br><span class="line"></span><br><span class="line">times2save = -200:1000/EEG.srate:800;</span><br><span class="line">% convert from ms to index</span><br><span class="line">times2saveidx = zeros(size(times2save));</span><br><span class="line">for i=1:length(times2save)</span><br><span class="line">    [junk,times2saveidx(i)]=min(abs(EEG.times-times2save(i)));</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%% complex wavelet convolution</span><br><span class="line">time = -1:1/EEG.srate:1;</span><br><span class="line">numcycle = 4;</span><br><span class="line">s = numcycle/(2*pi*frequency);</span><br><span class="line">wavelet = exp(-time.^2./(2*s^2)) .* exp(1i*2*pi*frequency.*time);</span><br><span class="line"></span><br><span class="line">% FFT parameters</span><br><span class="line">n_wavelet            = length(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data-1;</span><br><span class="line">half_of_wavelet_size = (length(time)-1)/2;</span><br><span class="line"></span><br><span class="line">% FFT of wavelet and EEG data</span><br><span class="line">fft_wavelet = fft(wavelet,n_convolution);</span><br><span class="line">convol = zeros(EEG.trials,n_convolution);</span><br><span class="line">for triali = 1:EEG.trials</span><br><span class="line">    fft_data    = fft(squeeze(EEG.data(electrode,:,triali)),n_convolution);</span><br><span class="line">    convol(triali,:) = ifft(fft_wavelet.*fft_data,n_convolution);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">convolution_result_fft = mean((abs(convol).^2),1);</span><br><span class="line"></span><br><span class="line">% cut off edges</span><br><span class="line">convolution_result_fft = convolution_result_fft(half_of_wavelet_size+1:end-half_of_wavelet_size);</span><br><span class="line"></span><br><span class="line">%% filter-Hilbert</span><br><span class="line">freqspread = 3; % Hz +/- the center frequency</span><br><span class="line">transwid   = 0.01;</span><br><span class="line">nyquist = EEG.srate/2;</span><br><span class="line">% construct filter kernels</span><br><span class="line">ffrequencies  = [ 0 (1-transwid)&#x27;.*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (1+transwid)&#x27;.*(frequency+freqspread)&#x27; nyquist ]./nyquist;</span><br><span class="line">idealresponse = [ 0 0 1 1 0 0 ];</span><br><span class="line"></span><br><span class="line">filterweights = firls(200,ffrequencies,idealresponse);</span><br><span class="line">filter_result = zeros(EEG.trials,EEG.pnts);</span><br><span class="line"></span><br><span class="line">for triali = 1:EEG.trials</span><br><span class="line">    filter_result(triali,:) = hilbert(filtfilt(filterweights,1,EEG.data(electrode,:,triali)));</span><br><span class="line">end</span><br><span class="line">filter_result = mean(abs(filter_result.^2),1);</span><br><span class="line">%% the short-time FFT</span><br><span class="line">timewin = 400;      % in ms</span><br><span class="line">timewinidx = round(EEG.srate*timewin/1000);</span><br><span class="line"></span><br><span class="line">% create hann taper</span><br><span class="line">hann_win = .5*(1-cos(2*pi*(0:timewinidx-1)/(timewinidx-1)));</span><br><span class="line"></span><br><span class="line">% define frequencies</span><br><span class="line">frex = linspace(0,EEG.srate/2,floor(timewinidx/2)+1);</span><br><span class="line"></span><br><span class="line">% initialize power output matrix</span><br><span class="line">tf = zeros(length(frex),length(times2save));</span><br><span class="line"></span><br><span class="line">% loop over time points and perform FFT</span><br><span class="line">for timepointi=1:length(times2save)</span><br><span class="line">    </span><br><span class="line">    % extract time series data for this center time point</span><br><span class="line">    tempdat = squeeze(EEG.data(electrode,times2saveidx(timepointi)-floor(timewinidx/2):times2saveidx(timepointi)+floor(timewinidx/2)-mod(timewinidx+1,2),:)); % note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span><br><span class="line">    </span><br><span class="line">    % taper data (using bsxfun instead of repmat... note sizes of tempdat</span><br><span class="line">    % and hann_win)</span><br><span class="line">    taperdat = bsxfun(@times,tempdat,hann_win&#x27;);</span><br><span class="line">    </span><br><span class="line">    fdat = fft(taperdat,[],1)/timewinidx; % 3rd input is to make sure fft is over time</span><br><span class="line">    tf(:,timepointi) = mean(abs(fdat(1:floor(timewinidx/2)+1,:)).^2,2); % average over trials</span><br><span class="line">end</span><br><span class="line">[junk,frequencyidx]=min(abs(frex-frequency));</span><br><span class="line">%% plot</span><br><span class="line">figure</span><br><span class="line">plot(times2save,tf(frequencyidx,:)./(max(tf(frequencyidx,:))),&#x27;b&#x27;,&#x27;LineWidth&#x27;,1)</span><br><span class="line">hold on</span><br><span class="line">plot(times2save,convolution_result_fft(times2saveidx)./(max(convolution_result_fft(times2saveidx))),&#x27;Color&#x27;,[0 0.8 0],&#x27;LineWidth&#x27;,1)</span><br><span class="line">plot(times2save,filter_result(times2saveidx)./(max(filter_result(times2saveidx))),&#x27;r&#x27;,&#x27;LineWidth&#x27;,1)</span><br><span class="line">legend(&#x27;Short-Time FFT&#x27;,&#x27;complex wavelet&#x27;,&#x27;Hilbert-filter&#x27;)</span><br><span class="line">set(gca,&#x27;ylim&#x27;,[0.2,1.3]) </span><br><span class="line">colormap parula</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/01/fyXaesRPZCNb8lh.png" alt="Ex_15(2)" style="zoom:67%;" /></p>
<hr>
<h1 id="Exercises-16-Multitaper"><a href="#Exercises-16-Multitaper" class="headerlink" title="Exercises 16 | Multitaper"></a>Exercises 16 | Multitaper</h1><ol>
<li><p>Pick one electrode and compute a time-frequency map of power using both the multitaper method and the short-time FFT. Store all of the power values for all of the trials.</p>
</li>
<li><p>Next, compute a time-frequency map of signal-to-noise ratio. The signal-to-noise ratio of power is discussed more in chapter 18, but it can be estimated as the average power at each time-frequency point across trials, divided by the standard deviation of power at each time-frequency point across trials. </p>
</li>
<li>Make time-frequency plots of power and signal-to-noise ratio from the two methods. Make another plot in which you subtract the signal-to-noise plots between the two methods. Are there any noticeable differences between the signal-to-noise results when the multitaper method versus the short-time FFT is used? </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick one electrode and compute a time-frequency map of power using both the multitaper method and the short-time FFT.</span></span><br><span class="line">load sampleEEGdata</span><br><span class="line"></span><br><span class="line">channel2plot = <span class="string">&#x27;p7&#x27;</span>;</span><br><span class="line">channel2plotidx = strcmpi(channel2plot,&#123;EEG.chanlocs.labels&#125;);</span><br><span class="line"></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">50</span>:<span class="number">1000</span>; <span class="comment">% in ms</span></span><br><span class="line"><span class="comment">% convert from ms to index</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [~,times2saveidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">baseline_range  = [<span class="number">-200</span> <span class="number">-00</span>];</span><br><span class="line"><span class="comment">% find baselinetimepoints</span></span><br><span class="line">baseidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(baseline_range));</span><br><span class="line">[~,baseidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-baseline_range(<span class="number">1</span>)));</span><br><span class="line">[~,baseidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-baseline_range(<span class="number">2</span>)));</span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% multitaper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 参数设置</span></span><br><span class="line">N = timewinidx; <span class="comment">% 样本点数</span></span><br><span class="line">W = <span class="number">4</span>;    <span class="comment">% 频带宽度</span></span><br><span class="line">Fs = EEG.srate; <span class="comment">% 采样率</span></span><br><span class="line">NW = N * (W / (Fs/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成tapers</span></span><br><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择特征值大于0.9的tapers</span></span><br><span class="line">tapersToUse = tapers(:, eigenvalues &gt; <span class="number">0.9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize output matrix</span></span><br><span class="line">multitaper_tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials,<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop through time bins</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)  <span class="comment">% 对应一个时间点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% initialize power vector (over tapers)</span></span><br><span class="line">    <span class="comment">% 一个时间点处各频率的功率值，对应tf图上与时间轴垂直的一条线段</span></span><br><span class="line">    taperpow = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% loop through tapers</span></span><br><span class="line">    <span class="keyword">for</span> tapi = <span class="number">1</span>:<span class="built_in">size</span>(tapersToUse,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">        tempdat = <span class="built_in">squeeze</span>(EEG.data(channel2plotidx,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">        data      = <span class="built_in">bsxfun</span>(@times,tempdat,tapersToUse(:,tapi));</span><br><span class="line"></span><br><span class="line">        <span class="comment">% timewindow截取、taper两端减弱后的数据进行Fourier变换，提取特定频率的功率值</span></span><br><span class="line">        pow       = fft(data,timewinidx)/timewinidx;</span><br><span class="line">        pow       = pow(<span class="number">1</span>:<span class="built_in">length</span>(frex),:);</span><br><span class="line">        taperpow  = taperpow + pow.*<span class="built_in">conj</span>(pow);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% finally, get power from closest frequency</span></span><br><span class="line">    multitaper_tf(:,:,timepointi) = taperpow/tapi;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% the short-time FFT</span></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">fft_tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials,<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">    tempdat = <span class="built_in">squeeze</span>(EEG.data(channel2plotidx,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">    <span class="comment">% and hann_win)</span></span><br><span class="line">    taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">    </span><br><span class="line">    fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">    fft_tf(:,:,timepointi) =<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>; <span class="comment">% average over trials</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% compute a time-frequency map of signal-to-noise ratio.</span></span><br><span class="line">multitaper_mean = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(multitaper_tf,<span class="number">2</span>));</span><br><span class="line">fft_mean = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(fft_tf,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">multitaper_std = <span class="built_in">squeeze</span>(std(multitaper_tf,[],<span class="number">2</span>));</span><br><span class="line">fft_std = <span class="built_in">squeeze</span>(std(fft_tf,[],<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">snr_multitaper = multitaper_mean ./ multitaper_std;</span><br><span class="line">snr_fft = fft_mean ./ fft_std;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="comment">% db-correct</span></span><br><span class="line">db_multitaper_tf = <span class="number">10</span>*<span class="built_in">log10</span>( multitaper_mean ./ <span class="built_in">repmat</span>(<span class="built_in">mean</span>(multitaper_mean(:,baseidx(<span class="number">1</span>):baseidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">length</span>(times2save)) );</span><br><span class="line"><span class="comment">% db-correct</span></span><br><span class="line">db_fft_tf = <span class="number">10</span>*<span class="built_in">log10</span>( fft_mean ./ <span class="built_in">repmat</span>(<span class="built_in">mean</span>(fft_mean(:,baseidx(<span class="number">1</span>):baseidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">length</span>(times2save)) );</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">colormap jet</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">contourf(times2save,frex,db_multitaper_tf,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;Power of Multitaper&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">contourf(times2save,frex,db_fft_tf,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;Power of FFT&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">contourf(times2save,frex,snr_multitaper,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0.4</span> <span class="number">1.6</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;SNR of Multitaper&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">contourf(times2save,frex,snr_fft,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0.4</span> <span class="number">1.6</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;SNR of FFT&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">colormap jet</span><br><span class="line">contourf(times2save,frex,snr_multitaper-snr_fft,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">colorbar</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-0.2</span> <span class="number">1.2</span>])</span><br><span class="line">title(<span class="string">&#x27;SNR_&#123;Multipaper&#125; minus SNR_&#123;FFT&#125;&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/02/K3nNI58gTucP7Xj.png" alt="Ex_16(1)" style="zoom: 50%;" /></p>
<p><img src="https://s2.loli.net/2024/09/02/acKXeDqzrPkFV16.png" alt="Ex_16(2)" style="zoom:50%;" /></p>
<ol>
<li>Select two frequencies, one relatively low and one relatively high (e.g., 8 Hz and 60 Hz), and compare the power time series and signal-to-noise time series in these frequency bands from the two methods in a separate figure, using line plots. Comment on the differences if there are any. </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select two frequencies, one relatively low and one relatively high (e.g., 8 Hz and 60 Hz), </span></span><br><span class="line"><span class="comment">% and compare the power time series and signal-to-noise time series in these frequency bands </span></span><br><span class="line"><span class="comment">% from the two methods in a separate figure, using line plots.</span></span><br><span class="line">frequncies = [<span class="number">8</span>, <span class="number">60</span>];</span><br><span class="line">frequnciesidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(frequncies));</span><br><span class="line">[~,frequnciesidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequncies(<span class="number">1</span>)));</span><br><span class="line">[~,frequnciesidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequncies(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frequncies)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save,db_multitaper_tf(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    title([<span class="string">&#x27;Frequency: &#x27;</span> num2str(frequncies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz, Power&#x27;</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Power (dB)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save,db_fft_tf(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;Multitaper&#x27;</span>,<span class="string">&#x27;FFT&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save,snr_multitaper(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    title([<span class="string">&#x27;Frequency: &#x27;</span> num2str(frequncies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz, SNR&#x27;</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;SNR&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save,snr_fft(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;Multitaper&#x27;</span>,<span class="string">&#x27;FFT&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="D:/Desktop/Analyzing%20Neural%20Time%20Series%20Data_%20Theory%20and%20Practice/MyMatlabCode/Ex_16/Ex_16(3).png" alt="Ex_16(3)" style="zoom:50%;" /></p>
<ul>
<li>Multitaper常用于低信噪比的情况，如高频活动或功率的单试次估计。通过使用多个taper，multitaper方法在频率轴上引入了一定的<strong>平滑效应</strong>。这种平滑可以减少频率分辨率的精细度，使得<strong>频谱变得更加连续和平滑</strong>。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://yuxii.top">Icarus</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yuxii.top/post/c9dcd3t1.html">http://yuxii.top/post/c9dcd3t1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yuxii.top" target="_blank">Icarus</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Analyzing-Neural-Time-Series-Data/">Analyzing Neural Time Series Data</a></div><div class="post_share"><div class="social-share" data-image="https://images2.alphacoders.com/907/907164.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/c9dcd8c4.html"><img class="prev-cover" src="https://images2.alphacoders.com/907/907164.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Part 4 Spatial Filters | Analyzing Neural Time Series Data</div></div></a></div><div class="next-post pull-right"><a href="/post/c9dcd8c3.html"><img class="next-cover" src="https://images2.alphacoders.com/907/907164.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Part 3 Frequency and Time-Frequency Domains Analyses | Analyzing Neural Time Series Data</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/c9dcc4d9.html" title="Exercises Part 1 | Analyzing Neural Time Series Data"><img class="cover" src="https://images2.alphacoders.com/907/907164.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="title">Exercises Part 1 | Analyzing Neural Time Series Data</div></div></a></div><div><a href="/post/c9dcd3o1.html" title="Exercises Part 2 | Analyzing Neural Time Series Data"><img class="cover" src="https://images2.alphacoders.com/907/907164.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-16</div><div class="title">Exercises Part 2 | Analyzing Neural Time Series Data</div></div></a></div><div><a href="/post/c9der4c1.html" title="Part 1 Introduction | Analyzing Neural Time Series Data"><img class="cover" src="https://images2.alphacoders.com/907/907164.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-25</div><div class="title">Part 1 Introduction | Analyzing Neural Time Series Data</div></div></a></div><div><a href="/post/c9dcd3c2.html" title="Part 2 Preprocessing and Time-Domain Analyses | Analyzing Neural Time Series Data"><img class="cover" src="https://images2.alphacoders.com/907/907164.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-10</div><div class="title">Part 2 Preprocessing and Time-Domain Analyses | Analyzing Neural Time Series Data</div></div></a></div><div><a href="/post/c9dcd8c3.html" title="Part 3 Frequency and Time-Frequency Domains Analyses | Analyzing Neural Time Series Data"><img class="cover" src="https://images2.alphacoders.com/907/907164.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-16</div><div class="title">Part 3 Frequency and Time-Frequency Domains Analyses | Analyzing Neural Time Series Data</div></div></a></div><div><a href="/post/c9dcd8c4.html" title="Part 4 Spatial Filters | Analyzing Neural Time Series Data"><img class="cover" src="https://images2.alphacoders.com/907/907164.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-01</div><div class="title">Part 4 Spatial Filters | Analyzing Neural Time Series Data</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercises-10-Convolution"><span class="toc-number">1.</span> <span class="toc-text">Exercises 10 | Convolution</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-1"><span class="toc-number">1.1.</span> <span class="toc-text">10.6.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-2"><span class="toc-number">1.2.</span> <span class="toc-text">10.6.2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercises-11-Fourier-Transform"><span class="toc-number">2.</span> <span class="toc-text">Exercises 11 | Fourier Transform</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-12-1"><span class="toc-number">2.1.</span> <span class="toc-text">11.12.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-12-2"><span class="toc-number">2.2.</span> <span class="toc-text">11.12.2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-12-3"><span class="toc-number">2.3.</span> <span class="toc-text">11.12.3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercises-12-Morlet-wavelets"><span class="toc-number">3.</span> <span class="toc-text">Exercises 12 | Morlet wavelets</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercises-13-complex-Morlet-wavelets"><span class="toc-number">4.</span> <span class="toc-text">Exercises 13 | complex Morlet wavelets</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Create-a-family-of-complex-Morlet-wavelets"><span class="toc-number">4.1.</span> <span class="toc-text">1. Create a family of complex Morlet wavelets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Convolve-each-wavelet-with-EEG-data"><span class="toc-number">4.2.</span> <span class="toc-text">2. Convolve each wavelet with EEG data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Extract-power-and-phase"><span class="toc-number">4.3.</span> <span class="toc-text">3. Extract power and phase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Make-topographical-plots-of-power-and-phase"><span class="toc-number">4.4.</span> <span class="toc-text">4. Make topographical plots of power and phase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Repeat-step-4-for-activity-at-360-ms"><span class="toc-number">4.5.</span> <span class="toc-text">5. Repeat step 4 for activity at 360 ms.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Think"><span class="toc-number">4.6.</span> <span class="toc-text">6. Think</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures"><span class="toc-number">4.6.0.1.</span> <span class="toc-text">(From ChatGPT for reference, GPT is not provided with corresponding pictures)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Are-there-any-prominent-topographical-features-in-power-or-in-phase"><span class="toc-number">4.6.0.2.</span> <span class="toc-text">(1) Are there any prominent topographical features in power or in phase?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Do-these-differ-for-different-frequencies"><span class="toc-number">4.6.0.3.</span> <span class="toc-text">(2) Do these differ for different frequencies?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Do-power-and-phase-have-similar-topographical-distributions"><span class="toc-number">4.6.0.4.</span> <span class="toc-text">(3) Do power and phase have similar topographical distributions?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies"><span class="toc-number">4.6.0.5.</span> <span class="toc-text">(4) Is there any reason to suspect that they might have similar or different topographies?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Summary"><span class="toc-number">4.6.0.6.</span> <span class="toc-text">Summary:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Create-a-circular-colormap"><span class="toc-number">4.7.</span> <span class="toc-text">7.  Create a circular colormap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercises-14-filter-Hilbert"><span class="toc-number">5.</span> <span class="toc-text">Exercises 14 | filter-Hilbert</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercises-15"><span class="toc-number">6.</span> <span class="toc-text">Exercises 15</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exercises-16-Multitaper"><span class="toc-number">7.</span> <span class="toc-text">Exercises 16 | Multitaper</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Icarus</div><div class="footer_custom_text"><p> <a style="margin-inline:5px"target="_blank" href="https://hexo.io/"> <img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"> </a> <a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"> <img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"> </a> <a style="margin-inline:5px"target="_blank" href="https://github.com/"> <img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"> </a> <a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"> <img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"> </a> </p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>