<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Exercises | Analyzing Neural Time Series Data | Icarus</title><meta name="author" content="Icarus"><meta name="copyright" content="Icarus"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Part 14.7 Exercise4.7.1 Exercises for Script A Create a 4 × 8 matrix of randomly generated numbers.   Loop through all rows and columns, and test whether each element is greater than 0.5.   Report the">
<meta property="og:type" content="article">
<meta property="og:title" content="Exercises | Analyzing Neural Time Series Data">
<meta property="og:url" content="http://yuxii.top/post/c9dcc4e1.html">
<meta property="og:site_name" content="Icarus">
<meta property="og:description" content="Part 14.7 Exercise4.7.1 Exercises for Script A Create a 4 × 8 matrix of randomly generated numbers.   Loop through all rows and columns, and test whether each element is greater than 0.5.   Report the">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images2.alphacoders.com/907/907164.jpg">
<meta property="article:published_time" content="2024-10-15T01:00:16.636Z">
<meta property="article:modified_time" content="2024-10-15T01:10:28.615Z">
<meta property="article:author" content="Icarus">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images2.alphacoders.com/907/907164.jpg"><link rel="shortcut icon" href="/img/cat_icon.png"><link rel="canonical" href="http://yuxii.top/post/c9dcc4e1"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Exercises | Analyzing Neural Time Series Data',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-15 09:10:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Icarus" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/howl.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Icarus</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Exercises | Analyzing Neural Time Series Data</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-10-15T01:00:16.636Z" title="发表于 2024-10-15 09:00:16">2024-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Analyzing-Neural-Time-Series-Data/">Analyzing Neural Time Series Data</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>85分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Exercises | Analyzing Neural Time Series Data"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="4-7-Exercise"><a href="#4-7-Exercise" class="headerlink" title="4.7 Exercise"></a>4.7 Exercise</h2><h3 id="4-7-1-Exercises-for-Script-A"><a href="#4-7-1-Exercises-for-Script-A" class="headerlink" title="4.7.1 Exercises for Script A"></a><strong>4.7.1 Exercises for Script A</strong></h3><ol>
<li><p>Create a 4 × 8 matrix of randomly generated numbers. </p>
</li>
<li><p>Loop through all rows and columns, and test whether each element is greater than 0.5. </p>
</li>
<li><p>Report the results of the test along with the value of the matrix element and its row-column position. For example, your Matlab script should print The 3rd row and 8th column has a value of 0.42345 and is not bigger than 0.5 . </p>
</li>
<li><p>Make sure to add exceptions to print out 1st, 2nd, and 3rd, instead of 1th, 2th, and 3th. </p>
</li>
<li><p>Put this code into a separate function that you can call from the command line with two inputs, corresponding to the number of rows and the number of columns of the matrix. </p>
</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.1 Exercises for Script A</span></span><br><span class="line">matA = GreaterThanPointFive(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成一个 rowx × colx 的0~1随机数矩阵，并输出各行各列上的元素及其与0.5的大小关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matx</span> = <span class="title">GreaterThanPointFive</span><span class="params">(rowx, colx)</span></span></span><br><span class="line">    matx = <span class="built_in">rand</span>(rowx,colx);</span><br><span class="line">    NoString = [<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;st&#x27;</span>;<span class="string">&#x27;nd&#x27;</span>;<span class="string">&#x27;rd&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>;<span class="string">&#x27;th&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> rowi = <span class="number">1</span>:rowx</span><br><span class="line">        <span class="keyword">for</span> coli = <span class="number">1</span>:colx</span><br><span class="line">            <span class="keyword">if</span> matx(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">disp</span>([ <span class="string">&#x27;The &#x27;</span> num2str(rowi) NoString(<span class="built_in">mod</span>(rowi,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; row and &#x27;</span> num2str(coli) NoString(<span class="built_in">mod</span>(coli,<span class="number">10</span>)+<span class="number">1</span>,:) <span class="string">&#x27; column has a value of &#x27;</span> num2str(matx(rowi,coli)) <span class="string">&#x27; and is not bigger than 0.5&#x27;</span>]);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="4-7-2-Exercises-for-Script-B"><a href="#4-7-2-Exercises-for-Script-B" class="headerlink" title="4.7.2 Exercises for Script B"></a><strong>4.7.2 Exercises for Script B</strong></h3><ol>
<li><p>Import and plot the picture of Amsterdam that comes with the online Matlab code. </p>
</li>
<li><p>On top of the picture, plot a thick red line from “ Nieuwmarkt ” (near the center of the picture) to “ Station Amsterdam Centraal ” (near the top of the picture). </p>
</li>
<li><p>Plot a magenta star over the Waterlooplein metro station (a bit South of Nieuwmarkt). </p>
</li>
<li><p>Find the maximum value on each color dimension (red, green, or blue) and plot a circle using that color. There may be more than one pixel with a maximum value; if so, pick one pixel at random. </p>
</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"><span class="comment">%% 4.7.2 Exercises for Script B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 6. Import and plot picture</span></span><br><span class="line">amsterdamImg = imread(<span class="string">&quot;amsterdam.bmp&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">imagesc(amsterdamImg);</span><br><span class="line">axis image</span><br><span class="line">axis on</span><br><span class="line">grid on</span><br><span class="line">grid minor</span><br><span class="line"></span><br><span class="line"><span class="comment">% 7. plot a thick red line</span></span><br><span class="line">line([<span class="number">367</span>,<span class="number">395</span>],[<span class="number">325</span>,<span class="number">75</span>],<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 8. plot a magenta star</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">375</span>,<span class="number">490</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 9.find maximum value on each color dimension and plot a circle using it</span></span><br><span class="line"><span class="comment">% 分别提取RGB数值</span></span><br><span class="line">R = amsterdamImg(:,:,<span class="number">1</span>);</span><br><span class="line">G = amsterdamImg(:,:,<span class="number">2</span>);</span><br><span class="line">B = amsterdamImg(:,:,<span class="number">3</span>);</span><br><span class="line"><span class="comment">% 找到最大的RGB值</span></span><br><span class="line">R_max = <span class="built_in">max</span>(R);</span><br><span class="line">G_max = <span class="built_in">max</span>(G);</span><br><span class="line">B_max = <span class="built_in">max</span>(B);</span><br><span class="line"><span class="comment">% 找到最大值所在位置</span></span><br><span class="line">[R_maxRow, R_maxCol] = <span class="built_in">find</span>(R==R_max);</span><br><span class="line">[G_maxRow, G_maxCol] = <span class="built_in">find</span>(G==G_max);</span><br><span class="line">[B_maxRow, B_maxCol] = <span class="built_in">find</span>(B==B_max);</span><br><span class="line"><span class="comment">% 随机选择一个索引</span></span><br><span class="line">R_idx = randi(<span class="built_in">length</span>(R_maxRow));</span><br><span class="line">G_idx = randi(<span class="built_in">length</span>(G_maxRow));</span><br><span class="line">B_idx = randi(<span class="built_in">length</span>(B_maxRow));</span><br><span class="line"><span class="comment">% 获取坐标</span></span><br><span class="line">R_position = [R_maxRow(R_idx), R_maxCol(R_idx)];</span><br><span class="line">G_position = [G_maxCol(G_idx), G_maxCol(G_idx)];</span><br><span class="line">B_position = [B_maxCol(B_idx), B_maxCol(B_idx)];</span><br><span class="line"><span class="comment">% 在图像上最大值位置绘制圆圈</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(R_position(<span class="number">1</span>),R_position(<span class="number">2</span>),<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(G_position(<span class="number">1</span>),G_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">plot</span>(B_position(<span class="number">1</span>),B_position(<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;MarkerFaceColor&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/10/15/JNc7oOSmMaQD5fC.png" alt="image-20240814164819625" style="zoom:67%;" /></p>
<h3 id="4-7-3-Exercises-for-Script-C"><a href="#4-7-3-Exercises-for-Script-C" class="headerlink" title="4.7.3 Exercises for Script C"></a><strong>4.7.3 Exercises for Script C</strong></h3><ol>
<li><p>From the function you wrote for exercise 5, generate a 32 × 3 number matrix in which the three numbers in each row correspond to the row, column, and result of the test (1 for bigger than 0.5; 0 for smaller than 0.5). </p>
</li>
<li><p>Write this 32 × 3 matrix to a text file that contains this matrix along with appropriate variable labels in the first row. Make sure this file is tab-delimited and readable by a spreadsheet software such as Microsoft Excel or Open Office Calc. </p>
</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 运行该代码前请先运行Exercise_04_A</span></span><br><span class="line"></span><br><span class="line">matC = NaN(<span class="number">32</span>,<span class="number">3</span>);   <span class="comment">% 第一、二列为matA的行、列坐标，第三列为该坐标上的元素是否大于0.5</span></span><br><span class="line">countRowi = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rowi = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> coli = <span class="number">1</span>:<span class="built_in">size</span>(matA,<span class="number">2</span>)</span><br><span class="line">        matC(countRowi,<span class="number">1</span>) = rowi;</span><br><span class="line">        matC(countRowi,<span class="number">2</span>) = coli;</span><br><span class="line">        <span class="keyword">if</span> matA(rowi,coli) &gt; <span class="number">0.5</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            matC(countRowi,<span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        countRowi = countRowi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 将matC写入txt文件</span></span><br><span class="line">fileC = fopen(<span class="string">&#x27;data_output_04C.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% variable labels</span></span><br><span class="line">variable_labels = &#123;<span class="string">&#x27;row&#x27;</span>;<span class="string">&#x27;column&#x27;</span>;<span class="string">&#x27;result&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">% 写入第一行变量名</span></span><br><span class="line"><span class="keyword">for</span> vari=<span class="number">1</span>:<span class="built_in">length</span>(variable_labels)</span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;%s\t&#x27;</span>,variable_labels&#123;vari&#125;);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 换行</span></span><br><span class="line">fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> datarowi=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> columni=<span class="number">1</span>:<span class="built_in">size</span>(matC,<span class="number">2</span>)</span><br><span class="line">        fprintf(fileC,<span class="string">&#x27;%g\t&#x27;</span>,matC(datarowi,columni));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(fileC,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fclose(fileC);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h1><h2 id="9-8-Exercise"><a href="#9-8-Exercise" class="headerlink" title="9.8 Exercise"></a>9.8 Exercise</h2><h3 id="9-8-1"><a href="#9-8-1" class="headerlink" title="9.8.1"></a>9.8.1</h3><p>Compute the ERP at each electrode. Select five time points at which to show topographical plots (e.g., 0 to 400 ms in 100-ms steps). In one figure, make a series of topographical plots  at these time points. To increase the signal-to-noise ratio, make each plot show the average of activity from 20 ms before until 20 ms after each time point. For example, the topographical  plot from 200 ms should show average activity from 180 ms until 220 ms. Indicate the center  time point in a title on each subplot. </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex_09 (1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% load EEG data</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% Compute the ERP at each electrode</span></span><br><span class="line">ERP = <span class="built_in">zeros</span>(EEG.nbchan, EEG.pnts);</span><br><span class="line"><span class="keyword">for</span> electrode_i = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    ERP(electrode_i,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(electrode_i,:,:),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% select 5 time points (0 to 400ms in 100-ms steps) </span></span><br><span class="line"><span class="comment">% and plot topographical Maps</span></span><br><span class="line">dt = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="keyword">for</span> timei=<span class="number">0</span>:<span class="number">100</span>:<span class="number">400</span></span><br><span class="line">    <span class="comment">% Each point show the average of activity from 20ms before until 20ms</span></span><br><span class="line">    <span class="comment">% after each point</span></span><br><span class="line">    TimeSpani = <span class="built_in">find</span>(EEG.times &gt;= timei-dt &amp; EEG.times &lt;= timei+dt);</span><br><span class="line">    MeanEEG = <span class="built_in">mean</span>(EEG.data(:,TimeSpani,:),<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% topographical plots</span></span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">2</span>,timei/<span class="number">100</span>+<span class="number">1</span>);</span><br><span class="line">    c = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(MeanEEG(:,:,:),<span class="number">3</span>));</span><br><span class="line">    topoplot(double(c),EEG.chanlocs,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="number">-10</span>,<span class="number">10</span>]);   <span class="comment">% 统一各subplot的colorbar</span></span><br><span class="line">    title([<span class="string">&#x27;ERP around &#x27;</span> num2str(timei) <span class="string">&#x27;ms&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">    colormap jet</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot colorbar</span></span><br><span class="line">ax6 = subplot(<span class="number">326</span>);</span><br><span class="line">axis off</span><br><span class="line">cb = colorbar;</span><br><span class="line">set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="number">-10</span>,<span class="number">10</span>]);</span><br><span class="line">cb.Position(<span class="number">1</span>) = ax6.Position(<span class="number">1</span>);</span><br><span class="line">cb.Position(<span class="number">2</span>) = ax6.Position(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/10/15/MCiH8hZkGxcRSoe.png" alt="Ex09(1)" style="zoom:67%;" /></p>
<h3 id="9-8-2"><a href="#9-8-2" class="headerlink" title="9.8.2"></a>9.8.2</h3><p>Loop through each electrode and find the peak time of the ERP between 100 and 400 ms. Store these peak times in a separate variable and then make a topographical plot of the peak times (that is, the topographical map will illustrate times in milliseconds, not activity at peak times). Include a color bar in the figure and make sure to show times in milliseconds from time 0 (not, for example, time in milliseconds since 100 ms or indices instead of milliseconds). What areas of the scalp show the earliest and the latest peak responses to the stimulus within this window?</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex_09 (2)</span></span><br><span class="line"></span><br><span class="line">PeakTimes = <span class="built_in">zeros</span>(EEG.nbchan,<span class="number">1</span>);      <span class="comment">% the peak time of the ERP between 100 and 400ms (in ms)</span></span><br><span class="line">PeakTimedx = <span class="built_in">zeros</span>(EEG.nbchan,<span class="number">1</span>);      <span class="comment">% peak time index of each channel</span></span><br><span class="line">Timedx = <span class="built_in">find</span>(EEG.times &gt;= <span class="number">100</span> &amp; EEG.times &lt;= <span class="number">400</span>);     <span class="comment">% index of 100~400ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% find ERP peak times</span></span><br><span class="line"><span class="keyword">for</span> electrode_i = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    PeakTimedx(electrode_i) = Timedx(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> timespani = <span class="number">1</span>:<span class="built_in">length</span>(Timedx)</span><br><span class="line">        <span class="keyword">if</span> ERP(electrode_i,Timedx(timespani)) &gt; ERP(electrode_i,PeakTimedx(electrode_i))</span><br><span class="line">            PeakTimedx(electrode_i) = Timedx(timespani);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    PeakTimes(electrode_i) = EEG.times(PeakTimedx(electrode_i));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot a topographical plot of peak times</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">topoplot(PeakTimes,EEG.chanlocs,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">colormap jet</span><br><span class="line">set(gca,<span class="string">&#x27;Clim&#x27;</span>,[<span class="built_in">min</span>(PeakTimes) <span class="built_in">max</span>(PeakTimes)]);</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;ERP peak times between 100 and 400 ms&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/10/15/Ntai3rTk7wF2yCe.png" alt="EX09(2)" style="zoom:67%;" /></p>
<hr>
<h1 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h1><h2 id="Exercises-10-Convolution"><a href="#Exercises-10-Convolution" class="headerlink" title="Exercises 10 | Convolution"></a>Exercises 10 | Convolution</h2><h3 id="10-6-1"><a href="#10-6-1" class="headerlink" title="10.6.1"></a>10.6.1</h3><ol>
<li>Create two kernels for convolution: one that looks like a U and one that looks like a decay function. There is no need to be too sophisticated in generating, for example, a Gaussian and an exponential; numerical approximations are fine.</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 10</span></span><br><span class="line"><span class="comment">% 1. Create two kernels </span></span><br><span class="line">kernel_U = [<span class="number">1</span> <span class="number">0.8</span> <span class="number">0.3</span> <span class="number">0.1</span> <span class="number">0</span> <span class="number">0.1</span> <span class="number">0.3</span> <span class="number">0.8</span> <span class="number">1</span>];</span><br><span class="line">kernel_decay = [<span class="number">1</span> <span class="number">0.9</span> <span class="number">0.8</span> <span class="number">0.7</span> <span class="number">0.5</span> <span class="number">0.3</span> <span class="number">0.2</span> <span class="number">0.1</span> <span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h3 id="10-6-2"><a href="#10-6-2" class="headerlink" title="10.6.2"></a>10.6.2</h3><ol>
<li>Convolve these two kernels with 50 time points of EEG data from one electrode. Make a plot showing the kernels, the EEG data, and the result of the convolution between the data and each kernel. Use time-domain convolution as explained in this chapter and as illustrated in the online Matlab code. Based on visual inspection, what is the effect of convolving the EEG data with these two kernels?</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2</span></span><br><span class="line"><span class="comment">% Snippet of EEG data</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">impEEG = EEG.data(<span class="number">47</span>,<span class="number">100</span>:<span class="number">149</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用自编函数计算impEEG与kernel_U的convolution</span></span><br><span class="line"><span class="comment">% data that we&#x27;ll use for convolution (must be zero-padded).</span></span><br><span class="line">dat4conv = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) impEEG <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>) ];</span><br><span class="line"></span><br><span class="line"><span class="comment">% used for cutting the result of convolution</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize convolution output</span></span><br><span class="line">convolution_result_U = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(impEEG)+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% run convolution (note that kernel is flipped backwards) ti以外的范围会被舍弃，没必要计算</span></span><br><span class="line"><span class="keyword">for</span> ti=half_of_kernel_size+<span class="number">1</span>:<span class="built_in">length</span>(convolution_result_U)-half_of_kernel_size         </span><br><span class="line">    convolution_result_U(ti) = sum(dat4conv(ti:ti+<span class="built_in">length</span>(kernel_U)<span class="number">-1</span>).*kernel_U(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_U = convolution_result_U(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用Matlab自带函数conv()计算impEEG与kernel_decay的convolution</span></span><br><span class="line">convolution_result_decay = conv(impEEG,kernel_decay,<span class="string">&#x27;same&#x27;</span>);    <span class="comment">%% &#x27;same&#x27;:conv的结果与impfun的长度相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot kernels</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">311</span>)</span><br><span class="line"><span class="built_in">plot</span>(kernel_U,<span class="string">&#x27;bo-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(kernel_decay,<span class="string">&#x27;ro-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;decay&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.84</span> <span class="number">0.13512</span> <span class="number">0.064683</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Points&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Convolution kernels&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot Snippet of EEG data</span></span><br><span class="line">subplot(<span class="number">312</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Snippet of EEG data (EEG.data(47,100:149,10))&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot EEG data before and after convolution</span></span><br><span class="line">subplot(<span class="number">313</span>)</span><br><span class="line"><span class="built_in">plot</span>(impEEG,<span class="string">&#x27;k-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_U./sum(kernel_U),<span class="string">&#x27;b-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(convolution_result_decay./sum(kernel_decay),<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;U-convolved&#x27;</span>,<span class="string">&#x27;decay-convolved&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,[<span class="number">0.65</span> <span class="number">0.245</span> <span class="number">0.2</span> <span class="number">0.09</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Time points&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Voltage \muV&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;EEG data before and after convolution&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/17/Id6gBtjlfc2LV1M.png" alt="Ex_10" style="zoom:67%;" /></p>
<hr>
<h2 id="Exercises-11-Fourier-Transform"><a href="#Exercises-11-Fourier-Transform" class="headerlink" title="Exercises 11 | Fourier Transform"></a>Exercises 11 | Fourier Transform</h2><h3 id="11-12-1"><a href="#11-12-1" class="headerlink" title="11.12.1"></a>11.12.1</h3><p>Reproduce the top three panels of figure 11.12 three times. </p>
<ul>
<li><p>First, perform time-domain convolution using <strong>the “ manual ” convolution method</strong> shown in chapter 10. </p>
</li>
<li><p>Second, perform frequency-domain convolution using <strong>the discrete time Fourier transform</strong> presented at the beginning of this chapter. </p>
</li>
<li>Finally, perform frequency-domain convolution using <strong>the Matlab functions fft and ifft</strong> (do not use the function conv). (You can optionally reproduce the bottom panel of figure 11.12 for the frequency domain analyses; keep in mind that the power scaling is for display purposes only.) </li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 1. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">    conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"><span class="comment">% Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    <span class="comment">% create sine wave</span></span><br><span class="line">    sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">    fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line"></span><br><span class="line"><span class="comment">% inverse Fourier transform</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">    sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">    conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line">conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,eegdat4convol);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_manual,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_Fourier,<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,conv_result_fft,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EEG data&#x27;</span>,<span class="string">&#x27;&quot;manual&quot; convolution method&#x27;</span>,<span class="string">&#x27;discrete time Fourier transform&#x27;</span>,<span class="string">&#x27;Matlab functions fft and ifft&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/dHleLSJOyTUR9xt.png" alt="Ex_11"></p>
<h3 id="11-12-2"><a href="#11-12-2" class="headerlink" title="11.12.2"></a>11.12.2</h3><p>From the three sets of Matlab code you have for reproducing figure 11.12 , run a computation time test. That is, time how long it takes Matlab to perform 1000 repetitions of each of the three methods for computing convolution that you generated in the previous exercise (do not plot the results each time). You can use the Matlab function pairs tic and toc to time a Matlab process. Plot the results in a bar plot, similar to figure 11.8 . </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"><span class="comment">% 2. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">eegdat4convol = <span class="built_in">squeeze</span>(EEG.data(<span class="number">47</span>,:,<span class="number">1</span>));</span><br><span class="line"><span class="comment">% create Gaussian</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">s = <span class="number">5</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">30</span>);</span><br><span class="line">gaussian = <span class="built_in">exp</span>((-time.^<span class="number">2</span>)/(<span class="number">2</span>*s^<span class="number">2</span>))/<span class="number">30</span>;</span><br><span class="line">t = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">%% (1) perform time-domain convolution using the &quot;manual&quot; convolution method</span></span><br><span class="line">longEEG = [<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>) eegdat4convol <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)];  <span class="comment">% 扩展eegdata左右两边的长度</span></span><br><span class="line">half_of_kernel_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(gaussian)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">conv_result_manual = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(eegdat4convol)+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> ti = half_of_kernel_size+<span class="number">1</span> : <span class="built_in">length</span>(conv_result_manual)-half_of_kernel_size</span><br><span class="line">        conv_result_manual(ti) = sum(longEEG(ti:ti+<span class="built_in">length</span>(gaussian)<span class="number">-1</span>).*gaussian(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_manual = conv_result_manual(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">1</span>) = toc;</span><br><span class="line"><span class="comment">%% (2) perform frequency-domain convolution using the discrete time Fourier transform</span></span><br><span class="line"><span class="comment">% 对EEG信号和kernal(Gaussian)进行延长，保证Fourier变换时二者长度一致</span></span><br><span class="line">padding_length = <span class="built_in">length</span>(eegdat4convol) + <span class="built_in">length</span>(gaussian) - <span class="number">1</span>;</span><br><span class="line">EEG_padded = [eegdat4convol, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(eegdat4convol))];</span><br><span class="line">Gaussian_padded = [gaussian, <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length-<span class="built_in">length</span>(gaussian))];</span><br><span class="line">fourier_eeg = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">fourier_gaussian = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line">conv_result_Fourier = <span class="built_in">zeros</span>(<span class="number">1</span>,padding_length);</span><br><span class="line"></span><br><span class="line">time_fourier = (<span class="number">0</span>:padding_length<span class="number">-1</span>)/padding_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    <span class="comment">% Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        <span class="comment">% create sine wave</span></span><br><span class="line">        sine_wave  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        fourier_eeg(fi) = sum(sine_wave.*EEG_padded);</span><br><span class="line">        fourier_gaussian(fi) = sum(sine_wave.*Gaussian_padded);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fourier_result = fourier_eeg .* fourier_gaussian;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% inverse Fourier transform</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:padding_length</span><br><span class="line">        sine_wave = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*(fi<span class="number">-1</span>).*time_fourier);</span><br><span class="line">        conv_result_Fourier(fi) = sum(fourier_result.*sine_wave);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    conv_result_Fourier = <span class="built_in">real</span>(conv_result_Fourier(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size))./padding_length;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">2</span>) = toc;</span><br><span class="line"><span class="comment">%% (3) perform frequency-domain convolution using the Matlab functions fft and ifft</span></span><br><span class="line"><span class="comment">% repeat 1000 times</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">    conv_result_fft = ifft(fft(EEG_padded) .* fft(Gaussian_padded));</span><br><span class="line">    conv_result_fft = conv_result_fft(half_of_kernel_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_kernel_size);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t(<span class="number">3</span>) = toc;</span><br><span class="line"><span class="comment">%% plot results in a bar plot</span></span><br><span class="line">b = bar(t);</span><br><span class="line">labels = string(b(<span class="number">1</span>).YData);</span><br><span class="line">text(b(<span class="number">1</span>).XEndPoints,b(<span class="number">1</span>).YEndPoints,labels,<span class="string">&#x27;HorizontalAlignment&#x27;</span>,<span class="string">&#x27;center&#x27;</span>,<span class="string">&#x27;VerticalAlignment&#x27;</span>,<span class="string">&#x27;top&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>])</span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,&#123;<span class="string">&#x27;manual convolution&#x27;</span>;<span class="string">&#x27;DTFT&amp;IDTFT&#x27;</span>;<span class="string">&#x27;FFT&amp;IFFt&#x27;</span>&#125;)</span><br><span class="line">set(gca, <span class="string">&#x27;YScale&#x27;</span>, <span class="string">&#x27;log&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;time(s)&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/391pAN7iXbJEkdl.png" alt="Ex_11(2)" style="zoom: 50%;" /></p>
<h3 id="11-12-3"><a href="#11-12-3" class="headerlink" title="11.12.3"></a>11.12.3</h3><p>Generate a time series by creating and summing sine waves, as in figure 11.2B . Use between two and four sine waves, so that the individual sine waves are still somewhat visible in the sum. Perform a Fourier analysis (you can use the fft function) on the resulting time series and plot the power structure. Confirm that your code is correct by comparing the frequencies with nonzero power to the frequencies of the sine waves that you generated. Now try adding random noise to the signal before computing the Fourier transform. First, add a small amount of noise so that the sine waves are still visually recognizable. Next, add a large amount of noise so that the sine waves are no longer visually recognizable in the time domain data. Perform a Fourier analysis on the two noisy signals and plot the results. What is the effect of a small and a large amount of noise in the power spectrum? Are the sine waves with noise easier to detect in the time domain or in the frequency domain, or is it equally easy/difficult to detect a sine wave in the presence of noise? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Create sine waves</span></span><br><span class="line">srate = <span class="number">400</span>;</span><br><span class="line">time=<span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">N = <span class="built_in">length</span>(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create three sine waves</span></span><br><span class="line">s1 = <span class="number">20</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">3</span>*time);</span><br><span class="line">s2 = <span class="number">10</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">8</span>*time);</span><br><span class="line">s3 = <span class="number">5</span>*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">15</span>*time);</span><br><span class="line">sum_Sine = s1+s2+s3;</span><br><span class="line"></span><br><span class="line"><span class="comment">% add random noise</span></span><br><span class="line">Sine_LitteNoise = sum_Sine + <span class="number">10</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line">Sine_LargeNoise = sum_Sine + <span class="number">40</span>*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">linspace</span>(<span class="number">0</span>,srate/<span class="number">2</span>,<span class="built_in">floor</span>(N/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = fft(sum_Sine)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LitteNoise = fft(Sine_LitteNoise)./(N/<span class="number">2</span>);</span><br><span class="line">FFT_LargeNoise = fft(Sine_LargeNoise)./(N/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">FFT_Sine = <span class="built_in">abs</span>(FFT_Sine(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LitteNoise = <span class="built_in">abs</span>(FFT_LitteNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line">FFT_LargeNoise = <span class="built_in">abs</span>(FFT_LargeNoise(<span class="number">1</span>:<span class="built_in">ceil</span>(N/<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(time,sum_Sine);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Original time series&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">bar(f,FFT_Sine);</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LitteNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">bar(f,FFT_LitteNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, small noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(time,Sine_LargeNoise)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(s)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Time series, large noise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>)</span><br><span class="line">bar(f,FFT_LargeNoise)</span><br><span class="line">set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">0</span>,<span class="number">20</span>],<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0</span>,<span class="number">25</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Power spectrum, large noise&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/I5wHdjzGkQmMDN6.png" alt="Ex_11(3)" style="zoom: 80%;" /></p>
<hr>
<h2 id="Exercises-12-Morlet-wavelets"><a href="#Exercises-12-Morlet-wavelets" class="headerlink" title="Exercises 12 | Morlet wavelets"></a>Exercises 12 | Morlet wavelets</h2><ol>
<li><p>Create a family of Morlet wavelets ranging in frequency from 2 Hz to 30 Hz in five steps. </p>
</li>
<li><p>Select one electrode from the scalp EEG dataset and convolve each wavelet with EEG data from all trials from that electrode. Apply the Matlab function real to the convolution result, as in <code>convol_result=real(convol_result)</code>. This will return the EEG data bandpass filtered at the peak frequency of the wavelet. You learn more about why this is in the next chapter. </p>
</li>
<li><p>Average the result of convolution over all trials and plot an ERP corresponding to each wavelet frequency. Each frequency should be in its own subplot. </p>
</li>
<li><p>Plot the broadband ERP (without any convolution). Thus, you will have six subplots in one figure. How do the wavelet-convolved ERPs compare with the broadband ERP? Are there dynamics revealed by the wavelet-convolved ERPs that are not apparent in the broadband ERP, and are there dynamics in the broadband ERP that are not apparent in the waveletconvolved ERPs? Base your answer on qualitative visual inspection of the results; statistics or other quantitative comparisons are not necessary. </p>
</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercise 12</span></span><br><span class="line"><span class="comment">%% 1. Create a family of Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequencies = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">num_wavelets = <span class="built_in">length</span>(frequencies);</span><br><span class="line"></span><br><span class="line">srate = EEG.srate;</span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/srate:<span class="number">1</span>;</span><br><span class="line">wavelet_family = <span class="built_in">zeros</span>(num_wavelets,<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Loop through frequencies and make a family of wavelets.</span></span><br><span class="line"><span class="keyword">for</span> fi=<span class="number">1</span>:num_wavelets</span><br><span class="line"> </span><br><span class="line">    <span class="comment">% create a sine wave at this frequency</span></span><br><span class="line">    sinewave = <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*frequencies(fi).*time); <span class="comment">% the &quot;1i&quot; makes it a complex wavelet</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create a Gaussian window</span></span><br><span class="line">    gaus_win = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi)))^<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% create wavelet via element-by-element multiplication of the sinewave and gaussian window</span></span><br><span class="line">    wavelet_family(fi,:) = sinewave.*gaus_win;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 2. Get EEG data from electrode 47, convolve each wavelet with EEG data</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line">channel = <span class="number">47</span>;</span><br><span class="line">n_conv = EEG.pnts + <span class="built_in">length</span>(time) - <span class="number">1</span>;</span><br><span class="line">convol_result = <span class="built_in">zeros</span>(EEG.trials,num_wavelets,n_conv);</span><br><span class="line">half_of_kernal_size = <span class="built_in">ceil</span>((<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> trial_i = <span class="number">1</span>:EEG.trials</span><br><span class="line">    fft_EEG = fft(EEG.data(channel,:,trial_i),n_conv);</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:num_wavelets</span><br><span class="line">        fft_wavelet = fft(wavelet_family(fi,:),n_conv);</span><br><span class="line">        convol_result(trial_i,fi,:) = ifft(fft_EEG.*fft_wavelet,n_conv) * <span class="built_in">sqrt</span>(<span class="number">6</span>/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi))) / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convol_result = <span class="built_in">real</span>(convol_result(:,:,half_of_kernal_size+<span class="number">1</span>:n_conv-half_of_kernal_size));</span><br><span class="line">filtered_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(convol_result,<span class="number">1</span>));		<span class="comment">% 经过wavelet滤波后的ERP</span></span><br><span class="line">broadband_ERP = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(channel,:,:),<span class="number">3</span>));		 <span class="comment">% 未滤波的ERP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num_wavelets</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,filtered_ERP(<span class="built_in">i</span>,:));</span><br><span class="line">    set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-300</span>, <span class="number">1000</span>])</span><br><span class="line">    ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">    xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Wavelet filtered ERP at &#x27;</span> num2str(frequencies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">plot</span>(EEG.times,broadband_ERP);</span><br><span class="line">ylim(<span class="string">&quot;padded&quot;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Unfiltered broadband ERP&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/19/3lrQXKtgZI4docT.png" alt="Ex_12"></p>
<hr>
<h2 id="Exercises-13-complex-Morlet-wavelets"><a href="#Exercises-13-complex-Morlet-wavelets" class="headerlink" title="Exercises 13 | complex Morlet wavelets"></a>Exercises 13 | complex Morlet wavelets</h2><h3 id="1-Create-a-family-of-complex-Morlet-wavelets"><a href="#1-Create-a-family-of-complex-Morlet-wavelets" class="headerlink" title="1. Create a family of complex Morlet wavelets"></a>1. Create a family of complex Morlet wavelets</h3><p>Create a family of complex Morlet wavelets ranging in frequencies from 2 Hz to 30 Hz in five steps. </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 13</span></span><br><span class="line"><span class="comment">% 1. Create a family of complex Morlet wavelets</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">5</span>);</span><br><span class="line">time = <span class="number">-2</span>:<span class="number">1</span>/EEG.srate:<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在3和10之间生成5个对数分别的数，作为不同频率下wavelet包含的周期数目</span></span><br><span class="line">numcycles = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">10</span>),<span class="built_in">length</span>(frex));</span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex), <span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% make complex Morlet wavelets</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi));</span><br><span class="line">    wavelet(fi,:) = <span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)) * <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi).*time);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 检查两侧是否衰减到0</span></span><br><span class="line">    <span class="comment">% subplot(ceil(length(frex)/3), ceil(length(frex)/2), fi);</span></span><br><span class="line">    <span class="comment">% plot(time,real(wavelet));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Convolve-each-wavelet-with-EEG-data"><a href="#2-Convolve-each-wavelet-with-EEG-data" class="headerlink" title="2. Convolve each wavelet with EEG data"></a>2. Convolve each wavelet with EEG data</h3><p>Convolve each wavelet with EEG data from all electrodes and from one trial. </p>
<h3 id="3-Extract-power-and-phase"><a href="#3-Extract-power-and-phase" class="headerlink" title="3. Extract power and phase"></a>3. Extract power and phase</h3><p>Extract power and phase from the result of complex wavelet convolution and store in a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix). </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 2. Convolve each wavelet with EEG data from all electrode and from one trial</span></span><br><span class="line">trial = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 3. a time × frequency × electrodes × power/phase matrix (thus, a 640 × 5 × 64 × 2 matrix)</span></span><br><span class="line">convolution_result_fft = <span class="built_in">zeros</span>(n_convolution,<span class="built_in">length</span>(frex),EEG.nbchan,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% FFT of wavelet and EEG data</span></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    fft_data    = fft(<span class="built_in">squeeze</span>(EEG.data(electrodei,:,trial)),n_convolution); <span class="comment">% trial 1</span></span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">        fft_wavelet = fft(wavelet(fi,:),n_convolution);</span><br><span class="line">        convoli = ifft(fft_wavelet.*fft_data,n_convolution) * <span class="built_in">sqrt</span>(s);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">1</span>) = <span class="built_in">abs</span>(convoli.^<span class="number">2</span>);</span><br><span class="line">        convolution_result_fft(:,fi,electrodei,<span class="number">2</span>) = <span class="built_in">angle</span>(convoli);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_fft = convolution_result_fft(half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size,:,:,:);</span><br></pre></td></tr></table></figure>
<h3 id="4-Make-topographical-plots-of-power-and-phase"><a href="#4-Make-topographical-plots-of-power-and-phase" class="headerlink" title="4. Make topographical plots of power and phase"></a>4. Make topographical plots of power and phase</h3><p>Make topographical plots of power and phase at 180 ms at all frequencies (hint: you may need to use the squeeze function to remove singleton dimensions). Arrange the plots in one figure with five columns for frequency and two rows for power/phase. Put labels in the plot so it is clear which topographical maps correspond to which frequencies. </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 180 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">180</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/gypqPbMUZfo2iC5.png" alt="Ex_13(1)"></p>
<h3 id="5-Repeat-step-4-for-activity-at-360-ms"><a href="#5-Repeat-step-4-for-activity-at-360-ms" class="headerlink" title="5. Repeat step 4 for activity at 360 ms."></a>5. Repeat step 4 for activity at 360 ms.</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% make topographical features in power ans phase at 360 ms</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">t = <span class="number">360</span>;</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">1</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Pwr:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">5</span>,fi+<span class="number">5</span>)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/DxTRqhzK72JtoPL.png" alt="Ex_13(2)"></p>
<h3 id="6-Think"><a href="#6-Think" class="headerlink" title="6. Think"></a>6. Think</h3><p>Are there any prominent topographical features in power or in phase?     - Yes.</p>
<p>Do these differ for different frequencies?     - Yes.</p>
<p>Do power and phase have similar topographical distributions?    - It doesn’t look very similar.</p>
<p>Is there any reason to suspect that they might have similar or different topographies?     </p>
<blockquote>
<h4 id="From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures"><a href="#From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures" class="headerlink" title="(From ChatGPT for reference, GPT is not provided with corresponding pictures)"></a><strong>(From ChatGPT for reference, GPT is not provided with corresponding pictures)</strong></h4><p>When analyzing EEG data, particularly through time-frequency decomposition, you might observe various topographical features in both power and phase distributions across the scalp. These features can provide insights into underlying neural processes. Let’s break down each question:</p>
<h4 id="1-Are-there-any-prominent-topographical-features-in-power-or-in-phase"><a href="#1-Are-there-any-prominent-topographical-features-in-power-or-in-phase" class="headerlink" title="(1) Are there any prominent topographical features in power or in phase?"></a><strong>(1) Are there any prominent topographical features in power or in phase?</strong></h4><ul>
<li><strong>Power Topography</strong>: Power topography represents the distribution of signal power across the scalp. Prominent features in power maps could indicate areas of strong neural activity, which might correspond to specific cognitive or sensory processes. For example, increased power in the occipital regions might be related to visual processing.</li>
<li><strong>Phase Topography</strong>: Phase topography shows the distribution of phase angles across the scalp. Prominent features in phase topography could indicate phase synchronization between regions, which might be associated with communication between different brain areas.</li>
</ul>
<h4 id="2-Do-these-differ-for-different-frequencies"><a href="#2-Do-these-differ-for-different-frequencies" class="headerlink" title="(2) Do these differ for different frequencies?"></a><strong>(2) Do these differ for different frequencies?</strong></h4><ul>
<li>Yes, topographical features often differ for different frequencies. Different frequencies in EEG are associated with different types of neural activity (e.g., alpha waves in the 8-12 Hz range are often related to relaxation and closed eyes, while beta waves in the 13-30 Hz range are associated with active thinking or focus). The power and phase topographies can change significantly across different frequency bands, reflecting the different functional roles of these frequencies.</li>
</ul>
<h4 id="3-Do-power-and-phase-have-similar-topographical-distributions"><a href="#3-Do-power-and-phase-have-similar-topographical-distributions" class="headerlink" title="(3) Do power and phase have similar topographical distributions?"></a><strong>(3) Do power and phase have similar topographical distributions?</strong></h4><ul>
<li>Power and phase distributions are often not identical. Power topography might highlight regions with strong amplitude, while phase topography might emphasize regions where the timing of oscillatory activity is synchronized across electrodes. However, there can be similarities, especially in regions where strong power is accompanied by consistent phase alignment (e.g., in tasks requiring coordinated neural activity across brain regions).</li>
</ul>
<h4 id="4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies"><a href="#4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies" class="headerlink" title="(4) Is there any reason to suspect that they might have similar or different topographies?"></a><strong>(4) Is there any reason to suspect that they might have similar or different topographies?</strong></h4><ul>
<li><strong>Similar Topographies</strong>: Power and phase could have similar topographies in cases where high power is associated with phase-locked activity across trials or regions. For instance, during sensory processing, a stimulus might evoke both strong power and phase synchronization in relevant brain areas.</li>
<li><strong>Different Topographies</strong>: Conversely, power and phase might differ in their topographical distributions due to different underlying mechanisms. High power might occur in one region without strong phase alignment, especially if the neural activity is more localized or independent across trials. Additionally, phase synchronization can occur without strong power, especially in low-amplitude oscillations that are critical for certain cognitive processes.</li>
</ul>
<h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a>Summary:</h4><ul>
<li><strong>Power and phase topographies can both reveal important aspects of neural activity, but they often provide different insights</strong>. Power maps tend to show where neural activity is strong, while phase maps can indicate where different regions are temporally synchronized. The topographies of power and phase may differ depending on the frequency of interest and the specific neural processes involved. Understanding these distributions and their relationships is key to interpreting EEG data in the context of neural dynamics.</li>
</ul>
</blockquote>
<h3 id="7-Create-a-circular-colormap"><a href="#7-Create-a-circular-colormap" class="headerlink" title="7.  Create a circular colormap"></a>7.  Create a circular colormap</h3><p>Because phase values are circular ( – <em>π</em> and + <em>π</em> are identical), most color maps are inappropriate because they suggest that – <em>π</em> and + <em>π</em> are very different values (represented, e.g., by blue and red colors). Create a circular colormap that can be used for phase values. You can do this by setting the red, green, and/or blue values to be a cosine function rather than a linear function. Recreate the phase topographical maps. Do they look any different with the new color maps? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自定义用于相位的环形colormap，使得-pi和pi对应的颜色相同</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,fi)</span><br><span class="line">    topoplot(<span class="built_in">squeeze</span>(convolution_result_fft(EEG.times&gt;=t<span class="number">-500</span>/EEG.srate &amp; EEG.times &lt;= t+<span class="number">500</span>/EEG.srate,fi,:,<span class="number">2</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    title([<span class="string">&#x27;Phs:&#x27;</span> num2str(frex(fi)) <span class="string">&#x27;Hz,&#x27;</span> num2str(t) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ax6 = subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">nColors = <span class="number">128</span>; <span class="comment">% 调色板的颜色数量</span></span><br><span class="line">cmap = hsv(nColors); <span class="comment">% 使用 HSV colormap</span></span><br><span class="line">cmap = cmap([<span class="number">1</span>:<span class="keyword">end</span> <span class="number">1</span>], :); <span class="comment">% 将第一个颜色重复，使得 -pi 和 pi 一致</span></span><br><span class="line">colormap(cmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加环形 colorbar</span></span><br><span class="line">cb = colorbar;</span><br><span class="line">set(cb, <span class="string">&#x27;Ticks&#x27;</span>, [-<span class="built_in">pi</span>, -<span class="built_in">pi</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="built_in">pi</span>/<span class="number">2</span>, <span class="built_in">pi</span>], <span class="string">&#x27;TickLabels&#x27;</span>, &#123;<span class="string">&#x27;-\pi&#x27;</span>, <span class="string">&#x27;-\pi/2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;\pi/2&#x27;</span>, <span class="string">&#x27;\pi&#x27;</span>&#125;);</span><br><span class="line">clim([-<span class="built_in">pi</span> <span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">axis off</span><br><span class="line">cb.Position(<span class="number">1</span>) = ax6.Position(<span class="number">1</span>);</span><br><span class="line">cb.Position(<span class="number">2</span>) = ax6.Position(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/23/8dGJkcTSfWMRO1A.png" alt="Ex_13(3)"></p>
<hr>
<h2 id="Exercises-14-filter-Hilbert"><a href="#Exercises-14-filter-Hilbert" class="headerlink" title="Exercises 14 | filter-Hilbert"></a>Exercises 14 | filter-Hilbert</h2><ol>
<li>Pick two frequencies (e.g., 5 Hz and 25 Hz) and one electrode and perform complex Morlet wavelet convolution and filter-Hilbert using those two frequencies as the peak/center frequencies for all trials. Plot the resulting power and the bandpass-filtered signal (that is, the real component of the analytic signal) from each method. Plot one single trial (you can choose the trial randomly but plot the same trial for both methods) and then plot the average of all trials. Describe some similarities and differences between the results of the two time-frequency decomposition methods. </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 14</span></span><br><span class="line"><span class="comment">%% 1. perform complex Morlet wavelet convolution and filter-Hilbert using frequencies 5 Hz and 25 Hz</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"><span class="comment">% two frequencies</span></span><br><span class="line">frex = [<span class="number">5</span>, <span class="number">25</span>]; <span class="comment">% the center frequencies</span></span><br><span class="line"><span class="comment">% pick one electrode (Fcz) and one trial</span></span><br><span class="line">electrode = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,<span class="string">&#x27;Fcz&#x27;</span>));</span><br><span class="line">trial = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">data2filter = <span class="built_in">squeeze</span>(EEG.data(electrode,:,trial));</span><br><span class="line">data2filter_average = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(electrode,:,:),<span class="number">3</span>));</span><br><span class="line"><span class="comment">%% perform complex Morlet wavelet convolution</span></span><br><span class="line"><span class="comment">% wavelet parameters</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">numcycles = [<span class="number">4</span> <span class="number">5</span>];</span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">conv_result_wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),n_convolution);</span><br><span class="line">conv_result_wavelet_2 = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),n_convolution);</span><br><span class="line">fft_data = fft(data2filter,n_convolution);</span><br><span class="line">fft_data_2 = fft(data2filter_average,n_convolution);</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi));</span><br><span class="line">    wavelet = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frex(fi).*time);</span><br><span class="line">    </span><br><span class="line">    fft_wavelet = fft(wavelet,n_convolution);</span><br><span class="line">    fft_wavelet = fft_wavelet ./ <span class="built_in">max</span>(<span class="built_in">abs</span>(fft_wavelet));</span><br><span class="line">    conv_result_wavelet(fi,:) = ifft(fft_wavelet.*fft_data,n_convolution)*(<span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)));</span><br><span class="line">    conv_result_wavelet_2(fi,:) = ifft(fft_wavelet.*fft_data_2,n_convolution)*(<span class="number">1</span>/<span class="built_in">sqrt</span>(s*<span class="built_in">sqrt</span>(<span class="built_in">pi</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">conv_result_wavelet = conv_result_wavelet(:,half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line">conv_result_wavelet_2 = conv_result_wavelet_2(:,half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line"><span class="comment">%% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">2</span> <span class="number">10</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = [<span class="number">.01</span> <span class="number">.15</span>];</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>) ([<span class="number">1</span> <span class="number">1</span>]-transwid)&#x27;.*(frex-freqspread)&#x27; (frex-freqspread)&#x27; (frex+freqspread)&#x27; ([<span class="number">1</span> <span class="number">1</span>]+transwid)&#x27;.*(frex+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(fi),EEG.pnts);</span><br><span class="line">filter_result_2 = <span class="built_in">zeros</span>(<span class="built_in">length</span>(fi),EEG.pnts);</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">    fft_filter = fft(filterweights);</span><br><span class="line">    filter_result(fi,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    filter_result_2(fi,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter_average));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(conv_result_wavelet(<span class="built_in">i</span>,:)).^<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(filter_result(<span class="built_in">i</span>,:)).^<span class="number">2</span>)</span><br><span class="line">    set(gca,<span class="string">&quot;XLim&quot;</span>,[<span class="number">-500</span>,<span class="number">1000</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Voltage (\muV)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Center Frequency: &#x27;</span> num2str(frex(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;wavelet&#x27;</span>,<span class="string">&#x27;filter-Hilbert&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frex)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="built_in">i</span>)</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(conv_result_wavelet_2(<span class="built_in">i</span>,:)).^<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">abs</span>(filter_result_2(<span class="built_in">i</span>,:)).^<span class="number">2</span>)</span><br><span class="line">    set(gca,<span class="string">&quot;XLim&quot;</span>,[<span class="number">-500</span>,<span class="number">1000</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Voltage (\muV)&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Center Frequency: &#x27;</span> num2str(frex(<span class="built_in">i</span>)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;wavelet&#x27;</span>,<span class="string">&#x27;filter-Hilbert&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/08/26/5IQZ4tyGiRP6Lck.png" alt="Ex_14(1)_onetrial"></p>
<p><img src="https://s2.loli.net/2024/08/26/LfFCS7RhA6BjYpX.png" alt="Ex_14(1)_onetrial"></p>
<ol>
<li>Modify the wavelet and filter settings (but keep the peak/center frequencies the same) until these two methods produce very similar results. Next, modify the wavelet and filter settings (except the peak/center frequencies) to make the results different (stay within a reasonable range of parameter settings; they do not need to look dramatically different). Which parameters did you change to make the results look more similar versus more different? How different are the results, and would you consider this a meaningful difference? What does this difference tell you about when to use specific parameter settings for wavelet convolution and the filter-Hilbert method? </li>
</ol>
<p>尝试改变的参数：</p>
<ul>
<li>wavelet：<ul>
<li>numcycles：wavelet包含的周期数目参数。包含的周期数目越多，wavelet频带越窄，频率分辨率越高</li>
</ul>
</li>
<li>filter-Hilbert：<ul>
<li>freqspread：带宽参数。带宽越大，频率分辨率越低</li>
<li>transwid：过渡区宽度参数。</li>
<li><code>firls()</code>的第一个参数，the order of the filter：决定filter kernel频率响应的精度。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Exercises-15-The-Short-Time-FFT"><a href="#Exercises-15-The-Short-Time-FFT" class="headerlink" title="Exercises 15 | The Short-Time FFT"></a>Exercises 15 | The Short-Time FFT</h2><ol>
<li>Compute the <strong>short-time FFT</strong> at each electrode and make topographical maps of theta band (around 6 Hz) power and alpha-band (around 10 Hz) power at 150 ms and 700 ms. </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Compute the short-time FFT at each electrode</span></span><br><span class="line"><span class="comment">% and make topographical maps of theta band (around 6 Hz) power and alpha-band (around 10 Hz) power at 150 ms and 700 ms. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">50</span>:<span class="number">1000</span>; <span class="comment">% in ms</span></span><br><span class="line">timepoint(<span class="number">1</span>) = <span class="number">150</span>;   <span class="comment">% ms</span></span><br><span class="line">timepoint(<span class="number">2</span>) = <span class="number">700</span>;   <span class="comment">% ms</span></span><br><span class="line">frequency(<span class="number">1</span>) = <span class="number">6</span>;     <span class="comment">% Hz</span></span><br><span class="line">frequency(<span class="number">2</span>) = <span class="number">10</span>;    <span class="comment">% Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert ms to idx</span></span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> frexi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [junk,times2saveidx(frexi)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(frexi)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">0.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">tf = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frex),<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    <span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">        tempdat = <span class="built_in">squeeze</span>(EEG.data(channi,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">        <span class="comment">% and hann_win)</span></span><br><span class="line">        taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">        </span><br><span class="line">        fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">        tf(channi,:,timepointi) = <span class="built_in">mean</span>(<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>,<span class="number">2</span>); <span class="comment">% average over trials</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[junk,frequencyidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency(<span class="number">1</span>)));</span><br><span class="line">[junk,frequencyidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency(<span class="number">2</span>)));</span><br><span class="line">[junk,timepointidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-timepoint(<span class="number">1</span>)));</span><br><span class="line">[junk,timepointidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-timepoint(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> timei = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> frexi = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        subplot(<span class="number">2</span>,<span class="number">2</span>,(timei<span class="number">-1</span>)*<span class="number">2</span>+frexi)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(tf(:,frequencyidx(frexi),timepointidx(timei))),EEG.chanlocs);</span><br><span class="line">        title([num2str(timepoint(timei)) <span class="string">&#x27;ms, &#x27;</span> num2str(frequency(frexi)) <span class="string">&#x27;Hz&#x27;</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/01/IZGUTadVePJ85Qt.png" alt="Ex_15(1)" style="zoom:50%;" /></p>
<ol>
<li>Select one electrode and one frequency and compute power over time at that electrode and that frequency using <strong>complex wavelet convolution</strong>, <strong>filter-Hilbert</strong>, and the <strong>short-time FFT</strong>. Plot the results of these three time-frequency decomposition methods in different subplots of one figure. Note that the scaling might be different because no baseline normalization has been applied. How visually similar are the results from these three methods? If the results from the three methods are different, how are they different, and what parameters do you think you could change in the three methods to make the results look more or less similar? </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select one electrode and one frequency and compute power over time at that electrode and that frequency</span></span><br><span class="line"><span class="comment">% using complex wavelet convolution, filter-Hilbert, and the short-time FFT.</span></span><br><span class="line"></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">channel2plot = <span class="string">&#x27;Fcz&#x27;</span>;</span><br><span class="line">electrode = strcmpi(channel2plot,&#123;EEG.chanlocs.labels&#125;);</span><br><span class="line">frequency = <span class="number">6</span>;     <span class="comment">% in Hz</span></span><br><span class="line"></span><br><span class="line">times2save = <span class="number">-200</span>:<span class="number">1000</span>/EEG.srate:<span class="number">800</span>;</span><br><span class="line"><span class="comment">% convert from ms to index</span></span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [junk,times2saveidx(<span class="built_in">i</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% complex wavelet convolution</span></span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">numcycle = <span class="number">4</span>;</span><br><span class="line">s = numcycle/(<span class="number">2</span>*<span class="built_in">pi</span>*frequency);</span><br><span class="line">wavelet = <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>)) .* <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frequency.*time);</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT parameters</span></span><br><span class="line">n_wavelet            = <span class="built_in">length</span>(time);</span><br><span class="line">n_data               = EEG.pnts;</span><br><span class="line">n_convolution        = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line">half_of_wavelet_size = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT of wavelet and EEG data</span></span><br><span class="line">fft_wavelet = fft(wavelet,n_convolution);</span><br><span class="line">convol = <span class="built_in">zeros</span>(EEG.trials,n_convolution);</span><br><span class="line"><span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">    fft_data    = fft(<span class="built_in">squeeze</span>(EEG.data(electrode,:,triali)),n_convolution);</span><br><span class="line">    convol(triali,:) = ifft(fft_wavelet.*fft_data,n_convolution);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">convolution_result_fft = <span class="built_in">mean</span>((<span class="built_in">abs</span>(convol).^<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% cut off edges</span></span><br><span class="line">convolution_result_fft = convolution_result_fft(half_of_wavelet_size+<span class="number">1</span>:<span class="keyword">end</span>-half_of_wavelet_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% filter-Hilbert</span></span><br><span class="line">freqspread = <span class="number">3</span>; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.01</span>;</span><br><span class="line">nyquist = EEG.srate/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="number">0</span> (<span class="number">1</span>-transwid)&#x27;.*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (<span class="number">1</span>+transwid)&#x27;.*(frequency+freqspread)&#x27; nyquist ]./nyquist;</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line"></span><br><span class="line">filterweights = firls(<span class="number">200</span>,ffrequencies,idealresponse);</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(EEG.trials,EEG.pnts);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">    filter_result(triali,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,EEG.data(electrode,:,triali)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">filter_result = <span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result.^<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line"><span class="comment">%% the short-time FFT</span></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">    tempdat = <span class="built_in">squeeze</span>(EEG.data(electrode,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">    <span class="comment">% and hann_win)</span></span><br><span class="line">    taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">    </span><br><span class="line">    fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">    tf(:,timepointi) = <span class="built_in">mean</span>(<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>,<span class="number">2</span>); <span class="comment">% average over trials</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[junk,frequencyidx]=<span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequency));</span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(times2save,tf(frequencyidx,:)./(<span class="built_in">max</span>(tf(frequencyidx,:))),<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(times2save,convolution_result_fft(times2saveidx)./(<span class="built_in">max</span>(convolution_result_fft(times2saveidx))),<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.8</span> <span class="number">0</span>],<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(times2save,filter_result(times2saveidx)./(<span class="built_in">max</span>(filter_result(times2saveidx))),<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Short-Time FFT&#x27;</span>,<span class="string">&#x27;complex wavelet&#x27;</span>,<span class="string">&#x27;Hilbert-filter&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">0.2</span>,<span class="number">1.3</span>]) </span><br><span class="line">colormap parula</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/10/15/8ksfL9EAevVWQbX.png" alt="Ex_15(2)" style="zoom:67%;" /></p>
<hr>
<h2 id="Exercises-16-Multitaper"><a href="#Exercises-16-Multitaper" class="headerlink" title="Exercises 16 | Multitaper"></a>Exercises 16 | Multitaper</h2><ol>
<li><p>Pick one electrode and compute a time-frequency map of power using both the multitaper method and the short-time FFT. Store all of the power values for all of the trials.</p>
</li>
<li><p>Next, compute a time-frequency map of signal-to-noise ratio. The signal-to-noise ratio of power is discussed more in chapter 18, but it can be estimated as the average power at each time-frequency point across trials, divided by the standard deviation of power at each time-frequency point across trials. </p>
</li>
<li>Make time-frequency plots of power and signal-to-noise ratio from the two methods. Make another plot in which you subtract the signal-to-noise plots between the two methods. Are there any noticeable differences between the signal-to-noise results when the multitaper method versus the short-time FFT is used? </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick one electrode and compute a time-frequency map of power using both the multitaper method and the short-time FFT.</span></span><br><span class="line">load sampleEEGdata</span><br><span class="line"></span><br><span class="line">channel2plot = <span class="string">&#x27;p7&#x27;</span>;</span><br><span class="line">channel2plotidx = strcmpi(channel2plot,&#123;EEG.chanlocs.labels&#125;);</span><br><span class="line"></span><br><span class="line">timewin = <span class="number">400</span>;      <span class="comment">% in ms</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">50</span>:<span class="number">1000</span>; <span class="comment">% in ms</span></span><br><span class="line"><span class="comment">% convert from ms to index</span></span><br><span class="line">timewinidx = <span class="built_in">round</span>(EEG.srate*timewin/<span class="number">1000</span>);</span><br><span class="line">times2saveidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(times2save));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    [~,times2saveidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-times2save(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">baseline_range  = [<span class="number">-200</span> <span class="number">-00</span>];</span><br><span class="line"><span class="comment">% find baselinetimepoints</span></span><br><span class="line">baseidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(baseline_range));</span><br><span class="line">[~,baseidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-baseline_range(<span class="number">1</span>)));</span><br><span class="line">[~,baseidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(times2save-baseline_range(<span class="number">2</span>)));</span><br><span class="line"><span class="comment">% define frequencies</span></span><br><span class="line">frex = <span class="built_in">linspace</span>(<span class="number">0</span>,EEG.srate/<span class="number">2</span>,<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% multitaper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 参数设置</span></span><br><span class="line">N = timewinidx; <span class="comment">% 样本点数</span></span><br><span class="line">W = <span class="number">4</span>;    <span class="comment">% 频带宽度</span></span><br><span class="line">Fs = EEG.srate; <span class="comment">% 采样率</span></span><br><span class="line">NW = N * (W / (Fs/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成tapers</span></span><br><span class="line">[tapers, eigenvalues] = dpss(N, NW);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择特征值大于0.9的tapers</span></span><br><span class="line">tapersToUse = tapers(:, eigenvalues &gt; <span class="number">0.9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize output matrix</span></span><br><span class="line">multitaper_tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials,<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop through time bins</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)  <span class="comment">% 对应一个时间点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% initialize power vector (over tapers)</span></span><br><span class="line">    <span class="comment">% 一个时间点处各频率的功率值，对应tf图上与时间轴垂直的一条线段</span></span><br><span class="line">    taperpow = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% loop through tapers</span></span><br><span class="line">    <span class="keyword">for</span> tapi = <span class="number">1</span>:<span class="built_in">size</span>(tapersToUse,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">        tempdat = <span class="built_in">squeeze</span>(EEG.data(channel2plotidx,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">        data      = <span class="built_in">bsxfun</span>(@times,tempdat,tapersToUse(:,tapi));</span><br><span class="line"></span><br><span class="line">        <span class="comment">% timewindow截取、taper两端减弱后的数据进行Fourier变换，提取特定频率的功率值</span></span><br><span class="line">        pow       = fft(data,timewinidx)/timewinidx;</span><br><span class="line">        pow       = pow(<span class="number">1</span>:<span class="built_in">length</span>(frex),:);</span><br><span class="line">        taperpow  = taperpow + pow.*<span class="built_in">conj</span>(pow);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% finally, get power from closest frequency</span></span><br><span class="line">    multitaper_tf(:,:,timepointi) = taperpow/tapi;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% the short-time FFT</span></span><br><span class="line"><span class="comment">% create hann taper</span></span><br><span class="line">hann_win = <span class="number">.5</span>*(<span class="number">1</span>-<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:timewinidx<span class="number">-1</span>)/(timewinidx<span class="number">-1</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% initialize power output matrix</span></span><br><span class="line">fft_tf = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frex),EEG.trials,<span class="built_in">length</span>(times2save));</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop over time points and perform FFT</span></span><br><span class="line"><span class="keyword">for</span> timepointi=<span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% extract time series data for this center time point</span></span><br><span class="line">    tempdat = <span class="built_in">squeeze</span>(EEG.data(channel2plotidx,times2saveidx(timepointi)-<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>):times2saveidx(timepointi)+<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)-<span class="built_in">mod</span>(timewinidx+<span class="number">1</span>,<span class="number">2</span>),:)); <span class="comment">% note: the &#x27;mod&#x27; function here corrects for even or odd number of points</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% taper data (using bsxfun instead of repmat... note sizes of tempdat</span></span><br><span class="line">    <span class="comment">% and hann_win)</span></span><br><span class="line">    taperdat = <span class="built_in">bsxfun</span>(@times,tempdat,hann_win&#x27;);</span><br><span class="line">    </span><br><span class="line">    fdat = fft(taperdat,[],<span class="number">1</span>)/timewinidx; <span class="comment">% 3rd input is to make sure fft is over time</span></span><br><span class="line">    fft_tf(:,:,timepointi) =<span class="built_in">abs</span>(fdat(<span class="number">1</span>:<span class="built_in">floor</span>(timewinidx/<span class="number">2</span>)+<span class="number">1</span>,:)).^<span class="number">2</span>; <span class="comment">% average over trials</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% compute a time-frequency map of signal-to-noise ratio.</span></span><br><span class="line">multitaper_mean = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(multitaper_tf,<span class="number">2</span>));</span><br><span class="line">fft_mean = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(fft_tf,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">multitaper_std = <span class="built_in">squeeze</span>(std(multitaper_tf,[],<span class="number">2</span>));</span><br><span class="line">fft_std = <span class="built_in">squeeze</span>(std(fft_tf,[],<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">snr_multitaper = multitaper_mean ./ multitaper_std;</span><br><span class="line">snr_fft = fft_mean ./ fft_std;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="comment">% db-correct</span></span><br><span class="line">db_multitaper_tf = <span class="number">10</span>*<span class="built_in">log10</span>( multitaper_mean ./ <span class="built_in">repmat</span>(<span class="built_in">mean</span>(multitaper_mean(:,baseidx(<span class="number">1</span>):baseidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">length</span>(times2save)) );</span><br><span class="line"><span class="comment">% db-correct</span></span><br><span class="line">db_fft_tf = <span class="number">10</span>*<span class="built_in">log10</span>( fft_mean ./ <span class="built_in">repmat</span>(<span class="built_in">mean</span>(fft_mean(:,baseidx(<span class="number">1</span>):baseidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">length</span>(times2save)) );</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">colormap jet</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">contourf(times2save,frex,db_multitaper_tf,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;Power of Multitaper&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">contourf(times2save,frex,db_fft_tf,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;Power of FFT&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">contourf(times2save,frex,snr_multitaper,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0.4</span> <span class="number">1.6</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;SNR of Multitaper&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">contourf(times2save,frex,snr_fft,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0.4</span> <span class="number">1.6</span>])</span><br><span class="line">colorbar</span><br><span class="line">title(<span class="string">&#x27;SNR of FFT&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">colormap jet</span><br><span class="line">contourf(times2save,frex,snr_multitaper-snr_fft,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">colorbar</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-0.2</span> <span class="number">1.2</span>])</span><br><span class="line">title(<span class="string">&#x27;SNR_&#123;Multipaper&#125; minus SNR_&#123;FFT&#125;&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;frequcy (Hz)&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/02/K3nNI58gTucP7Xj.png" alt="Ex_16(1)" style="zoom: 50%;" /></p>
<p><img src="https://s2.loli.net/2024/09/02/acKXeDqzrPkFV16.png" alt="Ex_16(2)" style="zoom:50%;" /></p>
<ol>
<li>Select two frequencies, one relatively low and one relatively high (e.g., 8 Hz and 60 Hz), and compare the power time series and signal-to-noise time series in these frequency bands from the two methods in a separate figure, using line plots. Comment on the differences if there are any. </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select two frequencies, one relatively low and one relatively high (e.g., 8 Hz and 60 Hz), </span></span><br><span class="line"><span class="comment">% and compare the power time series and signal-to-noise time series in these frequency bands </span></span><br><span class="line"><span class="comment">% from the two methods in a separate figure, using line plots.</span></span><br><span class="line">frequncies = [<span class="number">8</span>, <span class="number">60</span>];</span><br><span class="line">frequnciesidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(frequncies));</span><br><span class="line">[~,frequnciesidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequncies(<span class="number">1</span>)));</span><br><span class="line">[~,frequnciesidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(frex-frequncies(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(frequncies)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save,db_multitaper_tf(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    title([<span class="string">&#x27;Frequency: &#x27;</span> num2str(frequncies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz, Power&#x27;</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Power (dB)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save,db_fft_tf(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;Multitaper&#x27;</span>,<span class="string">&#x27;FFT&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save,snr_multitaper(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    title([<span class="string">&#x27;Frequency: &#x27;</span> num2str(frequncies(<span class="built_in">i</span>)) <span class="string">&#x27; Hz, SNR&#x27;</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;time (ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;SNR&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save,snr_fft(frequnciesidx(<span class="built_in">i</span>),:))</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;Multitaper&#x27;</span>,<span class="string">&#x27;FFT&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/03/WkcpXonqmF8lbr5.png" alt="Ex_16(3)" style="zoom: 50%;" /></p>
<ul>
<li>Multitaper常用于低信噪比的情况，如高频活动或功率的单试次估计。通过使用多个taper，multitaper方法在频率轴上引入了一定的<strong>平滑效应</strong>。这种平滑可以减少频率分辨率的精细度，使得<strong>频谱变得更加连续和平滑</strong>。</li>
</ul>
<hr>
<h2 id="Exercises-18-Baseline-Normalization"><a href="#Exercises-18-Baseline-Normalization" class="headerlink" title="Exercises 18 | Baseline Normalization"></a>Exercises 18 | Baseline Normalization</h2><ol>
<li><p>Select three frequency bands and compute time-varying power at each electrode in these three bands, using either complex wavelet convolution or filter-Hilbert. Compute and store both the baseline-corrected power and the raw non-baseline-corrected power. You can choose which time period and baseline normalization method to use. </p>
</li>
<li><p>Select five time points and create topographical maps of power with and without baseline normalization at each selected time-frequency point. You should have time in columns and with/without baseline normalization in rows. Use separate figures for each frequency. The color scaling should be the same for all plots over time within a frequency, but the color scaling should be different for with versus without baseline normalization and should also be different for each frequency. </p>
</li>
<li>Are there qualitative differences in the topographical distributions of power with compared to without baseline normalization? Are the differences more prominent in some frequency bands or at some time points? What might be causing these differences? </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Select three frequency bands and compute time-varying power at each electrode in these three bands, using either complex wavelet convolution or filter-Hilbert.</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequency = [<span class="number">6</span> <span class="number">15</span> <span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">4</span> <span class="number">4</span> <span class="number">4</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.1</span>;</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequency+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">raw_result = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frequency),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(EEG.data(electrodei,:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">        filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        raw_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">raw_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(raw_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(raw_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">baseline_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,raw_result,baseline_power));</span><br><span class="line"></span><br><span class="line">timepoints = <span class="number">0</span>:<span class="number">100</span>:<span class="number">400</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timepoints)</span><br><span class="line">    [~,timepointsidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timepoints(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">    <span class="built_in">figure</span></span><br><span class="line">    sgtitle([<span class="string">&#x27;frequncy: &#x27;</span> num2str(frequency(fi)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    max_raw = <span class="built_in">ceil</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">abs</span>(raw_result(:,fi,timepointsidx)))));</span><br><span class="line">    max_baseline = <span class="built_in">ceil</span>(<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">abs</span>(baseline_dbconverted(:,fi,timepointsidx)))));</span><br><span class="line">    <span class="keyword">for</span> ti = <span class="number">1</span>:<span class="built_in">length</span>(timepoints)</span><br><span class="line">        subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,ti)</span><br><span class="line">        topoplot(raw_result(:,fi,timepointsidx(ti)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        title([<span class="string">&#x27;Raw Power, &#x27;</span> num2str(timepoints(ti)) <span class="string">&#x27;ms&#x27;</span>])   </span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[-max_raw,max_raw])</span><br><span class="line"></span><br><span class="line">        subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>+ti);</span><br><span class="line">        topoplot(baseline_dbconverted(:,fi,timepointsidx(ti)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        title([<span class="string">&#x27;DB Power, &#x27;</span> num2str(timepoints(ti)) <span class="string">&#x27;ms&#x27;</span>])</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[-max_baseline,max_baseline])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    subplot(subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>))</span><br><span class="line">    axis off</span><br><span class="line">    colorbar(<span class="string">&#x27;Ticks&#x27;</span>,[<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],<span class="string">&#x27;TickLabels&#x27;</span>,[-max_raw, -max_raw/<span class="number">2</span>, <span class="number">0</span>, max_raw/<span class="number">2</span>, max_raw]);</span><br><span class="line">    </span><br><span class="line">    subplot(subplot(<span class="number">2</span>,<span class="built_in">length</span>(timepoints)+<span class="number">1</span>,<span class="number">2</span>*(<span class="built_in">length</span>(timepoints)+<span class="number">1</span>)))</span><br><span class="line">    axis off</span><br><span class="line">    colorbar(<span class="string">&#x27;Ticks&#x27;</span>,[<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],<span class="string">&#x27;TickLabels&#x27;</span>,[-max_baseline, -max_baseline/<span class="number">2</span>, <span class="number">0</span>, max_baseline/<span class="number">2</span>, max_baseline]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/03/3z12yptIrshBUcF.png" alt="Ex_18_6Hz" style="zoom: 45%;" /></p>
<p><img src="https://s2.loli.net/2024/09/03/sHWeBm4nFMlz9cR.png" alt="Ex_18_15Hz" style="zoom:45%;" /></p>
<p><img src="https://s2.loli.net/2024/09/03/8hnCD9qUrumiJgc.png" alt="Ex_18_60Hz" style="zoom:45%;" /></p>
<hr>
<h2 id="Exercises-19-ITPC-Intertrial-Phase-Clustering"><a href="#Exercises-19-ITPC-Intertrial-Phase-Clustering" class="headerlink" title="Exercises 19 | ITPC (Intertrial Phase Clustering)"></a>Exercises 19 | ITPC (Intertrial Phase Clustering)</h2><ol>
<li>Pick three electrodes. Compute time-frequency plots of ITPC and decibel-corrected power for these electrodes, using either complex Morlet wavelet convolution or the filter-Hilbert method. Plot the results side by side for each electrode (power and ITPC in subplots; one figure for each electrode). Are the patterns of results from ITPC and power generally similar or generally different? Do the results look more similar at some electrodes and less similar at other electrodes? </li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick three electrodes. Compute time-frequency plots of ITPC and decibel-corrected power for these electrodes, using either complex Morlet wavelet convolution or the filter-Hilbert method. </span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">electrode = [<span class="string">&quot;fz&quot;</span>, <span class="string">&quot;p8&quot;</span>, <span class="string">&quot;oz&quot;</span>];</span><br><span class="line">electrodeidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(electrode));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(electrode) </span><br><span class="line">    electrodeidx(<span class="built_in">i</span>) = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,electrode(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">frequencies = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">30</span>),<span class="number">30</span>);</span><br><span class="line"><span class="comment">%% calculate power</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line"></span><br><span class="line">freqspread = <span class="built_in">linspace</span>(<span class="number">1</span>,<span class="number">6</span>,<span class="built_in">length</span>(frequencies)); <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.1</span>;</span><br><span class="line">nyquist = <span class="built_in">repmat</span>(EEG.srate/<span class="number">2</span>, <span class="built_in">size</span>(frequencies));</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">ones</span>(<span class="built_in">length</span>(frequencies),<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequencies-freqspread)&#x27; (frequencies-freqspread)&#x27; (frequencies+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequencies+freqspread)&#x27; nyquist&#x27; ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(electrode),<span class="built_in">length</span>(frequencies),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">        filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        filter_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">power_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(power_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">power_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,power_result,baseline_power));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% calculate ITPC</span></span><br><span class="line">ITPC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">angle</span>(filter_result)),<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">time2plot = [<span class="number">-300</span>, <span class="number">1000</span>];</span><br><span class="line">time2plotidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(time2plot));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    [~,time2plotidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-time2plot(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,electrodei)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(power_dbconverted(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">    title([<span class="string">&#x27;Power from &#x27;</span> num2str(electrode(electrodei))])</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>+electrodei)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(ITPC(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    title([<span class="string">&#x27;ITPC from &#x27;</span> num2str(electrode(electrodei))])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/03/PQAfsYTyS8UwIZ5.png" alt="Ex_19(1)" style="zoom: 67%;" /></p>
<ol>
<li>For each of these three electrodes, compute wITPCz using reaction time as the trial-varying modulator. Perform this analysis for all time-frequency points to generate time-frequency maps of the relationship between phase and reaction time. Do the time-frequency maps of wITPCz look different from the time-frequency maps of ITPC? Do you see any striking patterns in the ITPCz results, and do the results differ across the different electrodes (don ’ t worry about statistics, base your judgment on qualitative patterns)? How would you interpret the results if they were statistically significant? </li>
</ol>
<hr>
<h2 id="Exercises-20-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency"><a href="#Exercises-20-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency" class="headerlink" title="Exercises 20 | Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency"></a>Exercises 20 | Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency</h2><p>Pick two frequencies and compute total and non-phase-locked power from each electrode over time at these two frequencies. Pick two time windows, one early and one late, of several hundreds of milliseconds each (e.g., 100 – 300 ms and 500 – 800 ms) and show topographical maps of total power, non-phase-locked power, and phase-locked power from the average of all time points within these windows. Are there striking topographical differences among these results? If so, are the differences bigger or smaller in the early or the late time window? Why might this be the case? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Pick two frequencies and compute total and non-phase-locked power from each electrode over time at these two frequencies. </span></span><br><span class="line"><span class="comment">% compute total power</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">frequency = [<span class="number">5</span> <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">freqspread = [<span class="number">1.5</span> <span class="number">4</span>]; <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.15</span>;</span><br><span class="line">nyquist = [<span class="number">1</span>;<span class="number">1</span>] .* EEG.srate/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequency-freqspread)&#x27; (frequency-freqspread)&#x27; (frequency+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequency+freqspread)&#x27; nyquist ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">raw_result = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frequency),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(EEG.data(electrodei,:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">        filterweights = firls(<span class="number">200</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        raw_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">raw_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(raw_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(raw_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">baseline_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,raw_result,baseline_power));</span><br><span class="line">timewindow = [<span class="number">100</span>,<span class="number">300</span>; <span class="number">600</span>, <span class="number">900</span>];</span><br><span class="line">timewindowidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timewindowidx)</span><br><span class="line">    [~,timewindowidx(<span class="built_in">i</span>,<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">1</span>)));</span><br><span class="line">    [~,timewindowidx(<span class="built_in">i</span>,<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">2</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">total = <span class="built_in">zeros</span>(<span class="built_in">length</span>(timewindow),EEG.nbchan,<span class="built_in">length</span>(frequency));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timewindow)</span><br><span class="line">    total(<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(baseline_dbconverted(:,:,timewindowidx(<span class="built_in">i</span>,<span class="number">1</span>):timewindowidx(<span class="built_in">i</span>,<span class="number">2</span>)),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% compute non-phase-locked power</span></span><br><span class="line"><span class="comment">% compute ERP</span></span><br><span class="line">erp = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(:,:,:),<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% compute induced power by subtracting ERP from each trial</span></span><br><span class="line">induced_EEG = EEG.data(:,:,:) - <span class="built_in">repmat</span>(erp,[<span class="number">1</span> <span class="number">1</span> EEG.trials]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% filter the induced eeg data</span></span><br><span class="line">raw_result_non_phase_locked = <span class="built_in">zeros</span>(EEG.nbchan,<span class="built_in">length</span>(frequency),EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data2filter = <span class="built_in">squeeze</span>(induced_EEG(electrodei,:,:));</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">        filterweights = firls(<span class="number">200</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        raw_result_non_phase_locked(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">raw_result_non_phase_locked = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(raw_result_non_phase_locked).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% baseline normalization</span></span><br><span class="line">baseline_dbconverted_non_phase_locked = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,raw_result_non_phase_locked,baseline_power));</span><br><span class="line"></span><br><span class="line">non_phase_locked = <span class="built_in">zeros</span>(<span class="built_in">length</span>(timewindow),EEG.nbchan,<span class="built_in">length</span>(frequency));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(timewindow)</span><br><span class="line">    non_phase_locked(<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(baseline_dbconverted_non_phase_locked(:,:,timewindowidx(<span class="built_in">i</span>,<span class="number">1</span>):timewindowidx(<span class="built_in">i</span>,<span class="number">2</span>)),<span class="number">3</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% compute phase-locked power</span></span><br><span class="line">phase_locked = total - non_phase_locked;</span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">n = <span class="number">0</span>;  <span class="comment">% 用于绘子图时计算行数</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequency)</span><br><span class="line">    <span class="keyword">for</span> twi = <span class="number">1</span>:<span class="built_in">length</span>(timewindow)</span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>*n+<span class="number">1</span>)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(total(twi,:,fi)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-2</span>,<span class="number">2</span>])</span><br><span class="line">        title([<span class="string">&#x27;Total (&#x27;</span> num2str(frequency(fi)) <span class="string">&#x27;Hz, &#x27;</span> num2str(timewindow(twi,<span class="number">1</span>)) <span class="string">&#x27;-&#x27;</span> num2str(timewindow(twi,<span class="number">2</span>)) <span class="string">&#x27;ms)&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>*n+<span class="number">2</span>)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(non_phase_locked(twi,:,fi)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-2</span>,<span class="number">2</span>])</span><br><span class="line">        title([<span class="string">&#x27;Non-Phase-Locked (&#x27;</span> num2str(frequency(fi)) <span class="string">&#x27;Hz, &#x27;</span> num2str(timewindow(twi,<span class="number">1</span>)) <span class="string">&#x27;-&#x27;</span> num2str(timewindow(twi,<span class="number">2</span>)) <span class="string">&#x27;ms)&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>*n+<span class="number">3</span>)</span><br><span class="line">        topoplot(<span class="built_in">squeeze</span>(phase_locked(twi,:,fi)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;numcontour&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-1</span>,<span class="number">1</span>])</span><br><span class="line">        title([<span class="string">&#x27;Phase-Locked (&#x27;</span> num2str(frequency(fi)) <span class="string">&#x27;Hz, &#x27;</span> num2str(timewindow(twi,<span class="number">1</span>)) <span class="string">&#x27;-&#x27;</span> num2str(timewindow(twi,<span class="number">2</span>)) <span class="string">&#x27;ms)&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        n = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    colormap jet</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/04/yZaAUzbl3Nus6wh.png" alt="Ex_20" style="zoom:67%;" /></p>
<hr>
<h1 id="Part-4"><a href="#Part-4" class="headerlink" title="Part 4"></a>Part 4</h1><h2 id="Exercises-22-Surface-Laplacian"><a href="#Exercises-22-Surface-Laplacian" class="headerlink" title="Exercises 22 | Surface Laplacian"></a>Exercises 22 | Surface Laplacian</h2><ol>
<li><p>Based on the topographical maps of ERPs in figure 22.6 (plate 12) , select one electrode whose activity you think might look similar before and after computing the surface Laplacian, and one electrode whose activity you think might look different before and after the surface Laplacian. </p>
<p>(1) look similar before and after computing the surface Laplacian: <strong>FC1</strong></p>
<p>(2) look different before and after the surface Laplacian: <strong>PO8</strong></p>
<p><img src="https://s2.loli.net/2024/09/06/91IQ6UqVTAFykvG.png" alt="Figure22.6"></p>
</li>
<li><p>Perform a time-frequency decomposition of the data from those two electrodes both before and after computing the surface Laplacian (that is, compute the surface Laplacian on the raw data before applying a time-frequency decomposition). Compute both power (decibels normalized using a baseline period of your choice) and ITPC. </p>
</li>
<li><p>Plot the results using the same color scaling for before and after the surface Laplacian. </p>
</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 获得Surface Laplacian处理前后的数据</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"><span class="comment">% extract XYZ coordinates from EEG structure</span></span><br><span class="line">X = [EEG.chanlocs.X];</span><br><span class="line">Y = [EEG.chanlocs.Y];</span><br><span class="line">Z = [EEG.chanlocs.Z];</span><br><span class="line"><span class="comment">% compute surface laplacian</span></span><br><span class="line">lap_data = laplacian_perrinX(EEG.data,X,Y,Z);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算Power</span></span><br><span class="line">electrode = [<span class="string">&quot;FC1&quot;</span>, <span class="string">&quot;PO8&quot;</span> ,<span class="string">&quot;FC4&quot;</span>];</span><br><span class="line">electrodeidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(electrode));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(electrode) </span><br><span class="line">    electrodeidx(<span class="built_in">i</span>) = <span class="built_in">find</span>(strcmpi(&#123;EEG.chanlocs.labels&#125;,electrode(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">frequencies = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">2</span>),<span class="built_in">log10</span>(<span class="number">40</span>),<span class="number">30</span>);</span><br><span class="line"><span class="comment">%% calculate power</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% perform filter-Hilber</span></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line"></span><br><span class="line">freqspread = <span class="built_in">linspace</span>(<span class="number">0.8</span>,<span class="number">6</span>,<span class="built_in">length</span>(frequencies)); <span class="comment">% Hz +/- the center frequency</span></span><br><span class="line">transwid   = <span class="number">0.1</span>;</span><br><span class="line">nyquist = <span class="built_in">repmat</span>(EEG.srate/<span class="number">2</span>, <span class="built_in">size</span>(frequencies));</span><br><span class="line"></span><br><span class="line"><span class="comment">% construct filter kernels</span></span><br><span class="line">ffrequencies  = [ <span class="built_in">ones</span>(<span class="built_in">length</span>(frequencies),<span class="number">1</span>) (<span class="number">1</span>-transwid).*(frequencies-freqspread)&#x27; (frequencies-freqspread)&#x27; (frequencies+freqspread)&#x27; (<span class="number">1</span>+transwid).*(frequencies+freqspread)&#x27; nyquist&#x27; ]./nyquist(<span class="number">1</span>);</span><br><span class="line">idealresponse = [ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> ];</span><br><span class="line">filter_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(electrode),<span class="built_in">length</span>(frequencies),<span class="number">3</span>*EEG.pnts,EEG.trials);</span><br><span class="line">filter_result_lap = <span class="built_in">zeros</span>(<span class="built_in">length</span>(electrode),<span class="built_in">length</span>(frequencies),<span class="number">3</span>*EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    data2filter = [<span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:))); <span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:)); <span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(EEG.data(electrodeidx(electrodei),:,:)))];</span><br><span class="line">    data2filter_lap= [<span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(lap_data(electrodeidx(electrodei),:,:))); <span class="built_in">squeeze</span>(lap_data(electrodeidx(electrodei),:,:)); <span class="built_in">flipud</span>(<span class="built_in">squeeze</span>(lap_data(electrodeidx(electrodei),:,:)))];</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">        filterweights = firls(<span class="number">100</span>,ffrequencies(fi,:),idealresponse);</span><br><span class="line">        filter_result(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter));</span><br><span class="line">        filter_result_lap(electrodei,fi,:,:) = hilbert(filtfilt(filterweights,<span class="number">1</span>,data2filter_lap));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">filter_result = filter_result(:,:,<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span>:<span class="keyword">end</span>*<span class="number">2</span>/<span class="number">3</span>,:);</span><br><span class="line">filter_result_lap = filter_result_lap(:,:,<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span>:<span class="keyword">end</span>*<span class="number">2</span>/<span class="number">3</span>,:);</span><br><span class="line">power_result = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">power_result_lap = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(filter_result_lap).^<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">% define baseline period</span></span><br><span class="line">baselinetime = [<span class="number">-500</span> <span class="number">-200</span> ]; <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% convert baseline window time to indices</span></span><br><span class="line">[~,baselineidx(<span class="number">1</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">1</span>)));</span><br><span class="line">[~,baselineidx(<span class="number">2</span>)]=<span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-baselinetime(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">% dB-correct</span></span><br><span class="line">baseline_power = <span class="built_in">mean</span>(power_result(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">baseline_power_lap = <span class="built_in">mean</span>(power_result_lap(:,:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">3</span>);</span><br><span class="line">power_dbconverted = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,power_result,baseline_power));</span><br><span class="line">power_dbconverted_lap = <span class="number">10</span>*<span class="built_in">log10</span>( <span class="built_in">bsxfun</span>(@rdivide,power_result_lap,baseline_power_lap));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% calculate ITPC</span></span><br><span class="line">ITPC = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">angle</span>(filter_result)),<span class="number">4</span>));</span><br><span class="line">ITPC_lap = <span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">angle</span>(filter_result_lap)),<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">time2plot = [<span class="number">-300</span>, <span class="number">1000</span>];</span><br><span class="line">time2plotidx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(time2plot));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    [~,time2plotidx(<span class="built_in">i</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-time2plot(<span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> electrodei = <span class="number">1</span>:<span class="built_in">length</span>(electrode)</span><br><span class="line">    <span class="built_in">figure</span>(electrodei)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(power_dbconverted(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;Before Laplacian&#x27;</span>, [<span class="string">&#x27;Power from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(ITPC(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0</span> <span class="number">0.3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;Before Laplacian&#x27;</span>, [<span class="string">&#x27;ITPC from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(power_dbconverted_lap(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-3</span> <span class="number">3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;After Laplacian&#x27;</span>, [<span class="string">&#x27;Power from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"></span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">    contourf(EEG.times(time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>)),frequencies,<span class="built_in">squeeze</span>(ITPC_lap(electrodei,:,time2plotidx(<span class="number">1</span>):time2plotidx(<span class="number">2</span>))),<span class="number">30</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">0</span> <span class="number">0.3</span>])</span><br><span class="line">    title(&#123;<span class="string">&#x27;After Laplacian&#x27;</span>, [<span class="string">&#x27;ITPC from &#x27;</span> num2str(electrode(electrodei))]&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/06/c5YvOF8VH3RBhEt.png" alt="Ex_22(1)" style="zoom: 50%;" /></p>
<p><img src="https://s2.loli.net/2024/09/06/8vFAIJibtjwNEq9.png" alt="Ex_22(2)" style="zoom:50%;" /></p>
<ol>
<li>Are there any salient differences in the time-frequency power or ITPC results before versus after application of the surface Laplacian, and do the differences depend on the frequency? How would you interpret similarities and differences at different frequency bands? </li>
</ol>
<ul>
<li>There are differences and the differences depend on the frequency, like the power from PC1 at 10 Hz and from PO8 at 15 Hz.</li>
</ul>
<hr>
<h2 id="Exercises-23-Principal-Components-Analysis-PCA"><a href="#Exercises-23-Principal-Components-Analysis-PCA" class="headerlink" title="Exercises 23 | Principal Components Analysis (PCA)"></a>Exercises 23 | Principal Components Analysis (PCA)</h2><ol>
<li><p>Perform PCA on broadband data using two time windows, one before and one after trial onset (e.g., – 500 to 0 ms and 100 to 600 ms). </p>
</li>
<li><p>Plot topographical maps and time courses of the first four components. To construct the PCA time courses, multiply the PCA weights defined by the pre- and posttrial time windows with the electrode time courses from the entire trial. Do you notice any differences in the topographical maps or time courses from before versus after stimulus onset? How would you interpret differences and/or similarities? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Perform PCA on broadband data using two time windows</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line">timewindow = [<span class="number">-500</span>, <span class="number">0</span>; <span class="number">100</span>, <span class="number">600</span>];       <span class="comment">% in ms, 选取的timewindow</span></span><br><span class="line">timewindow_idx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(timewindow,<span class="number">1</span>)</span><br><span class="line">    [~,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">1</span>)));</span><br><span class="line">    [~,timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">2</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% timewindow的长度</span></span><br><span class="line">timewindow_length = timewindow_idx(<span class="number">1</span>,<span class="number">2</span>)-timewindow_idx(<span class="number">1</span>,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% compute covariance of ERP </span></span><br><span class="line">covar = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">pc = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">temp_eigvals = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">eigvals = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan);</span><br><span class="line"></span><br><span class="line"><span class="comment">% average single-trial covariances. 先对每一个试次计算协方差，最后平均</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(timewindow,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> triali=<span class="number">1</span>:EEG.trials</span><br><span class="line">        eeg = <span class="built_in">bsxfun</span>(@minus,<span class="built_in">squeeze</span>(EEG.data(:,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>):timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>),triali)),<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(:,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>):timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>),triali),<span class="number">2</span>)));</span><br><span class="line">        covar(<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(covar(<span class="built_in">i</span>,:,:)) + (eeg*eeg&#x27;)./(timewindow_length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    covar(<span class="built_in">i</span>,:,:) = covar(<span class="built_in">i</span>,:,:)./triali;</span><br><span class="line">    <span class="comment">% principle components analysis via eigenvalue decomposition 计算特征值eigvals、特征向量pc</span></span><br><span class="line">    [pc(<span class="built_in">i</span>,:,:),temp_eigvals(<span class="built_in">i</span>,:,:)] = eig(<span class="built_in">squeeze</span>(covar(<span class="built_in">i</span>,:,:)));</span><br><span class="line">    eigvals(<span class="built_in">i</span>,:) = <span class="built_in">diag</span>(<span class="built_in">squeeze</span>(temp_eigvals(<span class="built_in">i</span>,:,:)))&#x27;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">clear temp_eigvals</span><br><span class="line"></span><br><span class="line"><span class="comment">% components are listed in increasing order, and converted here to descending order for convenience</span></span><br><span class="line">pc      = pc(:,:,<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">eigvals = <span class="number">100</span>*eigvals(:,<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>)./sum(eigvals,<span class="number">2</span>); <span class="comment">% convert to percent change</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">4</span> <span class="comment">% only first 4 are shown in the real figure</span></span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">    colormap jet</span><br><span class="line">    subplot(<span class="number">4</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    topoplot(double(pc(<span class="number">1</span>,:,<span class="built_in">i</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">    title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;, eigval=&#x27;</span> num2str(eigvals(<span class="number">1</span>,<span class="built_in">i</span>)) ])</span><br><span class="line">    subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="built_in">i</span>*<span class="number">2</span>)</span><br><span class="line">    topoplot(double(pc(<span class="number">2</span>,:,<span class="built_in">i</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">    title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;, eigval=&#x27;</span> num2str(eigvals(<span class="number">2</span>,<span class="built_in">i</span>)) ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="built_in">i</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">% PC time course for each trial, then average together</span></span><br><span class="line">    pctimes = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>,EEG.pnts);</span><br><span class="line">    <span class="keyword">for</span> triali=<span class="number">1</span>:EEG.trials</span><br><span class="line">        eeg = <span class="built_in">bsxfun</span>(@minus,<span class="built_in">squeeze</span>(EEG.data(:,:,triali)),<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(EEG.data(:,:,triali),<span class="number">2</span>)));</span><br><span class="line">        pctimes(<span class="number">1</span>,:,:) = <span class="built_in">squeeze</span>(pctimes(<span class="number">1</span>,:,:))&#x27; + <span class="built_in">squeeze</span>(pc(<span class="number">1</span>,:,<span class="built_in">i</span>))*eeg;</span><br><span class="line">        pctimes(<span class="number">2</span>,:,:) = <span class="built_in">squeeze</span>(pctimes(<span class="number">2</span>,:,:))&#x27; + <span class="built_in">squeeze</span>(pc(<span class="number">2</span>,:,<span class="built_in">i</span>))*eeg;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">squeeze</span>(pctimes(<span class="number">1</span>,:,:))./EEG.trials)</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(EEG.times,<span class="built_in">squeeze</span>(pctimes(<span class="number">2</span>,:,:))./EEG.trials)</span><br><span class="line">    set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1200</span>])</span><br><span class="line">    title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;, eigval=&#x27;</span> num2str(eigvals(<span class="built_in">i</span>)) ])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/20/NdLJIsl67hyezbi.png" alt="Ex_23(1)" style="zoom: 67%;" /></p>
<p><img src="https://s2.loli.net/2024/09/20/HXKNLgRt4pqzjvi.png" alt="Ex_23(1.2)"></p>
</li>
<li><p>Repeat this exercise but after bandpass filtering in two different frequency bands. Make sure there are no edge artifacts in the pretrial time window (consider using reflection, if necessary, as described in figure 7.3). Justify your decision of frequency bands and time window width(s). Comment on any qualitative similarities and differences you observe between frequency bands and time windows and similarities and differences between the frequencyband-specific and broadband signal from the results obtained in the previous exercise. </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% perform Morlet wavelet, calculate power</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% parameters of filter</span></span><br><span class="line">frequencies = [<span class="number">15</span> <span class="number">30</span>];</span><br><span class="line">time = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">numcycles = [<span class="number">5</span> <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">half_wavelet  = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">n_wavelet = <span class="built_in">length</span>(time);</span><br><span class="line">n_data = <span class="number">3</span>*EEG.pnts;</span><br><span class="line">n_convolution = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">wavelet = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">length</span>(time));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi));</span><br><span class="line">    wavelet(fi,:) = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi).*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*s^<span class="number">2</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% filtered data</span></span><br><span class="line">convolution_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),EEG.nbchan,EEG.trials,EEG.pnts);</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform Morlet wavelet</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">    wavelet_fft = fft(wavelet(fi,:),n_convolution);</span><br><span class="line">    <span class="keyword">for</span> chani = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">        <span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">            data2filter = <span class="built_in">squeeze</span>(EEG.data(chani,:,triali));</span><br><span class="line">            data2filter = [<span class="built_in">fliplr</span>(data2filter) data2filter <span class="built_in">fliplr</span>(data2filter)];</span><br><span class="line">            data_fft = fft(data2filter,n_convolution);</span><br><span class="line">            </span><br><span class="line">            temp_result = ifft(wavelet_fft .* data_fft,n_convolution);</span><br><span class="line">            temp_result = temp_result(half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line"></span><br><span class="line">            convolution_result(fi,chani,triali,:) = <span class="built_in">real</span>(temp_result(<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span> : <span class="number">2</span>*<span class="keyword">end</span>/<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% calculate eigvals and pc</span></span><br><span class="line">timewindow = [<span class="number">-500</span>, <span class="number">0</span>; <span class="number">100</span>, <span class="number">600</span>];       <span class="comment">% in ms, 选取的timewindow</span></span><br><span class="line">timewindow_idx = <span class="built_in">zeros</span>(<span class="built_in">size</span>(timewindow));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(timewindow,<span class="number">1</span>)</span><br><span class="line">    [~,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">1</span>)));</span><br><span class="line">    [~,timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="built_in">i</span>,<span class="number">2</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% timewindow的长度</span></span><br><span class="line">timewindow_length = timewindow_idx(<span class="number">1</span>,<span class="number">2</span>)-timewindow_idx(<span class="number">1</span>,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% compute covariance of ERP </span></span><br><span class="line">covar = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">pc = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">temp_eigvals = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan,EEG.nbchan);</span><br><span class="line">eigvals = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">size</span>(timewindow,<span class="number">1</span>),EEG.nbchan);</span><br><span class="line"></span><br><span class="line"><span class="comment">% average single-trial covariances. 先对每一个试次计算协方差，最后平均</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(timewindow,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> triali=<span class="number">1</span>:EEG.trials</span><br><span class="line">            eeg = <span class="built_in">bsxfun</span>(@minus,<span class="built_in">squeeze</span>(convolution_result(fi,:,triali,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>):timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>))),<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(convolution_result(fi,:,triali,timewindow_idx(<span class="built_in">i</span>,<span class="number">1</span>):timewindow_idx(<span class="built_in">i</span>,<span class="number">2</span>)),<span class="number">4</span>))&#x27;);</span><br><span class="line">            covar(fi,<span class="built_in">i</span>,:,:) = <span class="built_in">squeeze</span>(covar(fi,<span class="built_in">i</span>,:,:)) + (eeg*eeg&#x27;)./(timewindow_length<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        covar(fi,<span class="built_in">i</span>,:,:) = covar(fi,<span class="built_in">i</span>,:,:)./triali;</span><br><span class="line">        <span class="comment">% principle components analysis via eigenvalue decomposition 计算特征值eigvals、特征向量pc</span></span><br><span class="line">        [pc(fi,<span class="built_in">i</span>,:,:),temp_eigvals(fi,<span class="built_in">i</span>,:,:)] = eig(<span class="built_in">squeeze</span>(covar(fi,<span class="built_in">i</span>,:,:)));</span><br><span class="line">        eigvals(fi,<span class="built_in">i</span>,:) = <span class="built_in">diag</span>(<span class="built_in">squeeze</span>(temp_eigvals(fi,<span class="built_in">i</span>,:,:)))&#x27;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">clear temp_eigvals</span><br><span class="line"></span><br><span class="line"><span class="comment">% components are listed in increasing order, and converted here to descending order for convenience</span></span><br><span class="line">pc      = pc(:,:,:,<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">eigvals = <span class="number">100</span>*eigvals(:,:,<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>)./sum(eigvals,<span class="number">3</span>); <span class="comment">% convert to percent change</span></span><br><span class="line"><span class="comment">%% </span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">4</span> <span class="comment">% only first 4 are shown in the real figure</span></span><br><span class="line">        <span class="built_in">figure</span>((fi<span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        a = sgtitle([<span class="string">&#x27;Frequency = &#x27;</span> num2str(frequencies(fi)) <span class="string">&#x27;Hz&#x27;</span>]);</span><br><span class="line">        a.FontSize = <span class="number">12</span>;</span><br><span class="line">        colormap jet</span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">2</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        topoplot(double(pc(fi,<span class="number">1</span>,:,<span class="built_in">i</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">        title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>) ], [<span class="string">&#x27;eigval=&#x27;</span> num2str(eigvals(<span class="number">1</span>,<span class="built_in">i</span>)) ])</span><br><span class="line">        subplot(<span class="number">4</span>,<span class="number">2</span>,<span class="built_in">i</span>*<span class="number">2</span>)</span><br><span class="line">        topoplot(double(pc(fi,<span class="number">2</span>,:,<span class="built_in">i</span>)),EEG.chanlocs,<span class="string">&#x27;electrodes&#x27;</span>,<span class="string">&#x27;off&#x27;</span>,<span class="string">&#x27;plotrad&#x27;</span>,<span class="number">.53</span>);</span><br><span class="line">        title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>)], [<span class="string">&#x27;eigval=&#x27;</span> num2str(eigvals(<span class="number">2</span>,<span class="built_in">i</span>)) ])</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">figure</span>(fi*<span class="number">2</span>)</span><br><span class="line">        sgtitle([<span class="string">&#x27;Frequency = &#x27;</span> num2str(frequencies(fi)) <span class="string">&#x27;Hz&#x27;</span>])</span><br><span class="line">        subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="built_in">i</span>)</span><br><span class="line">        <span class="comment">% PC time course for each trial, then average together</span></span><br><span class="line">        pctimes = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>,EEG.pnts);</span><br><span class="line">        <span class="keyword">for</span> triali=<span class="number">1</span>:EEG.trials</span><br><span class="line">            eeg = <span class="built_in">bsxfun</span>(@minus,<span class="built_in">squeeze</span>(convolution_result(fi,:,triali,:)),<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(convolution_result(fi,:,triali,:),<span class="number">4</span>))&#x27;);</span><br><span class="line">            pctimes(<span class="number">1</span>,:,:) = <span class="built_in">squeeze</span>(pctimes(<span class="number">1</span>,:,:))&#x27; + <span class="built_in">squeeze</span>(pc(fi,<span class="number">1</span>,:,<span class="built_in">i</span>))&#x27;*eeg;</span><br><span class="line">            pctimes(<span class="number">2</span>,:,:) = <span class="built_in">squeeze</span>(pctimes(<span class="number">2</span>,:,:))&#x27; + <span class="built_in">squeeze</span>(pc(fi,<span class="number">2</span>,:,<span class="built_in">i</span>))&#x27;*eeg;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">plot</span>(EEG.times,<span class="built_in">squeeze</span>(pctimes(<span class="number">1</span>,:,:)))</span><br><span class="line">        <span class="built_in">hold</span> on</span><br><span class="line">        <span class="built_in">plot</span>(EEG.times,<span class="built_in">squeeze</span>(pctimes(<span class="number">2</span>,:,:)))</span><br><span class="line">        set(gca,<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-200</span> <span class="number">1200</span>])</span><br><span class="line">        title([ <span class="string">&#x27;PC #&#x27;</span> num2str(<span class="built_in">i</span>)  ])</span><br><span class="line">        xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/23/VhqaPsYU2uKyjE5.png" alt="Ex_23(2.1)" style="zoom: 50%;" /></p>
<p><img src="https://s2.loli.net/2024/09/23/VtH1AECf8bPqegh.png" alt="Ex_23(2.2)" style="zoom: 50%;" /></p>
<p><img src="https://s2.loli.net/2024/09/23/lnPU2SOgCHZb3Jw.png" alt="Ex_23(2.3)" style="zoom: 50%;" /></p>
<p><img src="https://s2.loli.net/2024/09/23/MRHx9hgASXaz1JZ.png" alt="Ex_23(2.4)" style="zoom: 50%;" /></p>
</li>
</ol>
<hr>
<h1 id="Part-5"><a href="#Part-5" class="headerlink" title="Part 5"></a>Part 5</h1><h2 id="26-Phase-Based-Connectivity"><a href="#26-Phase-Based-Connectivity" class="headerlink" title="26 | Phase-Based Connectivity"></a>26 | Phase-Based Connectivity</h2><ol>
<li><p>Select <strong>one seed electrode</strong> and <strong>one frequency band</strong> and compute phase-based connectivity between that seed electrode and every other electrode. Use two methods for phase-based connectivity that were presented in this chapter, one that is volume conduction independent (e.g., PLI) and one that could produce spurious connectivity due to volume conduction (e.g., ISPC). Do not apply a baseline subtraction. Make topographical plots of seeded connectivity in a time window of your choice (e.g., 300 – 350 ms). What are the similarities and differences between results from the two methods, and what might be the reasons for the similarities and differences? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 26.1</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% Seed electrode</span></span><br><span class="line">channel = <span class="string">&#x27;p1&#x27;</span>;</span><br><span class="line">chanidx = <span class="built_in">find</span>(strcmpi(channel,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">% Select one frequency band</span></span><br><span class="line">frequency = <span class="number">5</span>;      <span class="comment">% in Hz</span></span><br><span class="line"><span class="comment">%% Perform Morlet wavelet </span></span><br><span class="line"><span class="comment">% wavelet and FFT parameters</span></span><br><span class="line">time          = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">half_wavelet  = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">numcycle = <span class="number">6</span>;</span><br><span class="line">n_wavelet     = <span class="built_in">length</span>(time);</span><br><span class="line">n_data        = EEG.pnts*EEG.trials;       </span><br><span class="line">n_convolution = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% create wavelet and take FFT</span></span><br><span class="line">s = numcycle/(<span class="number">2</span>*<span class="built_in">pi</span>*frequency);</span><br><span class="line">wavelet_fft = fft( <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*frequency.*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(s^<span class="number">2</span>))) ,n_convolution);</span><br><span class="line">    </span><br><span class="line">convolution_result = <span class="built_in">zeros</span>(EEG.nbchan,n_convolution);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    data_fft = fft(<span class="built_in">reshape</span>(EEG.data(channi,:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line">    convolution_result(channi,:) = ifft(wavelet_fft .* data_fft, n_convolution);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convolution_result = convolution_result(:,half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line"></span><br><span class="line">signal = <span class="built_in">reshape</span>(convolution_result,EEG.nbchan,EEG.pnts,EEG.trials);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Compute ISPC-trial and Imaginary coherence</span></span><br><span class="line">ISPC_trial = <span class="built_in">zeros</span>(EEG.nbchan,EEG.pnts);</span><br><span class="line">Imag_Coher = <span class="built_in">zeros</span>(EEG.nbchan,EEG.pnts);</span><br><span class="line"></span><br><span class="line">phase1 = <span class="built_in">squeeze</span>(<span class="built_in">angle</span>(signal(chanidx,:,:)));</span><br><span class="line">spec1 = sum(<span class="built_in">squeeze</span>(signal(chanidx,:,:)).*<span class="built_in">conj</span>(<span class="built_in">squeeze</span>(signal(chanidx,:,:))),<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:EEG.nbchan</span><br><span class="line">    phase2 = <span class="built_in">squeeze</span>(<span class="built_in">angle</span>(signal(channi,:,:)));</span><br><span class="line">    spec2 = sum(<span class="built_in">squeeze</span>(signal(channi,:,:)).*<span class="built_in">conj</span>(<span class="built_in">squeeze</span>(signal(channi,:,:))),<span class="number">2</span>); </span><br><span class="line">    specX = sum(<span class="built_in">squeeze</span>(signal(chanidx,:,:)).*<span class="built_in">conj</span>(<span class="built_in">squeeze</span>(signal(channi,:,:))),<span class="number">2</span>); </span><br><span class="line">    ISPC_trial(channi,:) = <span class="built_in">squeeze</span>(<span class="built_in">abs</span>(<span class="built_in">mean</span>(<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*(phase1-phase2)),<span class="number">2</span>)));</span><br><span class="line">    Imag_Coher(channi,:) = <span class="built_in">abs</span>(<span class="built_in">imag</span>(specX./<span class="built_in">sqrt</span>(spec1.*spec2)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">timewindow = [<span class="number">300</span> <span class="number">350</span>];</span><br><span class="line">[~, timewindowidx(<span class="number">1</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="number">1</span>)));</span><br><span class="line">[~, timewindowidx(<span class="number">2</span>)] = <span class="built_in">min</span>(<span class="built_in">abs</span>(EEG.times-timewindow(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">colormap jet</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">title(<span class="string">&#x27;ISPC-trials, no baseline correction&#x27;</span>)</span><br><span class="line">topoplot(<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(ISPC_trial(:,timewindowidx(<span class="number">1</span>):timewindowidx(<span class="number">2</span>)),<span class="number">2</span>)),EEG.chanlocs)</span><br><span class="line"><span class="comment">% set(gca,&#x27;CLim&#x27;,[0,0.8])</span></span><br><span class="line">colorbar</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">title(<span class="string">&#x27;Imaginary Coherence, no baseline correction&#x27;</span>)</span><br><span class="line">topoplot(<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(Imag_Coher(:,timewindowidx(<span class="number">1</span>):timewindowidx(<span class="number">2</span>)),<span class="number">2</span>)),EEG.chanlocs)</span><br><span class="line">set(gca,<span class="string">&#x27;CLim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>])</span><br><span class="line">colorbar</span><br></pre></td></tr></table></figure>
</li>
<li><p>Now apply a baseline subtraction to the results (you can choose the baseline time period). Are there any changes in the plots after baseline subtraction (note that the color scaling will be different after baseline subtraction), and how do results from the two analyses compare with each other after baseline subtraction? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% baseline</span></span><br><span class="line">baselinetm = [<span class="number">-400</span> <span class="number">-200</span>];</span><br><span class="line">baselineidx  = dsearchn(EEG.times&#x27;,baselinetm&#x27;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">repmat</span>(<span class="built_in">mean</span>(ISPC_trial(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">size</span>(ISPC_trial,<span class="number">2</span>));</span><br><span class="line">ISPC_baseline = ISPC_trial - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(ISPC_trial(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">size</span>(ISPC_trial,<span class="number">2</span>));</span><br><span class="line">Coher_baseline = Imag_Coher - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(Imag_Coher(:,baselineidx(<span class="number">1</span>):baselineidx(<span class="number">2</span>)),<span class="number">2</span>),<span class="number">1</span>,<span class="built_in">size</span>(Imag_Coher,<span class="number">2</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">title(<span class="string">&#x27;ISPC-trials, baseline corrected&#x27;</span>)</span><br><span class="line">topoplot(<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(ISPC_baseline(:,timewindowidx(<span class="number">1</span>):timewindowidx(<span class="number">2</span>)),<span class="number">2</span>)),EEG.chanlocs)</span><br><span class="line"><span class="comment">% set(gca,&#x27;CLim&#x27;,[-0.1,0.1])</span></span><br><span class="line">colorbar</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">title(<span class="string">&#x27;Imaginary Coherence, baseline corrected&#x27;</span>)</span><br><span class="line">topoplot(<span class="built_in">squeeze</span>(<span class="built_in">mean</span>(Coher_baseline(:,timewindowidx(<span class="number">1</span>):timewindowidx(<span class="number">2</span>)),<span class="number">2</span>)),EEG.chanlocs)</span><br><span class="line">set(gca,<span class="string">&#x27;CLim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>])</span><br><span class="line">colorbar</span><br></pre></td></tr></table></figure>
</li>
<li><p>From the results in exercise 1 above, pick one “ target ” electrode (any electrode other than the seed) and provide evidence, using additional data analyses if necessary, for or against that measure of phase-based connectivity between that electrode and the seed being driven by volume conduction. </p>
<ul>
<li>可以看出，对于可以排除volume conduction影响的相干性分析方法，如 Imaginary Coherence，baseline corrected前后的topographical map差异较小，而对于容易受volume conduction影响的分析方法，如ISPC-trial，baseline corrected前后有明显的差异。</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/24/DTP2Q6nIdCpgWVm.png" alt="Ex_26" style="zoom:50%;" /></p>
</li>
</ol>
<hr>
<h2 id="27-Power-Based-Connectivity"><a href="#27-Power-Based-Connectivity" class="headerlink" title="27 | Power-Based Connectivity"></a>27 | Power-Based Connectivity</h2><ol>
<li><p>Perform a power correlation analysis over time. Pick two electrodes and use a sliding time segment of three cycles (1.5 cycles on either side of each center time point). Average the results over trials. Perform this analysis at three frequencies and plot the time series of correlation coefficients. Next, repeat the analysis twice, using fixed time-segment lengths of 150 ms and 900 ms. Do the results differ according to the time segment length and the frequency band, and how are they different? In what situations would it be beneficial to use each window width parameter, and in what situations might problems or limitations arise? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Exercises 27.1</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">% perform time-frequency decomposition</span></span><br><span class="line"><span class="comment">% Select electrode</span></span><br><span class="line">channel1 = <span class="string">&#x27;Fz&#x27;</span>;</span><br><span class="line">channel2 = <span class="string">&#x27;O1&#x27;</span>;</span><br><span class="line">chanidx(<span class="number">1</span>) = <span class="built_in">find</span>(strcmpi(channel1,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line">chanidx(<span class="number">2</span>) = <span class="built_in">find</span>(strcmpi(channel2,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line"><span class="comment">% Select one frequency band</span></span><br><span class="line">frequencies = [<span class="number">5</span> <span class="number">10</span> <span class="number">15</span>];      <span class="comment">% in Hz</span></span><br><span class="line"><span class="comment">%% Perform Morlet wavelet </span></span><br><span class="line"><span class="comment">% wavelet and FFT parameters</span></span><br><span class="line">time          = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">half_wavelet  = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">numcycles = [<span class="number">5</span> <span class="number">7</span> <span class="number">9</span>];</span><br><span class="line">n_wavelet     = <span class="built_in">length</span>(time);</span><br><span class="line">n_data        = EEG.pnts*EEG.trials;       </span><br><span class="line">n_convolution = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">convolution_result = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies),<span class="built_in">length</span>(chanidx),n_convolution);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line"><span class="comment">% create wavelet and take FFT</span></span><br><span class="line">    s = numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*frequencies(fi));</span><br><span class="line">    wavelet_fft = fft( <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*frequencies(fi).*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(s^<span class="number">2</span>))) ,n_convolution);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> channi = <span class="number">1</span>:<span class="built_in">length</span>(chanidx)</span><br><span class="line">        data_fft = fft(<span class="built_in">reshape</span>(EEG.data(chanidx(channi),:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line">        convolution_result(fi,channi,:) = ifft(wavelet_fft .* data_fft, n_convolution);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">convolution_result = convolution_result(:,:,half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line">power = <span class="built_in">abs</span>(<span class="built_in">reshape</span>(convolution_result,<span class="built_in">length</span>(frequencies),<span class="built_in">length</span>(chanidx),EEG.pnts,EEG.trials)).^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Perform a power correlation over time, using a sliding time segment of three cycles</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">10</span>:<span class="number">800</span>;</span><br><span class="line">timewindow_1 = <span class="number">3</span>*<span class="number">500</span> ./ frequencies;       <span class="comment">% (in ms) half of three cycle</span></span><br><span class="line">timewindow_2 = <span class="number">150</span>/<span class="number">2</span>;       <span class="comment">% in ms</span></span><br><span class="line">timewindow_3 = <span class="number">900</span>/<span class="number">2</span>;       <span class="comment">% in ms</span></span><br><span class="line"></span><br><span class="line">times2saveidx = dsearchn(EEG.times&#x27;,times2save&#x27;);</span><br><span class="line">timewindowidx_1 = <span class="built_in">round</span>(timewindow_1/<span class="number">1000</span> * EEG.srate);</span><br><span class="line">timewindowidx_2 = <span class="built_in">round</span>(timewindow_2/<span class="number">1000</span> * EEG.srate);</span><br><span class="line">timewindowidx_3 = <span class="built_in">round</span>(timewindow_3/<span class="number">1000</span> * EEG.srate);</span><br><span class="line"></span><br><span class="line">Corr_3cycle = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies), <span class="built_in">length</span>(times2saveidx));</span><br><span class="line">Corr_150ms = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies), <span class="built_in">length</span>(times2saveidx));</span><br><span class="line">Corr_900ms = <span class="built_in">zeros</span>(<span class="built_in">length</span>(frequencies), <span class="built_in">length</span>(times2saveidx));</span><br><span class="line"><span class="comment">% perform correlation</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">   <span class="keyword">for</span> ti = <span class="number">1</span>:<span class="built_in">length</span>(times2save)</span><br><span class="line">       <span class="keyword">for</span> triali = <span class="number">1</span>:EEG.trials</span><br><span class="line">           <span class="comment">% a sliding time segment of 3 cycles</span></span><br><span class="line">            signal_1 = <span class="built_in">squeeze</span>(power(fi,<span class="number">1</span>,times2saveidx(ti)-timewindowidx_1(fi):times2saveidx(ti)+timewindowidx_1(fi),triali));</span><br><span class="line">            signal_2 = <span class="built_in">squeeze</span>(power(fi,<span class="number">2</span>,times2saveidx(ti)-timewindowidx_1(fi):times2saveidx(ti)+timewindowidx_1(fi),triali));</span><br><span class="line">            signal_1 = signal_1 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_1),<span class="built_in">size</span>(signal_1));</span><br><span class="line">            signal_2 = signal_2 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_2),<span class="built_in">size</span>(signal_2));</span><br><span class="line">            </span><br><span class="line">            Corr_3cycle(fi,ti) = Corr_3cycle(fi,ti) + signal_1&#x27; * signal_2 ./ <span class="built_in">sqrt</span>((signal_1&#x27;*signal_1) * (signal_2&#x27;*signal_2));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% fixed time segment of 150 ms</span></span><br><span class="line">            signal_1 = <span class="built_in">squeeze</span>(power(fi,<span class="number">1</span>,times2saveidx(ti)-timewindowidx_2:times2saveidx(ti)+timewindowidx_2,triali));</span><br><span class="line">            signal_2 = <span class="built_in">squeeze</span>(power(fi,<span class="number">2</span>,times2saveidx(ti)-timewindowidx_2:times2saveidx(ti)+timewindowidx_2,triali));</span><br><span class="line">            signal_1 = signal_1 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_1),<span class="built_in">size</span>(signal_1));</span><br><span class="line">            signal_2 = signal_2 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_2),<span class="built_in">size</span>(signal_2));</span><br><span class="line">            </span><br><span class="line">            Corr_150ms(fi,ti) = Corr_150ms(fi,ti) + signal_1&#x27; * signal_2 ./ <span class="built_in">sqrt</span>((signal_1&#x27;*signal_1) * (signal_2&#x27;*signal_2));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% fixed time segment of 900ms</span></span><br><span class="line">            signal_1 = <span class="built_in">squeeze</span>(power(fi,<span class="number">1</span>,times2saveidx(ti)-timewindowidx_3:times2saveidx(ti)+timewindowidx_3,triali));</span><br><span class="line">            signal_2 = <span class="built_in">squeeze</span>(power(fi,<span class="number">2</span>,times2saveidx(ti)-timewindowidx_3:times2saveidx(ti)+timewindowidx_3,triali));</span><br><span class="line">            signal_1 = signal_1 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_1),<span class="built_in">size</span>(signal_1));</span><br><span class="line">            signal_2 = signal_2 - <span class="built_in">repmat</span>(<span class="built_in">mean</span>(signal_2),<span class="built_in">size</span>(signal_2));</span><br><span class="line">            </span><br><span class="line">            Corr_900ms(fi,ti) = Corr_900ms(fi,ti) + signal_1&#x27; * signal_2 ./ <span class="built_in">sqrt</span>((signal_1&#x27;*signal_1) * (signal_2&#x27;*signal_2));</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Corr_3cycle = Corr_3cycle ./ EEG.trials;</span><br><span class="line">Corr_150ms = Corr_150ms ./ EEG.trials;</span><br><span class="line">Corr_900ms= Corr_900ms ./ EEG.trials;</span><br><span class="line"><span class="comment">%% plot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(frequencies)</span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">1</span>,fi)</span><br><span class="line">    <span class="built_in">plot</span>(times2save, <span class="built_in">squeeze</span>(Corr_3cycle(fi,:)),<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line">    <span class="built_in">plot</span>(times2save, <span class="built_in">squeeze</span>(Corr_150ms(fi,:)),<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(times2save, <span class="built_in">squeeze</span>(Corr_900ms(fi,:)),<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.8</span> <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    set(gca,<span class="string">&#x27;ylim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>],<span class="string">&#x27;xlim&#x27;</span>,[<span class="number">-300</span>,<span class="number">800</span>])</span><br><span class="line">    xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Correlation Coefficient&#x27;</span>)</span><br><span class="line">    title([<span class="string">&#x27;Correlation between &#x27;</span> num2str(channel1) <span class="string">&#x27; and &#x27;</span> num2str(channel2) <span class="string">&#x27; at &#x27;</span> num2str(frequencies(fi)) <span class="string">&#x27; Hz&#x27;</span>])</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;3 cycle&#x27;</span>,<span class="string">&#x27;150 ms&#x27;</span>,<span class="string">&#x27;900 ms&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/24/uXHri9PIn56ca7m.png" alt="Ex_27_1" style="zoom: 50%;" /></p>
<ul>
<li>从直观的角度，由于900ms的 timewindow比较长，所得出的结果也就较为平滑，而150ms timewindow下的correlation曲线波动明显更大。对于可变的3-Cycles timewindow，曲线的波动程度介于两者之间。在5Hz下，这种差异尤为明显，因为5Hz对应的周期更长，所需的timewindow（通常至少为3个周期）也就更长。</li>
</ul>
</li>
<li><p>Select two “ seed ” time-frequency-electrode windows and perform an exploratory power correlation <strong>over trials</strong> at one selected “ target ” electrode, as in figure 27.6C (plate 19) . Show the results in separate plots, and then show a time-frequency plot of correlation coefficient differences between the two seeds (Fisher- <em>Z</em> transform the coefficients before subtraction). Are there any striking qualitative differences between the two plots, and did plotting the difference map make the differences easier or more difficult to interpret? </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% Ex.27_2</span></span><br><span class="line">load sampleEEGdata.mat</span><br><span class="line"></span><br><span class="line">targetSensor = <span class="string">&#x27;C4&#x27;</span>;</span><br><span class="line">seedSensor1 = <span class="string">&#x27;Fz&#x27;</span>;</span><br><span class="line">seedSensor2 = <span class="string">&#x27;O1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">target_idx = <span class="built_in">find</span>(strcmpi(targetSensor,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line">seed_idx(<span class="number">1</span>) = <span class="built_in">find</span>(strcmpi(seedSensor1,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line">seed_idx(<span class="number">2</span>) = <span class="built_in">find</span>(strcmpi(seedSensor2,&#123;EEG.chanlocs.labels&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Perform Morlet wavelet on seed electrodes</span></span><br><span class="line"><span class="comment">% wavelet and FFT parameters</span></span><br><span class="line">seed_frex     = <span class="number">6</span>;      <span class="comment">% 选取的seed frequency</span></span><br><span class="line">time          = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">half_wavelet  = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">seed_numcycles     = <span class="number">4</span>;</span><br><span class="line">n_wavelet     = <span class="built_in">length</span>(time);</span><br><span class="line">n_data        = EEG.pnts*EEG.trials;</span><br><span class="line">n_convolution = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">convolution_result_seed = <span class="built_in">zeros</span>(<span class="built_in">length</span>(seed_idx),n_convolution);</span><br><span class="line"><span class="keyword">for</span> channi = <span class="number">1</span>:<span class="built_in">length</span>(seed_idx)</span><br><span class="line">    <span class="comment">% create wavelet and take FFT</span></span><br><span class="line">    s = seed_numcycles/(<span class="number">2</span>*<span class="built_in">pi</span>*seed_frex);</span><br><span class="line">    wavelet_fft = fft( <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*seed_frex.*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(s^<span class="number">2</span>))) ,n_convolution);</span><br><span class="line"></span><br><span class="line">    data_fft = fft(<span class="built_in">reshape</span>(EEG.data(seed_idx(channi),:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line">    convolution_result_seed(channi,:) = ifft(wavelet_fft .* data_fft, n_convolution) * <span class="built_in">sqrt</span>(s);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convolution_result_seed = convolution_result_seed(:,half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line">seed_tf = <span class="built_in">abs</span>(<span class="built_in">reshape</span>(convolution_result_seed,<span class="built_in">length</span>(seed_idx),EEG.pnts,EEG.trials)).^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Perform Morlet wavelet on target electrode</span></span><br><span class="line">target_frex      = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">2</span>),<span class="built_in">log10</span>(<span class="number">40</span>),<span class="number">20</span>);</span><br><span class="line">time             = <span class="number">-1</span>:<span class="number">1</span>/EEG.srate:<span class="number">1</span>;</span><br><span class="line">half_wavelet     = (<span class="built_in">length</span>(time)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">target_numcycles = <span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">3</span>),<span class="built_in">log10</span>(<span class="number">10</span>),<span class="number">20</span>);</span><br><span class="line">n_wavelet        = <span class="built_in">length</span>(time);</span><br><span class="line">n_data           = EEG.pnts*EEG.trials;</span><br><span class="line">n_convolution    = n_wavelet+n_data<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">convolution_result_target = <span class="built_in">zeros</span>(<span class="built_in">length</span>(target_frex),n_convolution);</span><br><span class="line"><span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(target_frex)</span><br><span class="line">    <span class="comment">% create wavelet and take FFT</span></span><br><span class="line">    s = target_numcycles(fi)/(<span class="number">2</span>*<span class="built_in">pi</span>*target_frex(fi));</span><br><span class="line">    wavelet_fft = fft( <span class="built_in">exp</span>(<span class="number">2</span>*<span class="number">1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*target_frex(fi).*time) .* <span class="built_in">exp</span>(-time.^<span class="number">2.</span>/(<span class="number">2</span>*(s^<span class="number">2</span>))) ,n_convolution);</span><br><span class="line"></span><br><span class="line">    data_fft = fft(<span class="built_in">reshape</span>(EEG.data(target_idx,:,:),<span class="number">1</span>,n_data),n_convolution);</span><br><span class="line">    convolution_result_target(fi,:) = ifft(wavelet_fft .* data_fft, n_convolution) * <span class="built_in">sqrt</span>(s);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">convolution_result_target = convolution_result_target(:,half_wavelet+<span class="number">1</span>:<span class="keyword">end</span>-half_wavelet);</span><br><span class="line">target_tf = <span class="built_in">abs</span>(<span class="built_in">reshape</span>(convolution_result_target,<span class="built_in">length</span>(target_frex),EEG.pnts,EEG.trials)).^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 计算seed electrode在所选取的timewindow内每一个trial的平均power，得到一个长EEG.trials的向量</span></span><br><span class="line">timewindow_seed = [<span class="number">100</span> <span class="number">300</span>];        <span class="comment">% 选取的seed time window</span></span><br><span class="line">timewindow_idx_seed = dsearchn(EEG.times&#x27;,timewindow_seed&#x27;);</span><br><span class="line">power_seed(<span class="number">1</span>,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(seed_tf(<span class="number">1</span>,timewindow_idx_seed(<span class="number">1</span>):timewindow_idx_seed(<span class="number">2</span>),:),<span class="number">2</span>));</span><br><span class="line">power_seed(<span class="number">2</span>,:) = <span class="built_in">squeeze</span>(<span class="built_in">mean</span>(seed_tf(<span class="number">2</span>,timewindow_idx_seed(<span class="number">1</span>):timewindow_idx_seed(<span class="number">2</span>),:),<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对target electrode下的每一个时间点，计算所有trials的power值与power_seed的correlation</span></span><br><span class="line">times2save = <span class="number">-300</span>:<span class="number">10</span>:<span class="number">800</span>;</span><br><span class="line">times2save_idx = dsearchn(EEG.times&#x27;,times2save&#x27;);</span><br><span class="line"></span><br><span class="line">Corr_trial = <span class="built_in">zeros</span>(<span class="built_in">length</span>(target_idx),<span class="built_in">length</span>(times2save),<span class="built_in">length</span>(target_frex));</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> seedi = <span class="number">1</span>:<span class="built_in">length</span>(seed_idx)</span><br><span class="line">    <span class="keyword">for</span> fi = <span class="number">1</span>:<span class="built_in">length</span>(target_frex)</span><br><span class="line">        <span class="keyword">for</span> ti = <span class="number">1</span>:<span class="built_in">length</span>(times2save_idx)</span><br><span class="line">            power_target = <span class="built_in">squeeze</span>(target_tf(fi,times2save_idx(ti),:));</span><br><span class="line">            Corr_trial(seedi,ti,fi) = corr(power_seed(seedi,:)&#x27;,power_target,<span class="string">&#x27;type&#x27;</span>,<span class="string">&#x27;Spearman&#x27;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% Fisher-Z</span></span><br><span class="line">    Corr_trial = <span class="number">0.5</span> .* <span class="built_in">log</span>((<span class="number">1</span>+Corr_trial) ./ (<span class="number">1</span>-Corr_trial));</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,seedi)</span><br><span class="line">    contourf(times2save,target_frex,<span class="built_in">squeeze</span>(Corr_trial(seedi,:,:))&#x27;,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">    colormap jet</span><br><span class="line">    set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>],<span class="string">&#x27;yscale&#x27;</span>,<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="built_in">round</span>(<span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">2</span>),<span class="built_in">log10</span>(<span class="number">40</span>),<span class="number">6</span>)))</span><br><span class="line">    xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">    ylabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">contourf(times2save,target_frex,<span class="built_in">squeeze</span>(Corr_trial(<span class="number">1</span>,:,:))&#x27;-<span class="built_in">squeeze</span>(Corr_trial(<span class="number">2</span>,:,:))&#x27;,<span class="number">40</span>,<span class="string">&#x27;linecolor&#x27;</span>,<span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">set(gca,<span class="string">&#x27;clim&#x27;</span>,[<span class="number">-0.2</span>,<span class="number">0.2</span>],<span class="string">&#x27;yscale&#x27;</span>,<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;ytick&#x27;</span>,<span class="built_in">round</span>(<span class="built_in">logspace</span>(<span class="built_in">log10</span>(<span class="number">2</span>),<span class="built_in">log10</span>(<span class="number">40</span>),<span class="number">6</span>)))</span><br><span class="line">xlabel(<span class="string">&#x27;Time(ms)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Frequency(Hz)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">axis off</span><br><span class="line">cb = colorbar;</span><br><span class="line">set(cb, <span class="string">&#x27;Ticks&#x27;</span>, [<span class="number">-0.2</span>, <span class="number">-0.1</span>, <span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.2</span>], <span class="string">&#x27;TickLabels&#x27;</span>, &#123;<span class="string">&#x27;-0.2&#x27;</span>, <span class="string">&#x27;-0.1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>&#125;);</span><br><span class="line">clim([<span class="number">-0.2</span> <span class="number">0.2</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/24/3rT9EtFOqDHcMZ1.png" alt="Ex_27_2" style="zoom: 50%;" /></p>
</li>
</ol>
<hr>
<h2 id="28-Granger-Prediction"><a href="#28-Granger-Prediction" class="headerlink" title="28 | Granger Prediction"></a>28 | Granger Prediction</h2><ol>
<li><p>How would you interpret panels A and C versus B and D in figure 28.8 (plate 21) ? Discuss advantages and disadvantages of baseline-normalized Granger prediction results for a study investigating the role of visual attention in healthy university students and in a study comparing visual attention in children with ADHD versus typically developing controls. </p>
<p><img src="https://s2.loli.net/2024/09/25/xvAqrZ4LGNEP26M.png" alt="image-20240925083902807"></p>
</li>
<li><p>Pick <strong>one electrode</strong> and <strong>one time segment</strong> and compute <strong>Granger prediction</strong> between that electrode (the “ seed ” ) and <strong>all other electrodes</strong> in <strong>that time segment</strong>. Before selecting a time segment, examine the ERP from that electrode and choose a time window that, based on the ERP, is likely to contain stationary data. Justify your selection of time segment and model order. Show the results in a topographical map and comment on any striking or salient features you observe. </p>
</li>
<li><p>From the electrode and time segment used above, recompute Granger prediction separately for the first 40 trials and the last 40 trials. Make topographical maps of the early and late experiment effects and their difference. Are there any notable topographical features that can be seen in the difference topographical map? If so, how would you interpret these effects if they were statistically significant (there is no need to perform statistics; base your answer on qualitative visual inspection)? </p>
</li>
</ol>
<hr>
<h2 id="29-Mutual-Information"><a href="#29-Mutual-Information" class="headerlink" title="29 | Mutual Information"></a>29 | Mutual Information</h2><ol>
<li>Pick two electrodes and two frequencies (one frequency per electrode) and compute mutual information over time and trials between power from the first electrode and phase from the second electrode. Justify your choice of bin size. Next, recompute mutual information using phase from the first electrode and power from the second electrode. Make sure you use the same bin size you used in the previous analysis, so the results are directly comparable. Plot the time courses of the mutual information from these two analyses. Do you notice any striking features in the results, and are there differences between using phase and power from the two different electrodes? </li>
</ol>
<ol>
<li>Pick one electrode and two frequency bands. Compute mutual information between phase in that electrode and power in all other electrodes, separately in those two frequency bands. Run this analysis for a prestimulus period (e.g., – 500 to – 100 ms) and a task-related period (e.g., +100 to +500 ms). Show topographical maps for each frequency band, the two time periods, and additionally for mutual information during the task period minus the baseline period. Comment on any topographically salient features and any differences between baseline and task periods. </li>
</ol>
<hr>
<h2 id="30"><a href="#30" class="headerlink" title="30 |"></a>30 |</h2><hr>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ol>
<li><p>把以ms为单位的时间转化为时间的索引index可以用<code>dsearchn</code>函数：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% convert requested times to indices</span></span><br><span class="line">times2saveidx = dsearchn(EEG.times&#x27;,times2save&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>把数据翻转后拼接在前后段，以减少artifacts，可以用<code>fliplr</code>或<code>flipud</code>实现：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">data2filter = [<span class="built_in">fliplr</span>(data2filter) data2filter <span class="built_in">fliplr</span>(data2filter)];</span><br><span class="line"></span><br><span class="line">filtered_result = filtered(<span class="keyword">end</span>/<span class="number">3</span>+<span class="number">1</span> : <span class="number">2</span>*<span class="keyword">end</span>/<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://yuxii.top">Icarus</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yuxii.top/post/c9dcc4e1.html">http://yuxii.top/post/c9dcc4e1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yuxii.top" target="_blank">Icarus</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://images2.alphacoders.com/907/907164.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/751f48aa.html"><img class="prev-cover" src="https://images2.alphacoders.com/907/907164.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">笔记 | Analyzing Neural Time Series Data</div></div></a></div><div class="next-post pull-right"><a href="/post/c9daa1a2.html"><img class="next-cover" src="https://images2.alphacoders.com/907/907164.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">笔记 | 矩阵理论（英）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-1"><span class="toc-text">Part 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-Exercise"><span class="toc-text">4.7 Exercise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-Exercises-for-Script-A"><span class="toc-text">4.7.1 Exercises for Script A</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-Exercises-for-Script-B"><span class="toc-text">4.7.2 Exercises for Script B</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-Exercises-for-Script-C"><span class="toc-text">4.7.3 Exercises for Script C</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-2"><span class="toc-text">Part 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-Exercise"><span class="toc-text">9.8 Exercise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-1"><span class="toc-text">9.8.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-2"><span class="toc-text">9.8.2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-3"><span class="toc-text">Part 3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-10-Convolution"><span class="toc-text">Exercises 10 | Convolution</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-1"><span class="toc-text">10.6.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-2"><span class="toc-text">10.6.2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-11-Fourier-Transform"><span class="toc-text">Exercises 11 | Fourier Transform</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-12-1"><span class="toc-text">11.12.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-12-2"><span class="toc-text">11.12.2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-12-3"><span class="toc-text">11.12.3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-12-Morlet-wavelets"><span class="toc-text">Exercises 12 | Morlet wavelets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-13-complex-Morlet-wavelets"><span class="toc-text">Exercises 13 | complex Morlet wavelets</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Create-a-family-of-complex-Morlet-wavelets"><span class="toc-text">1. Create a family of complex Morlet wavelets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Convolve-each-wavelet-with-EEG-data"><span class="toc-text">2. Convolve each wavelet with EEG data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Extract-power-and-phase"><span class="toc-text">3. Extract power and phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Make-topographical-plots-of-power-and-phase"><span class="toc-text">4. Make topographical plots of power and phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Repeat-step-4-for-activity-at-360-ms"><span class="toc-text">5. Repeat step 4 for activity at 360 ms.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Think"><span class="toc-text">6. Think</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#From-ChatGPT-for-reference-GPT-is-not-provided-with-corresponding-pictures"><span class="toc-text">(From ChatGPT for reference, GPT is not provided with corresponding pictures)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Are-there-any-prominent-topographical-features-in-power-or-in-phase"><span class="toc-text">(1) Are there any prominent topographical features in power or in phase?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Do-these-differ-for-different-frequencies"><span class="toc-text">(2) Do these differ for different frequencies?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Do-power-and-phase-have-similar-topographical-distributions"><span class="toc-text">(3) Do power and phase have similar topographical distributions?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Is-there-any-reason-to-suspect-that-they-might-have-similar-or-different-topographies"><span class="toc-text">(4) Is there any reason to suspect that they might have similar or different topographies?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Summary"><span class="toc-text">Summary:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Create-a-circular-colormap"><span class="toc-text">7.  Create a circular colormap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-14-filter-Hilbert"><span class="toc-text">Exercises 14 | filter-Hilbert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-15-The-Short-Time-FFT"><span class="toc-text">Exercises 15 | The Short-Time FFT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-16-Multitaper"><span class="toc-text">Exercises 16 | Multitaper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-18-Baseline-Normalization"><span class="toc-text">Exercises 18 | Baseline Normalization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-19-ITPC-Intertrial-Phase-Clustering"><span class="toc-text">Exercises 19 | ITPC (Intertrial Phase Clustering)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-20-Total-Phase-Locked-and-Non-Phase-Locked-Power-and-Intertrial-Phase-Consistency"><span class="toc-text">Exercises 20 | Total, Phase-Locked, and Non-Phase-Locked Power and Intertrial Phase Consistency</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-4"><span class="toc-text">Part 4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-22-Surface-Laplacian"><span class="toc-text">Exercises 22 | Surface Laplacian</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exercises-23-Principal-Components-Analysis-PCA"><span class="toc-text">Exercises 23 | Principal Components Analysis (PCA)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-5"><span class="toc-text">Part 5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Phase-Based-Connectivity"><span class="toc-text">26 | Phase-Based Connectivity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Power-Based-Connectivity"><span class="toc-text">27 | Power-Based Connectivity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Granger-Prediction"><span class="toc-text">28 | Granger Prediction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-Mutual-Information"><span class="toc-text">29 | Mutual Information</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30"><span class="toc-text">30 |</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tips"><span class="toc-text">Tips</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Icarus</div><div class="footer_custom_text"><p> <a style="margin-inline:5px"target="_blank" href="https://hexo.io/"> <img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"> </a> <a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"> <img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"> </a> <a style="margin-inline:5px"target="_blank" href="https://github.com/"> <img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"> </a> <a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"> <img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"> </a> </p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23li9HupCsmPHkMPu1',
      clientSecret: '57d262f73fe1f2ba8576cd9a61e2b7817941770b',
      repo: 'YuxiZhong.github.io',
      owner: 'YuxiZhong',
      admin: ['YuxiZhong'],
      id: '1da67ee4dbaec512e389c9a42e263895',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>